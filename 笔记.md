# 配置文件

---

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],

	//"semt"微震系统
	//"semt_carousel"轮播图微震系统
	//"tunnel"长沙铁建
	//"tunnel_1"随掘
	//"mining"随采
    "serve_for": "semt",
    "http_port": 11507,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": false,
    "ms_miningSignal": false,
    "save_full_msdata": false,
    "ms_tunnel": false,
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 0,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/var/kwang"
}

```

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.134",
            "device_port": 5086,
            "server_port": 5086
        }
    ],
    //"serve_for": "tunnel_1",
    "serve_for": "semt",
    "http_port": 11507,
    "realtime_interval": 1,
    "link_device": true,
    "time_sync": false,
    "timesync_interval": 10,
    
    "ms_experimental": false,
    "multi_chn_trig": false,
    "ms_grid_step": 0.1,
   
    "ms_tunnel_listen":false,    // 修改成是否有tcp通讯
    "warningType":0,  // warningType 异常预警计算类型（约定 1：铁建移动检波器时异常聚类  2：根据时间进行聚类提取 3：样本数量 4：提取次数）
    "ms_interface_type":0, //采集页面维度类型 0-XY 1-XZ 2-XYZ 
    "ms_mining_type":0,    //随采类型 0-无随采 1-随采 2-随掘
    "ms_components":1,     //微震通道分量设置，默认单分量
    "ms_rate": 0.8,
    "ms_mining":true,
    "ms_miningSignal":true,
    "ms_locating":true,
    "ms_tunnel":true,
    "save_full_msdata":true,
    "ms_trigger":true,
    "is_used_warning":true,

    "warningTimeSyncIntval":2,
    "warningTimeSync":true,
    "tunnel_server":"192.168.72.110",
    "tunnel_port":3002,

    "ftpUrl":"ftp://192.168.74.232:21/shfz/411081005643/WZ/",
    "ftpUserName":"ftpUser",
    "ftpPassWord":"testFTP123456",
    "upWSData":true,

    "digest_duration": 10,
    "optical_strain":true,
    "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    //"data_root": "/var/kwang/frame_data",
    "data_root": "/home/kwang/workspace/yuanqu",
    //"data_root": "/home/sma/workspace/yuanqu",
    "project_name":"库尔勒金川煤矿",
    "msg_receivers":"WangKun",
    "alarm_receivers":"WangKun",
    "leader_receivers":"GuoJinShuai",
    "probe_to":{
        "min_x":50,
        "max_x":50,
        "min_y":50,
        "max_y":50,
        "min_z":50,
        "max_z":10
    }
}
```

# 通道

| type_id | 数据类型                   | 通道数                              | 通道label           |
| ------- | -------------------------- | ----------------------------------- | ------------------- |
| 0       | 微震触发/微震极值/微震背景 | datachns[2/3/6]                     | dataChnLabel[2/3/6] |
| 1       | 接收电极reChannel（自电）  | datachns[0/1]                       | dataChnLabel[0/1]   |
| 2       | 发射电极eeChannel（激电）  |                                     |                     |
| 4       | 温度                       | datachns[4]                         |                     |
| 5       | 震电耦合（0+2+4）          | datachns[0]+datachns[2]+datachns[4] | dataChnLabel[5]     |
|         |                            |                                     |                     |

# 接口

```cpp
 Routes::Get(RoutesManager::router, "/devices",
              Routes::bind(&cmd::getDevices));
  Routes::Post(RoutesManager::router, "/save_devices",
              Routes::bind(&cmd::saveDevices));
```

```cpp
  void getDevices(const Rest::Request &request, Http::ResponseWriter response)
  {
    try
    {
      response.headers().add<Http::Header::ContentType>("application/json");
      //string devices = "{";
      string devices="{\"devices\":[";
      string id;
      string device_ip;
      string device_port;
      string server_port;
      auto iter = hzi::config.devicesMap.begin();
      for (; iter != hzi::config.devicesMap.end(); iter++)
      {
        id = std::to_string(iter->second.id);
        device_ip = iter->second.devIp;
        device_port = std::to_string(iter->second.devPort);
        server_port = std::to_string(iter->second.serverPort);
        std::ostringstream oss;
        oss << "{" << "\"id\":" << id << ",\"device_ip\":\"" << device_ip << "\",\"device_port\":" + device_port + ",\"server_port\":" + server_port + "}";
        string device = oss.str();
        // string device = std::format("{id: {0}, device_ip: {1}, device_port: {2}, device_port: {3}}",id,device_ip,device_port,sever_port);
        devices += device;
        devices += ",";
      }
      devices.pop_back();
      devices += "]}";
      response.send(Http::Code::Ok, devices.c_str());
    }
    catch(const std::exception &e)
    {
      response.send(Http::Code::Bad_Request, e.what());
    }
  }
```

```cpp
```

## apifox测试接口

```url
https://192.168.74.37:11507/devices
https://192.168.74.37:11507/save_devices/sys_config.json
```

## 错误码

* 200成功
* 405接口的方法类型搞错了。比如一个接口是POST方法，你发了GET请求。





# 数据库操作

---

## 查询

```cpp
auto rslt = conn.executeQuery(sqlQuery.c_str());

//获取字段函数
rslt.getInt("field");
rslt.getDouble("field");
rslt.getString("field");
```

## 存储过程

```cpp
Connection conn = hzi::config.pConnPool->getConnection();
PreparedStatement prp = conn.prepareStatement("INSERT INTO e_tunnel_locInfo (mining_loc,tmstamp) values(?,?) ON DUPLICATE KEY UPDATE tmstamp = values(tmstamp)");
conn.beginTransaction();
prp.bind(1, mining_locx);
prp.bind(2, (double)tmstamp);//时间戳转成double再存
prp.execute();
conn.commit();
```

```cpp
function "zdb::PreparedStatement::bind(int, int)" (declared at line 394)
function "zdb::PreparedStatement::bind(int, long long)" (declared at line 398)
function "zdb::PreparedStatement::bind(int, double)" (declared at line 402)
function "zdb::PreparedStatement::bind(int, time_t)" (declared at line 406)
```

## 时间戳相关

库表格式为`bigint`，8位，但存入库中不直接存uint64_t，而是强转为double再存入，用getDouble获取。

```cpp
//获取表内字面值，强转long long int。（uint64_t无法获取字面值）
uint64_t tm = msgSentToUsers.getDouble("tm");
cout<<"tm="<<tm<<endl;//和数据库中所存的值不等
cout<<"tm="<<static_cast<long long>(tm)<<endl;//和数据库中所存字面值相等
conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", static_cast<long long>(tm));

//但这里为什么uint64_t可以取数据库字面值？
string sqlMs = "SELECT * FROM `e_msevt_rslts` WHERE samp_time >=" + std::to_string(fromsampTime) +
                   " and samp_time <= " + std::to_string(endsampTime) + " and validity = 1";
auto rslt_ms = conn.executeQuery(sqlMs.c_str());
```







```cpp
//where?表示where可选，可不传值
//SELECT [cols冒号左侧为字段名field1,field2,...] FROM [tblName] [where];
//response：{"code":0,"data":[{"field1":"field1Val"},{"field2":"field2Val"},...]}
Routes::Get(RoutesManager::router, "/table/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData));//表查询
Routes::Get(RoutesManager::router, "/table1/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData1));//queryTblData1用的是pTempConnPool
```









## 表更新

```cpp
//UPDATE tblName set [请求体updates字段值] where [condition]
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));

//
Routes::Post(RoutesManager::router, "/update/:tblName/:refCol/:updateCol",
               Routes::bind(&cmd::updateColumnRef));

//delCondition传true：delete from [tblName]
//传where语句：delete from [tblName] where ...
//若请求体中有schema和values，遍历json数组schema获取要更新的字段名，遍历json数组value获取要更新的字段的值。请求体中还应有type，指明字段值的类型是string/float/double/int64：insert into [tblName] (field1, field2,...)values('value11','value12',...),('value21','value22',...) on duplicate key update field1=values(value1),field2=values(value2)...;插入多条记录，若有主键相同的记录改为update修改(on duplicate key)
Routes::Post(RoutesManager::router, "/table/:tblName/:delCondition?",
               Routes::bind(&cmd::updateTable));//表增删改


//UPDATE [tblName] set [请求体updates字段值] where [condition].
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));
```

* `response.headers().add<Http::Header::ContentType>("text/plain");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `text/plain`。这表示服务器返回的内容是纯文本格式
* `response.headers().add<Http::Header::ContentType>("application/json; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `application/json; charset='utf-8'`。这表示服务器返回的内容是JSON格式，并且使用UTF-8字符集进行编码。

## 上传图片

```cpp
Routes::Post(RoutesManager::router, "/upload_image/:name",
               Routes::bind(&cmd::uploadImage));

void uploadImage(const Rest::Request &request, Http::ResponseWriter response) {
  response.headers().add<Http::Header::ContentType>(
      "text/plain; charset='utf-8'");
  string name = request.param(":name").as<string>();
  if (request.body().empty() || name == "undefined") {
    response.send(Http::Code::No_Content, "没有传入图片！");
    return;
  } // 理论上，严谨的写法，还需要判断传入的 MIME type 是不是图片

  try {
    string path = "assets/images/" + name;
    std::ofstream fout(path);
    fout.write(request.body().data(), request.body().size());
    fout.close();
  } catch (std::exception &e) {
    string reason = "图片 " + name + " 写入目录错误：" + e.what();
    logErr(reason);
    response.send(Http::Code::Expectation_Failed, reason);
    return;
  }
  response.send(Http::Code::Ok, "图片 " + name + " 上传成功！");
}
```

## 上传数据文件

```cpp
Routes::Post(RoutesManager::router, "/upload_DateFile/:name",
               Routes::bind(&ms_comm::uploadDateFile));


void uploadDateFile(const Rest::Request &request,
                    Http::ResponseWriter response) {
  if (request.body().empty()) {
    response.send(Http::Code::No_Content, "The request body is empty");
    return;
  }
  string name = request.param(":name").as<string>();
  cout << " name = " << name << endl;
  try {
    if (0) {
      //电法反演数据处理
      string fileName2 = "test/1111.dat";
      std::ifstream dat_data("test/1111.dat", std::ios::in);
      string line_dat;

      if (!dat_data.is_open()) {
        return;
      }

      char deli = (fileName2.find(".dat") != std::string::npos) ? '\t' : ',';

      std::vector<string> words_dat; // 声明一个字符串向量
      std::vector<vector<float>> dataVec;

      // 读取数据
      while (std::getline(dat_data, line_dat)) {
        words_dat.clear();
        split_String(line_dat, deli, words_dat);
        //  cout<<" words_dat.size() = "<<words_dat.size()<<endl;
        if (words_dat.size() == 4) {
          vector<float> tmpData;
          tmpData.push_back(atof(words_dat[0].c_str()));
          tmpData.push_back(atof(words_dat[1].c_str()));
          tmpData.push_back(atof(words_dat[2].c_str()) - 720);
          tmpData.push_back(atof(words_dat[3].c_str()));
          dataVec.push_back(tmpData);
          // cout<<atof(words_dat[0].c_str())<<","
          //     <<atof(words_dat[1].c_str())<<","
          //     <<atof(words_dat[2].c_str())<<","
          //     <<atof(words_dat[3].c_str())<<endl;
        }
      }

      float dx = 5;
      float dy = 4;
      float dz = 20;
      float max_x, min_x, max_y, min_y, max_z, min_z;
      max_x = 960;
      min_x = 0;
      max_y = 510;
      min_y = 0;
      max_z = -575;
      min_z = -820;

      int xSize = int((max_x - min_x) / dx);
      int ySize = int((max_y - min_y) / dy);
      int zSize = int((max_z - min_z) / dz);
      cout << " size = " << dataVec.size() << " ," << xSize << " ," << ySize
           << "," << zSize << endl;
      //初始化网格
      vector<vector<vector<GridCell>>> grid;
      initializeGrid(grid, xSize, ySize, zSize);

      for (int i = 0; i < dataVec.size(); i++) {
        auto x = dataVec[i][0];
        auto y = dataVec[i][1];
        auto z = dataVec[i][2];
        auto p = dataVec[i][3];
        int x_index = int((x - min_x) / dx);
        int y_index = int((y - min_y) / dy);
        int z_index = int((z - min_z) / dz);
        // cout<<x_index<<" ,"<<y_index<<","<<z_index<<" ,"
        //     <<x_index<<" ,"<<y_index<<","<<z_index<<endl;
        GridCell cell;
        cell.hasValue = true;
        cell.value = p;
        cell.r = 1;
        cell.intersectValues.push_back(p);
        grid[x_index][y_index][z_index] = cell;
      }

      //克里金插值
      debugLog(" start applyKrigingInterpolation");
      int variogramType = 0; // 0 表示球状模型。1 表示指数模型。2 表示高斯模型。
      applyKrigingInterpolation(grid, xSize, ySize, zSize, variogramType);
      debugLog(" end applyKrigingInterpolation");

      // 2023-12-18 4:00:00
      uint64_t fromsampTime = 1702843200000;
      //保存结果
      auto classId = 30;
      int file_type = 3;
      int constSize = 16; // x,y,z,p 16字节
      unique_ptr<char[]> pHeadData = std::make_unique<char[]>(64);
      char *pHead = pHeadData.get();
      *(double *)(pHead) = (double)fromsampTime;
      *(uint16_t *)(pHead + 8) = constSize; //

      fs::path fileName(hzi::config.dataRoot);

      fileName /= relLocFromTime(fromsampTime) / std::to_string(classId) /
                  std::to_string(fromsampTime) / std::to_string(file_type);
      auto dir = fileName.parent_path();
      if (!fs::exists(dir)) {
        fs::create_directories(dir);
      }
      std::ofstream ofs(fileName, std::ofstream::binary);
      ofs.write(pHead, 64);
      for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
          for (int k = 0; k < zSize; ++k) {
            if (!grid[i][j][k].hasValue)
              continue;
            float x = min_x + i * dx + dx / 2.0;
            float y = min_y + j * dy + dy / 2.0;
            float z = min_z + k * dz + dy / 2.0;

            unique_ptr<char[]> pGridData = std::make_unique<char[]>(constSize);
            char *pGrid = pGridData.get();
            *(uint32_t *)(pGrid) = *((int32_t *)&x);
            *(uint32_t *)(pGrid + 4) = *((int32_t *)&y);
            *(uint32_t *)(pGrid + 8) = *((int32_t *)&z);
            *(uint32_t *)(pGrid + 12) = *((int32_t *)&grid[i][j][k].value);
            //   cout<<x<<","<<y<<","<<z<<","<<grid[i][j][k].value<<endl;
            ofs.write(pGrid, constSize);
          }
        }
      }

      ofs.close();
      cout << "OK" << endl;
      autoHandleData(fromsampTime);
      response.send(Http::Code::Ok, "OK");
      return;
    }

    // Read the request body (the CSV file) into a stringstream

    // std::ifstream csv_data("test/GathEP-X.csv", std::ios::in);
    // string line;
    // if (!csv_data.is_open())
    // {
    //       return;
    // }

    std::stringstream csv_data(request.body().data());

    std::string line;

    std::vector<string> words; // 声明一个字符串向量
    string word;
    string fileHead;
    // 读取标题行
    std::getline(csv_data, fileHead);
    split_String(fileHead, ',', words);
    int chns = 0;
    int points = 0;
    float deltT = 0;
    int prepoint = 0;
    cout << " 1 fileHead = " << fileHead << endl;
    if (words.size() >= 4) {
      chns = atoi(words[0].c_str());
      points = atoi(words[1].c_str());
      deltT = atof(words[2].c_str());
      prepoint = atoi(words[3].c_str());
    }
    cout << " chns = " << chns << " points = " << points << " deltT = " << deltT
         << " prepoint = " << prepoint << endl;

    float **pData = new float *[chns];
    for (int ch = 0; ch < chns; ++ch) {
      pData[ch] = new float[points];
    }
    int index = 0;
    // 读取数据
    while (std::getline(csv_data, line)) {
      words.clear();
      split_String(line, ',', words);
      if (words.size() >= chns) {
        for (int ch = 0; ch < chns; ++ch) {
          pData[ch][index] = atof(words[ch].c_str());
          // if(index < 3){
          //     cout<<pData[ch][index]<<"  ";
          // }
        }
      }
      //  if(index < 3)cout<<endl;
      index++;
    }
    //写入微震事件
    if (0) {
      // unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
      // char* pHead = pHeadData.get();
      const float voltageCoef = 3000.0 / 8388607.0;
      // for (int ch = 0; ch < chns; ++ch) {
      //   for(int pnt = 0;pnt <points;pnt++){
      //     pData[ch][pnt] /= voltageCoef;
      //   }
      // }
      cout << " -- 101 --" << chns << "," << points << endl;
      DataFrame msDf(chns, points);
      cout << " -- 1 --" << endl;
      auto tm = nowMS();
      msDf.setSampTime(tm);
      cout << " -- 2 --" << endl;
      msDf.addDevMask(1);
      cout << " -- 3 --" << endl;
      msDf.setDevMask();
      cout << " -- 4 --" << endl;
      msDf.setClassId(2);
      cout << " -- 5 --" << endl;
      msDf.setHeadValue(19, deltT);
      cout << " -- 61 --" << endl;
      int32_t *p32 = reinterpret_cast<int32_t *>(msDf.upData.get());
      for (int ch = 0; ch < chns; ++ch) {
        for (int pt = 0; pt < points; ++pt) {
          float value = pData[ch][pt];
          int32_t originalValue = static_cast<int32_t>(value * 8388607.0 / 3.0);
          p32[ch * points + pt] = originalValue;
        }
        // std::memcpy(msDf.upData.get() + ch * points * sizeof(float),
        // pData[ch], points * sizeof(float));
      }
      msDf.save();
      //   for (int i = 0; i < 10; ++i) {
      //     std::cout << p32[i] << " ";
      // }
      response.send(Http::Code::Ok, "OK");
      return;
    }

    logInfo("start handleSignalProcess_test");
    // string filepath =
    //     test_mining(pData, points, chns, deltT, prepoint);
    string filepath =
        handleSignalProcess_test(pData, points, chns, deltT, prepoint);
    logInfo(filepath);
    string rslt("{");
    rslt += "\"ms_miningSignal\": \"";
    rslt += std::to_string(hzi::config.ms_miningSignal);
    rslt += "\",";
    rslt += " \"tm\": \"";
    rslt += filepath;
    rslt += "\" } ";
    response.headers().add<Http::Header::ContentType>(
        "application/json; charset='utf-8'");
    // cout << " rslt = " << rslt << endl;

    response.send(Http::Code::Ok, rslt);
    // std::thread(test_scan).detach();
    //  fs::path peerPath(filepath);
    //  if (fs::exists(peerPath)) {
    //      Http::serveFile(response, peerPath.c_str());
    //  } else {
    //      response.send(Http::Code::No_Content, "no_content");
    //  }
    logInfo("endl handleSignalProcess");

  } catch (std::exception &e) {
    logErr(e.what());
    response.send(Http::Code::Expectation_Failed, " uploaded failed!");
    return;
  }
  // response.send(Http::Code::Ok, " uploaded successfully!");
}

```

```cpp
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],
    "serve_for": "semt",
    "http_port": 11504,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": false,
    "ms_miningSignal": false,
    "save_full_msdata": false,
    "ms_tunnel": false,
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 0,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://192.168.74.113:3308/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/home/yzheng/workspace/yuanqu"
}
```



