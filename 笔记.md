

# 概念

---

* 传感器：基站上有根线，线的远端是1号近端是16号。1号靠近迎头。
* 偏移距：第一个传感器距离迎头距离。4个传感器一组，距离过远把第一组移到迎头处，当前掘进里程-偏移距得到新的第一个传感器的坐标。

* 当前掘进里程：迎头的位置（每天更新）

* 【系统-工程参数-工作面名称/工作面长度和宽度】工作面：大巷侧面是煤层，从大巷侧面垂直开的巷道叫工作面，进风面/出风面以及最后横向挖通构成一个U字形，中间很薄的一层是煤层。可能高度600米只有3米的煤层，其他是岩层。

* 掘进是什么？目的是什么？：主要判断前面有没有构造：水/断层之类的，提前知道，有相应方法处理。

* 【系统-工程参数-空间参数】将煤底层位置设为（0，0，0）

* 【系统-工程参数-通道配置】S1表示基站，GR01表示第一个传感器。（问题：矿上把传感器位置放反了，把线的近端放在了靠近迎头。代码里逻辑可能后面要修改。）

* 【采集置参】：采样间隔

* 【数据采集策略】：为了节省内存，设定不存储指定的数据。

* 【数据提取】：1-最小比例~1+最大比例，作为比例，乘以 平均能量时窗内数据的均值。用时窗内数据进行比较，判断是否在掘进。只用背景数据判断。

  判断是否正在掘进：通过1h内数据，计算平均值。设定比例值作为基准，乘以平均值。后面取2min，若在范围内，则判断为在掘进。

* 【实时参数】：用全时数据拼接。进行处理。

# 数据处理

---

> * 自动提取（2min，选的时间段）+在自动提取的基础上进行偏移，显示提取图和偏移图。
>
> * 点击【执行】后，会在自动提取的基础上，执行滤波/振幅均衡…等处理，再进行偏移，显示提取图+处理后的图+在处理后数据基础上的偏移图。
> * 图：横坐标时间。点数/采样间隔。
> * 黄色的干涉源提取按钮：手动选择时间段进行提取。分段时长：得到有多少炮，数据求均值，得到1炮的数据。

### 提取

* 塑形：选取若干点数，在波形边缘进行，防止吉布斯效应。

* 因子道：所有道和该道进行XCOR。

* 互相关：互相关函数，在频率进行。某道和因子道，取某道所有点和因子道第一个点相乘，得到所有点结果相加，再除以点数。得到和因子道第一个点的互相关结果。以此类推，得到某道所有点的互相关结果。

  因子道和自身自相关。

### 滤波

* 陷波：消除50周的信号干扰，

### 偏移

传感器发送信号，一来一回，时间乘以速度（速度参数里设定的：P波，S波，导波：P波算的某个网格幅值+S波算的某个网格幅值），再除以2进行画圆，若网格在圆内部，则取这个点的幅值作为这个网格的值。综合起来就是16个通道的所有**幅值的绝对值**（因为幅值有正负）相加，得到某个网格的幅值。即偏移图，通过颜色表示幅值。

折线图，偏移图Y=0那条线上的幅值。

### 叠加信号偏移

再偏移。手动取时间段，计算这个时间段内所有的的偏移图结果（2min），相加再除（取均值）

### 通过偏移图进行验证输入的参数的效果。把效果好的参数填入实时参数内，然后进行自动处理，并保存为文件。

# 配置文件

---

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],

	//"semt"微震系统
	//"semt_carousel"轮播图微震系统
	//"tunnel"长沙铁建
	//"tunnel_1"随掘
	//"mining"随采
    "serve_for": "semt",
    "http_port": 11507,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": false,
    "ms_miningSignal": false,
    "save_full_msdata": false,
    "ms_tunnel": false,
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 0,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/var/kwang"
}

```

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.134",
            "device_port": 5086,
            "server_port": 5086
        }
    ],
    //"serve_for": "tunnel_1",
    "serve_for": "semt",
    "http_port": 11507,
    "realtime_interval": 1,
    "link_device": true,
    "time_sync": false,
    "timesync_interval": 10,
    
    "ms_experimental": false,
    "multi_chn_trig": false,
    "ms_grid_step": 0.1,
   
    "ms_tunnel_listen":false,    // 修改成是否有tcp通讯
    "warningType":0,  // warningType 异常预警计算类型（约定 1：铁建移动检波器时异常聚类  2：根据时间进行聚类提取 3：样本数量 4：提取次数）
    "ms_interface_type":0, //采集页面维度类型 0-XY 1-XZ 2-XYZ 
    "ms_mining_type":0,    //随采类型 0-无随采 1-随采 2-随掘
    "ms_components":1,     //微震通道分量设置，默认单分量
    "ms_rate": 0.8,
    "ms_mining":true,
    "ms_miningSignal":true,
    "ms_locating":true,
    "ms_tunnel":true,
    "save_full_msdata":true,
    "ms_trigger":true,
    "is_used_warning":true,

    "warningTimeSyncIntval":2,
    "warningTimeSync":true,
    "tunnel_server":"192.168.72.110",
    "tunnel_port":3002,

    "ftpUrl":"ftp://192.168.74.232:21/shfz/411081005643/WZ/",
    "ftpUserName":"ftpUser",
    "ftpPassWord":"testFTP123456",
    "upWSData":true,

    "digest_duration": 10,
    "optical_strain":true,
    "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    //"data_root": "/var/kwang/frame_data",
    "data_root": "/home/kwang/workspace/yuanqu",
    //"data_root": "/home/sma/workspace/yuanqu",
    "project_name":"库尔勒金川煤矿",
    "msg_receivers":"WangKun",
    "alarm_receivers":"WangKun",
    "leader_receivers":"GuoJinShuai",
    "probe_to":{
        "min_x":50,
        "max_x":50,
        "min_y":50,
        "max_y":50,
        "min_z":50,
        "max_z":10
    }
}
```

# 通道

| type_id | 数据类型                   | 通道数                              | 通道label           |
| ------- | -------------------------- | ----------------------------------- | ------------------- |
| 0       | 微震触发/微震极值/微震背景 | datachns[2/3/6]                     | dataChnLabel[2/3/6] |
| 1       | 接收电极reChannel（自电）  | datachns[0/1]                       | dataChnLabel[0/1]   |
| 2       | 发射电极eeChannel（激电）  |                                     |                     |
| 4       | 温度                       | datachns[4]                         |                     |
| 5       | 震电耦合（0+2+4）          | datachns[0]+datachns[2]+datachns[4] | dataChnLabel[5]     |
|         |                            |                                     |                     |

# 接口

```cpp
 Routes::Get(RoutesManager::router, "/devices",
              Routes::bind(&cmd::getDevices));
  Routes::Post(RoutesManager::router, "/save_devices",
              Routes::bind(&cmd::saveDevices));
```

```cpp
  void getDevices(const Rest::Request &request, Http::ResponseWriter response)
  {
    try
    {
      response.headers().add<Http::Header::ContentType>("application/json");
      //string devices = "{";
      string devices="{\"devices\":[";
      string id;
      string device_ip;
      string device_port;
      string server_port;
      auto iter = hzi::config.devicesMap.begin();
      for (; iter != hzi::config.devicesMap.end(); iter++)
      {
        id = std::to_string(iter->second.id);
        device_ip = iter->second.devIp;
        device_port = std::to_string(iter->second.devPort);
        server_port = std::to_string(iter->second.serverPort);
        std::ostringstream oss;
        oss << "{" << "\"id\":" << id << ",\"device_ip\":\"" << device_ip << "\",\"device_port\":" + device_port + ",\"server_port\":" + server_port + "}";
        string device = oss.str();
        // string device = std::format("{id: {0}, device_ip: {1}, device_port: {2}, device_port: {3}}",id,device_ip,device_port,sever_port);
        devices += device;
        devices += ",";
      }
      devices.pop_back();
      devices += "]}";
      response.send(Http::Code::Ok, devices.c_str());
    }
    catch(const std::exception &e)
    {
      response.send(Http::Code::Bad_Request, e.what());
    }
  }
```

```cpp
```

## apifox测试接口

```url
https://192.168.74.37:11507/devices
https://192.168.74.37:11507/save_devices/sys_config.json
```

## 错误码

* 200成功
* 405接口的方法类型搞错了。比如一个接口是POST方法，你发了GET请求。





# 数据库

---

## 查询

```cpp
auto rslt = conn.executeQuery(sqlQuery.c_str());

//获取字段函数
rslt.getInt("field");
rslt.getDouble("field");
rslt.getString("field");

//或者
auto ret = queryDb(conn,"SELECT * FROM e_users where user_name=? and password=PASSWORD(?)",user, pswd)
                 ? true
                 : false;
```

```cpp
//查询有记录则返回，否则返回字符串异常
template <typename... Args>
tl::expected<ResultSet, std::string> queryDb(Connection &conn, const char *sql, Args... args) 
{
  try 
  {
    ResultSet result = conn.executeQuery(sql, args...);
    if (result.next()) 
    {
      return result;
    } 
    else 
    {
      return tl::make_unexpected("not found in query: " + std::string(sql));
    }
  } 
  catch (sql_exception &e) 
  {
    return tl::make_unexpected("sql error for " + std::string(sql) + ": " + std::string(e.what()));
  }
}
```



## 插入（若存在则更新）

```mysql
"INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)"
```

## 存储过程

```cpp
Connection conn = hzi::config.pConnPool->getConnection();
PreparedStatement prp = conn.prepareStatement("INSERT INTO e_tunnel_locInfo (mining_loc,tmstamp) values(?,?) ON DUPLICATE KEY UPDATE tmstamp = values(tmstamp)");
conn.beginTransaction();
prp.bind(1, mining_locx);
prp.bind(2, (double)tmstamp);//时间戳转成double再存
prp.execute();
conn.commit();
```

```cpp
function "zdb::PreparedStatement::bind(int, int)" (declared at line 394)
function "zdb::PreparedStatement::bind(int, long long)" (declared at line 398)
function "zdb::PreparedStatement::bind(int, double)" (declared at line 402)
function "zdb::PreparedStatement::bind(int, time_t)" (declared at line 406)
```

## 时间戳相关

库表格式为`bigint`，8位，但存入库中不直接存uint64_t，而是强转为double再存入，用getDouble获取。

```cpp
//获取表内字面值，强转long long int。（uint64_t无法获取字面值）
uint64_t tm = msgSentToUsers.getDouble("tm");
cout<<"tm="<<tm<<endl;//和数据库中所存的值不等
cout<<"tm="<<static_cast<long long>(tm)<<endl;//和数据库中所存字面值相等
auto tmTmp = static_cast<long long>(tm);
conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", tmTmp);

//但这里为什么uint64_t可以取数据库字面值？
string sqlMs = "SELECT * FROM `e_msevt_rslts` WHERE samp_time >=" + std::to_string(fromsampTime) +
                   " and samp_time <= " + std::to_string(endsampTime) + " and validity = 1";
auto rslt_ms = conn.executeQuery(sqlMs.c_str());
```

```cpp
//where?表示where可选，可不传值
//SELECT [cols冒号左侧为字段名field1,field2,...] FROM [tblName] [where];
//response：{"code":0,"data":[{"field1":"field1Val"},{"field2":"field2Val"},...]}
Routes::Get(RoutesManager::router, "/table/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData));//表查询
Routes::Get(RoutesManager::router, "/table1/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData1));//queryTblData1用的是pTempConnPool
```

## 表更新

```cpp
//UPDATE tblName set [请求体updates字段值] where [condition]
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));

//
Routes::Post(RoutesManager::router, "/update/:tblName/:refCol/:updateCol",
               Routes::bind(&cmd::updateColumnRef));

//delCondition传true：delete from [tblName]
//传where语句：delete from [tblName] where ...
//若请求体中有schema和values，遍历json数组schema获取要更新的字段名，遍历json数组value获取要更新的字段的值。请求体中还应有type，指明字段值的类型是string/float/double/int64：insert into [tblName] (field1, field2,...)values('value11','value12',...),('value21','value22',...) on duplicate key update field1=values(value1),field2=values(value2)...;插入多条记录，若有主键相同的记录改为update修改(on duplicate key)
Routes::Post(RoutesManager::router, "/table/:tblName/:delCondition?",
               Routes::bind(&cmd::updateTable));//表增删改


//UPDATE [tblName] set [请求体updates字段值] where [condition].
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));
```

* `response.headers().add<Http::Header::ContentType>("text/plain");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `text/plain`。这表示服务器返回的内容是纯文本格式
* `response.headers().add<Http::Header::ContentType>("application/json; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `application/json; charset='utf-8'`。这表示服务器返回的内容是JSON格式，并且使用UTF-8字符集进行编码。

## 上传图片

```cpp
Routes::Post(RoutesManager::router, "/upload_image/:name",
               Routes::bind(&cmd::uploadImage));

void uploadImage(const Rest::Request &request, Http::ResponseWriter response) {
  response.headers().add<Http::Header::ContentType>(
      "text/plain; charset='utf-8'");
  string name = request.param(":name").as<string>();
  if (request.body().empty() || name == "undefined") {
    response.send(Http::Code::No_Content, "没有传入图片！");
    return;
  } // 理论上，严谨的写法，还需要判断传入的 MIME type 是不是图片

  try {
    string path = "assets/images/" + name;
    std::ofstream fout(path);
    fout.write(request.body().data(), request.body().size());
    fout.close();
  } catch (std::exception &e) {
    string reason = "图片 " + name + " 写入目录错误：" + e.what();
    logErr(reason);
    response.send(Http::Code::Expectation_Failed, reason);
    return;
  }
  response.send(Http::Code::Ok, "图片 " + name + " 上传成功！");
}
```

## 上传数据文件

```cpp
Routes::Post(RoutesManager::router, "/upload_DateFile/:name",
               Routes::bind(&ms_comm::uploadDateFile));


void uploadDateFile(const Rest::Request &request,
                    Http::ResponseWriter response) {
  if (request.body().empty()) {
    response.send(Http::Code::No_Content, "The request body is empty");
    return;
  }
  string name = request.param(":name").as<string>();
  cout << " name = " << name << endl;
  try {
    if (0) {
      //电法反演数据处理
      string fileName2 = "test/1111.dat";
      std::ifstream dat_data("test/1111.dat", std::ios::in);
      string line_dat;

      if (!dat_data.is_open()) {
        return;
      }

      char deli = (fileName2.find(".dat") != std::string::npos) ? '\t' : ',';

      std::vector<string> words_dat; // 声明一个字符串向量
      std::vector<vector<float>> dataVec;

      // 读取数据
      while (std::getline(dat_data, line_dat)) {
        words_dat.clear();
        split_String(line_dat, deli, words_dat);
        //  cout<<" words_dat.size() = "<<words_dat.size()<<endl;
        if (words_dat.size() == 4) {
          vector<float> tmpData;
          tmpData.push_back(atof(words_dat[0].c_str()));
          tmpData.push_back(atof(words_dat[1].c_str()));
          tmpData.push_back(atof(words_dat[2].c_str()) - 720);
          tmpData.push_back(atof(words_dat[3].c_str()));
          dataVec.push_back(tmpData);
          // cout<<atof(words_dat[0].c_str())<<","
          //     <<atof(words_dat[1].c_str())<<","
          //     <<atof(words_dat[2].c_str())<<","
          //     <<atof(words_dat[3].c_str())<<endl;
        }
      }

      float dx = 5;
      float dy = 4;
      float dz = 20;
      float max_x, min_x, max_y, min_y, max_z, min_z;
      max_x = 960;
      min_x = 0;
      max_y = 510;
      min_y = 0;
      max_z = -575;
      min_z = -820;

      int xSize = int((max_x - min_x) / dx);
      int ySize = int((max_y - min_y) / dy);
      int zSize = int((max_z - min_z) / dz);
      cout << " size = " << dataVec.size() << " ," << xSize << " ," << ySize
           << "," << zSize << endl;
      //初始化网格
      vector<vector<vector<GridCell>>> grid;
      initializeGrid(grid, xSize, ySize, zSize);

      for (int i = 0; i < dataVec.size(); i++) {
        auto x = dataVec[i][0];
        auto y = dataVec[i][1];
        auto z = dataVec[i][2];
        auto p = dataVec[i][3];
        int x_index = int((x - min_x) / dx);
        int y_index = int((y - min_y) / dy);
        int z_index = int((z - min_z) / dz);
        // cout<<x_index<<" ,"<<y_index<<","<<z_index<<" ,"
        //     <<x_index<<" ,"<<y_index<<","<<z_index<<endl;
        GridCell cell;
        cell.hasValue = true;
        cell.value = p;
        cell.r = 1;
        cell.intersectValues.push_back(p);
        grid[x_index][y_index][z_index] = cell;
      }

      //克里金插值
      debugLog(" start applyKrigingInterpolation");
      int variogramType = 0; // 0 表示球状模型。1 表示指数模型。2 表示高斯模型。
      applyKrigingInterpolation(grid, xSize, ySize, zSize, variogramType);
      debugLog(" end applyKrigingInterpolation");

      // 2023-12-18 4:00:00
      uint64_t fromsampTime = 1702843200000;
      //保存结果
      auto classId = 30;
      int file_type = 3;
      int constSize = 16; // x,y,z,p 16字节
      unique_ptr<char[]> pHeadData = std::make_unique<char[]>(64);
      char *pHead = pHeadData.get();
      *(double *)(pHead) = (double)fromsampTime;
      *(uint16_t *)(pHead + 8) = constSize; //

      fs::path fileName(hzi::config.dataRoot);

      fileName /= relLocFromTime(fromsampTime) / std::to_string(classId) /
                  std::to_string(fromsampTime) / std::to_string(file_type);
      auto dir = fileName.parent_path();
      if (!fs::exists(dir)) {
        fs::create_directories(dir);
      }
      std::ofstream ofs(fileName, std::ofstream::binary);
      ofs.write(pHead, 64);
      for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
          for (int k = 0; k < zSize; ++k) {
            if (!grid[i][j][k].hasValue)
              continue;
            float x = min_x + i * dx + dx / 2.0;
            float y = min_y + j * dy + dy / 2.0;
            float z = min_z + k * dz + dy / 2.0;

            unique_ptr<char[]> pGridData = std::make_unique<char[]>(constSize);
            char *pGrid = pGridData.get();
            *(uint32_t *)(pGrid) = *((int32_t *)&x);
            *(uint32_t *)(pGrid + 4) = *((int32_t *)&y);
            *(uint32_t *)(pGrid + 8) = *((int32_t *)&z);
            *(uint32_t *)(pGrid + 12) = *((int32_t *)&grid[i][j][k].value);
            //   cout<<x<<","<<y<<","<<z<<","<<grid[i][j][k].value<<endl;
            ofs.write(pGrid, constSize);
          }
        }
      }

      ofs.close();
      cout << "OK" << endl;
      autoHandleData(fromsampTime);
      response.send(Http::Code::Ok, "OK");
      return;
    }

    // Read the request body (the CSV file) into a stringstream

    // std::ifstream csv_data("test/GathEP-X.csv", std::ios::in);
    // string line;
    // if (!csv_data.is_open())
    // {
    //       return;
    // }

    std::stringstream csv_data(request.body().data());

    std::string line;

    std::vector<string> words; // 声明一个字符串向量
    string word;
    string fileHead;
    // 读取标题行
    std::getline(csv_data, fileHead);
    split_String(fileHead, ',', words);
    int chns = 0;
    int points = 0;
    float deltT = 0;
    int prepoint = 0;
    cout << " 1 fileHead = " << fileHead << endl;
    if (words.size() >= 4) {
      chns = atoi(words[0].c_str());
      points = atoi(words[1].c_str());
      deltT = atof(words[2].c_str());
      prepoint = atoi(words[3].c_str());
    }
    cout << " chns = " << chns << " points = " << points << " deltT = " << deltT
         << " prepoint = " << prepoint << endl;

    float **pData = new float *[chns];
    for (int ch = 0; ch < chns; ++ch) {
      pData[ch] = new float[points];
    }
    int index = 0;
    // 读取数据
    while (std::getline(csv_data, line)) {
      words.clear();
      split_String(line, ',', words);
      if (words.size() >= chns) {
        for (int ch = 0; ch < chns; ++ch) {
          pData[ch][index] = atof(words[ch].c_str());
          // if(index < 3){
          //     cout<<pData[ch][index]<<"  ";
          // }
        }
      }
      //  if(index < 3)cout<<endl;
      index++;
    }
    //写入微震事件
    if (0) {
      // unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
      // char* pHead = pHeadData.get();
      const float voltageCoef = 3000.0 / 8388607.0;
      // for (int ch = 0; ch < chns; ++ch) {
      //   for(int pnt = 0;pnt <points;pnt++){
      //     pData[ch][pnt] /= voltageCoef;
      //   }
      // }
      cout << " -- 101 --" << chns << "," << points << endl;
      DataFrame msDf(chns, points);
      cout << " -- 1 --" << endl;
      auto tm = nowMS();
      msDf.setSampTime(tm);
      cout << " -- 2 --" << endl;
      msDf.addDevMask(1);
      cout << " -- 3 --" << endl;
      msDf.setDevMask();
      cout << " -- 4 --" << endl;
      msDf.setClassId(2);
      cout << " -- 5 --" << endl;
      msDf.setHeadValue(19, deltT);
      cout << " -- 61 --" << endl;
      int32_t *p32 = reinterpret_cast<int32_t *>(msDf.upData.get());
      for (int ch = 0; ch < chns; ++ch) {
        for (int pt = 0; pt < points; ++pt) {
          float value = pData[ch][pt];
          int32_t originalValue = static_cast<int32_t>(value * 8388607.0 / 3.0);
          p32[ch * points + pt] = originalValue;
        }
        // std::memcpy(msDf.upData.get() + ch * points * sizeof(float),
        // pData[ch], points * sizeof(float));
      }
      msDf.save();
      //   for (int i = 0; i < 10; ++i) {
      //     std::cout << p32[i] << " ";
      // }
      response.send(Http::Code::Ok, "OK");
      return;
    }

    logInfo("start handleSignalProcess_test");
    // string filepath =
    //     test_mining(pData, points, chns, deltT, prepoint);
    string filepath =
        handleSignalProcess_test(pData, points, chns, deltT, prepoint);
    logInfo(filepath);
    string rslt("{");
    rslt += "\"ms_miningSignal\": \"";
    rslt += std::to_string(hzi::config.ms_miningSignal);
    rslt += "\",";
    rslt += " \"tm\": \"";
    rslt += filepath;
    rslt += "\" } ";
    response.headers().add<Http::Header::ContentType>(
        "application/json; charset='utf-8'");
    // cout << " rslt = " << rslt << endl;

    response.send(Http::Code::Ok, rslt);
    // std::thread(test_scan).detach();
    //  fs::path peerPath(filepath);
    //  if (fs::exists(peerPath)) {
    //      Http::serveFile(response, peerPath.c_str());
    //  } else {
    //      response.send(Http::Code::No_Content, "no_content");
    //  }
    logInfo("endl handleSignalProcess");

  } catch (std::exception &e) {
    logErr(e.what());
    response.send(Http::Code::Expectation_Failed, " uploaded failed!");
    return;
  }
  // response.send(Http::Code::Ok, " uploaded successfully!");
}

```

```cpp
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],
    "serve_for": "semt",
    "http_port": 11504,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": false,
    "ms_miningSignal": false,
    "save_full_msdata": false,
    "ms_tunnel": false,
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 0,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://192.168.74.113:3308/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/home/yzheng/workspace/yuanqu"
}
```

## 变量与表对应

| 变量                                           | 表名                                                 | 说明 |
| ---------------------------------------------- | ---------------------------------------------------- | ---- |
| hzi::viewSpace                                 | e_space                                              |      |
| hzi::densityGrays                              | p_density_grays                                      |      |
| hzi::densityColors                             | p_density_colors                                     |      |
| hzi::msEvtCnf.sampIntvl                        | p_samp_intvls                                        |      |
| hzi::msEvtCnf.msAheadPnt                       | p_points                                             |      |
| hzi::msEvtCnf.pulsWid，hzi::msEvtCnf.ringThrld | e_ms_samp_config                                     |      |
| hzi::msEvtCnf.msThrldsMap                      | e_chns_config（chn_label，ms_trig_thrld,is_ms_trig） |      |
| hzi::viewSpace                                 | e_speed                                              |      |
| hzi::viewSpace.vtispeed_vector                 | e_vti_speeds                                         |      |
| hzi::chnState                                  | e_chns_config（chn_label, state_id）                 |      |
|                                                |                                                      |      |

## 表说明

| 表名             | 说明                                 |
| ---------------- | ------------------------------------ |
| e_send_frm_log   | 服务器向设备发送的命令的日志         |
| e_station_info   | 基站监测，【基站检测应答帧】参数入库 |
| e_dev_clock      | 时间校准，【时间校准应答帧】参数入库 |
| e_dev_config_ack | 参数配置，【参数配置应答帧】参数入库 |
| e_users          | 用户名，密码                         |
|                  |                                      |

# 登录

表`e_users`

## （1）验证用户名密码

```cpp
//接口
Routes::Post(RoutesManager::router, "/auth_user", Routes::bind(&cmd::authUser));


void authUser(const Rest::Request &request, Http::ResponseWriter response)
{
  Document bodyDoc;
  if (bodyDoc.Parse(request.body().c_str()).HasParseError())
  {
    response.send(Http::Code::Bad_Request, "用户认证格式错");
  }
  string userPswd = bodyDoc["user_pswd"].GetString();
  response.headers().add<Http::Header::ContentType>("text/plain");
  verifyUser(userPswd)
      .map([&](auto r)	{ response.send(Http::Code::Ok, "user_verified:ok"); })
      .map_error([&](auto err)	{ response.send(Http::Code::Unauthorized, "user_verified:failed"); });
}

bool verifyUser(string user, string pswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  auto ret = queryDb(conn, "SELECT * FROM e_users where user_name=? and password=PASSWORD(?)", user, pswd)
                 ? true : false;
  return ret;
}

tl::expected<int, string> verifyUser(string userPswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  return queryDb(conn, "SELECT FROM_BASE64(?) as user", userPswd.c_str())
      .and_then([&](ResultSet userPsw) -> tl::expected<int, string>
                {
    				auto user = string(userPsw.getString("user"));
    				auto colonPos = user.find(":");
    				if (colonPos != string::npos) 
                    {
    				  auto userName = user.substr(0, colonPos);
    				  auto psw = user.substr(colonPos + 1);
    				  return queryDb(conn,
    				                 "SELECT * FROM e_users where user_name=? and "
    				                 "password=PASSWORD(?)",
    				                 userName, psw)
    				      .and_then([&](auto r) { return tl::expected<int, string>(0); });
    				} 
                })
      .or_else([&](auto e) -> tl::expected<int, string>
               {
    			cout << "error:" << e << "\n";
    			return tl::make_unexpected(string("error verifying user:") + e); 
               });
}
```

## （2）修改密码

```cpp
//接口
Routes::Post(RoutesManager::router, "/password/:user/:pswd", Routes::bind(&cmd::changePswd));

void changePswd(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":user").as<string>();
  auto pswd = request.param(":pswd").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  try
  {
    conn.execute("UPDATE e_users set password=PASSWORD(?) where user_name=?",
                 pswd, userName);
    response.send(Http::Code::Ok, "ok");
  }
  catch (sql_exception &err)
  {
    response.send(Http::Code::Bad_Request, err.what());
  }
  // conn.close();
}
```

## （3）用户是否存在

```cpp
//接口
Routes::Get(RoutesManager::router, "/users/:name", Routes::bind(&cmd::userExists));

void userExists(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":name").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  queryDb(conn, "SELECT * from e_users where user_name=?", userName.c_str())
      .map([&](auto r)
           { response.send(Http::Code::Ok, "ok"); })
      .map_error([&](auto err)
                 {
      if (err.find("not found") != string::npos) {
        response.send(Http::Code::Not_Found, "not found");
      } else {
        response.send(Http::Code::Bad_Request, err);
      } });
  // conn.close();
}
```

## （4）用户名密码验证登录流程

```cpp
//commands.cpp
void login(const Rest::Request &request, Http::ResponseWriter response)
```

# 数据采集

---

## （1）原始帧

### 命令字（cmd_id）

| **命令功能** | **命令字** | **字节数****(Byte)** |
| ------------ | ---------- | -------------------- |
| 基站检测     | **0x01**   | 1                    |
| 时间校准     | **0x02**   | 1                    |
| 采集置参     | **0x03**   | 1                    |
| 启动监测     | **0x04**   | 1                    |
| 停止监测     | **0x05**   | 1                    |
| IP地址设置   | **0x06**   | 1                    |
| 连接检测     | **0x07**   | 1                    |
| 对时         | **8**      | 1                    |
| 对时         | **9**      | 1                    |

### 原始信号类型（class_id）

| **类型**       | **通信值**  | **定义**                             |
| -------------- | ----------- | ------------------------------------ |
| 自电数据       | 0x00        | 电法通道实时监测采集信号             |
| 激电数据       | 0x01        | 主动发射引起的激发电场采集信号       |
| 微震触发数据   | 0x02        | 微震通道阈值触发引起的微震采集信号   |
| 微震极值数据   | 0x03        | 微震通道一定时窗内的背景极大值       |
| 温度数据       | 0x04        | 温度通道实时采集的信号               |
| 震电磁耦合数据 | 0x05        | 微震通道耦合阈值引起的全通道采集信号 |
| 微震背景数据   | 0x06        | 微震通道环境背景实时采集信号         |
| 伽玛传感器数据 | 0x0b （11） | 伽马传感器实时采集数据               |

### 数据区

| **字节序号** | **大小（字节）** | **功能**                         | **参数说明**                                                 |
| ------------ | ---------------- | -------------------------------- | ------------------------------------------------------------ |
| D0~D7        | 8                | 采集时间                         | 采集时间8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00 UTC |
| D8           | 1                | 数据类型classId                  | **类型**            **属性**            **说明**                  0x00            自电数据            自然电位信号                  0x01            激电数据            发射电法采集信号                  0x02            微震触发数据            微震触发信号                  0x03            微震极值数据            微震时窗极值信号                  0x04            温度数据            实时温度信号                  0x05            震电磁耦合数据            震电磁‘耦合’信号                  0x06            背景数据            实时采集的背景信号 |
| D9           | 1                | 是否包含电流通道                 | 0x0：否 0x1:是                                               |
| D10~D11      | 2                | 包含通道数                       | 数据量包含数据通道数                                         |
| D12~D15      | 4                | 每通道包含点数                   | 每通道数据点数                                               |
| D16          | 1                | 发射帧序号                       | 电法发射帧序号                                               |
| D17~D18      | 2                | 信号触发通道号                   | 用于微震的信号触发时值最大的通道                             |
| D19          | 1                | 激电发射电压                     | **发射电压**            **说明**                  24V            参考通信值约定中的电压**类型**。                  48V                  72V                  96V |
| D20          | 1                | 该帧数据采集时刻激电是否正在采集 | 0x00:否 0x01:是                                              |
| D21          | 1                | 对时模块网络状态                 | 0x00:失联  0x01:正常                                         |
| D22~D29      | 8                | 对时模块时间信息                 | 8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00  UTC |
| D30          | 1                | 激励电法发射模式                 | 0x00:单正 0x01:正负正 0x02:M序列                             |
| D31          | 1                | 触发通道数                       |                                                              |

* 数据区：电流数据+电压数据
* 电流数据：4字节表示一个电流值，第一个字节最高位为符号位!  总点数为每通道包含点
* 电压数据：4字节表示一个电压值，第一个字节最高位为符号位! 总点数为电法发射采集模式：（包含通道数-1）*每通道包含点数；其余模式：包含通道数*每通道包含点
* 温度数据：2字节表示一个温度值



## （2）数据帧DataFrame（上位机中使用的）

### 数据类型（从什么原始信号构建的数据帧）

| df.classId() | 数据类型 |
| ------------ | -------- |
| 1            | 激电     |
| 2            | 微震事件 |
| 3            | 微震背景 |
| 4            | 温度数据 |
| 5            | 耦合数据 |
| 6            | 微震全时 |
|              |          |
| 9            | 提取     |
| 10           | 偏移     |
| 99           | 再提取   |

| 文件头     |            |                                           |          |                        |
| ---------- | ---------- | ----------------------------------------- | -------- | ---------------------- |
| 位置(字节) | 大小(字节) | 定义                                      | 数据类型 | 说明                   |
| 0          | 8          | 采样时间                                  | double   | 时间戳，毫秒           |
| 8          | 1          | 采样数据类型id                            | uint     | 按协议定义             |
| 9          | 1          | 是否包含电流通道                          | uint8_t  | 1:包含； 0:不包含      |
| 10         | 2          | 包含通道数                                | uint16_t | DataFrame::setChannels |
| 12         | 4          | 每通道数据点数                            | uint32_t | DataFrame::setPoints   |
| 16         | 1          | 激电发射帧序号或微震触发通道号            | uint8_t  |                        |
| 17         | 1          | 激电发射或微震触发基站ID号,主要用于多基站 | uint8_t  |                        |
| 18         | 1          | 保留                                      |          |                        |
| 19         | 4          | 采样间隔                                  | float    | 毫秒                   |
| 23         | 1          | 激电激发类型id                            | uint8_t  | 按协议定义             |
| 24         | 1          | 激电发射电压id                            | uint8_t  |                        |
| 25         | 1          | 该帧数据采集时刻激电是否正在采集          | uint8_t  | 0x00:否，0x01:是       |
| 26         | 1          | 设备拼接掩码                              | uint8_t  | 对应拼接设备ID         |
| 27         | 1          | 是否为拼接帧                              |          |                        |
| 28         | 1          | 激电电压模式                              | uint8_t  | 0:固定；1:智能         |
| 29         | 4          | 保留                                      |          |                        |

| 数据区     |                          |                                      |          |                                |
| ---------- | ------------------------ | ------------------------------------ | -------- | ------------------------------ |
| 位置(字节) | 大小(字节)               | 定义                                 | 数据类型 | 说明                           |
| 32         | 通道数x 每通道数据点数x4 | 原始采样数据值按通道、数据点顺序存放 | int      | 含电流通道时，第一道为电流数据 |

* 字节序：小字节序（高位在后，低位在前）
* 协议：指本公司《微震电法并行物理场监测系统采集通信约定》 
* 数据值： int类型的采样原始数据，未乘系数 
* 从系统页面下载数据文件名约定： yyyy_mm_dd_采集数据类型 id_采样时间戳.semt.bin 
