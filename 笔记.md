

# 1. 系统概述与业务

---

* 传感器：基站上有根线，线的远端是1号，近端是16号。1号靠近迎头。每个传感器线上固定间距5m。

* 当前掘进里程（掘进位置）：迎头的位置（每天更新）

* 【系统-工程参数-工作面名称/工作面长度和宽度】工作面：大巷侧面是煤层，从大巷侧面垂直开的巷道叫工作面，进风面/出风面以及最后横向挖通构成一个U字形，中间很薄的一层是煤层。可能高度600米只有3米的煤层，其他是岩层。

* 掘进是什么？目的是什么？：主要判断前面有没有构造：水/断层之类的，提前知道，有相应方法处理。

* 【系统-工程参数-空间参数】将煤底层位置设为（0，0，0）

* 【系统-工程参数-通道配置】S1表示基站，GR01表示第一个传感器。（问题：矿上把传感器位置放反了，把线的近端放在了靠近迎头。代码里逻辑可能后面要修改。）

* 【采集置参】：关注**采样间隔**

* 【数据存储策略】：为了节省内存，设定不存储指定的数据。

* 【系统-随掘监测-数据提取】：【1-最小比例~1+最大比例】作为比例，乘以【平均能量时窗】内数据（背景数据）的均值。用【时窗】内数据（背景数据）进行比较，判断是否在掘进。（用背景数据进行判断。全时数据数据量太大）

  判断是否正在掘进过程：通过1h内数据，计算平均值，平均值乘以比例作为基准。后面时窗即以2min为单位计算平均值，若在范围内，则判断这个时窗内为正在掘进。

* 【系统-随掘监测-实时参数】：用全时数据，根据设定参数自动进行提取处理。（随掘地震那里的设定，是为了修改参数值，通过偏移图看效果，找到最适合的参数，填入实施参数的设定参数进行自动提取。）

  监测前方距离：超前探测距离。

  拼接数据类型：一般是微震全时，即在全时数据的基础上进行提取，得到提取图。

# 2. 随掘地震概述

---

【目的】：监测掘煤前方的地质结构，提前预知水/岩石/煤的存在，做好措施。

【软件系统】：通道采集原始信号，经过干涉源提取生成提取数据和【图提取】。再经过滤波/振幅均衡/反褶积/反射波提取/偏移，得到偏移数据和【偏移图】。最后，通过【界面提取】，从偏移图中提取界面的坐标点和与横轴夹角。最后通过【聚类】算法，对提取的界面进行处理，找出真正的地质异常（也就是分层面），绘制在【首页的巷道探测示意图】。

波在介质中传播，当介质的密度突然发生改变时会发生反射。使用传感器接收反射波，通过系统处理，发现不同介质的分层。随掘系统，波的震源是掘锚机，通道（传感器）打在两侧的墙壁上。掘锚机的波向后首先到达传感器，这个波叫做直达波，在提取图上表现为最左侧的一些波，提取前需要去掉；而且因为通道号越大距离掘锚机越远，直达波到达的越晚，所以各个通道的直达波波形是从左上角向右下角。向前的波经过地质遇到分层会反射回来，再次被传感器收到，这个波是我们需要的。

# 3. 测试环境搭建

---

### 数据路径

数据放入：`var/kwang/frame_data/2025/4/5`

3-背景原始数据

6-全时原始数据

9-提取数据

10-偏移数据

99-再提取数据

### 库表设置

* `var/kwang/frame_data/2025/4/5/6`和`var/kwang/frame_data/2025/4/5/3`下文件的名称需和表`e_data_frm_info`记录保持一致。
* `var/kwang/frame_data/2025/4/5/9`下文件名称要和表`e_mining_signaldata_frm_info`保持一致
* `var/kwang/frame_data/2025/4/5/10`下文件名称要和表`e_mining_pcodata_frm_info`保持一致
* `e_chn_types`
* `e_chns_config`
* `e_chns_config_history`
* `e_chns_config_tunnel`
* `e_mining_PCOLocParm`
* `e_mining_PCOSignalParm`
* `e_mining_PCOSignalParm_history`
* `e_tunnel_extractPara`

# 4. 微震参数含义

---

### 干涉提取

* 塑形：选取若干点数，在波形边缘进行，防止吉布斯效应。

* 因子道：所有道和该道进行互相关。

* 互相关：互相关函数，在频率进行。某道和因子道，取某道所有点和因子道第一个点相乘，得到所有点结果相加，再除以点数。得到和因子道第一个点的互相关结果。再和因子道第二个点……以此类推，得到某道所有点的互相关结果。

  因子道和自身自相关。

* 因子时长：`转成ms，除以采样间隔`得到`pcoParm.coeLen`。

### 滤波

> * 作用：消除50HZ的信号干扰
>
> * 原理：
>
> 

### 偏移

传感器发送信号，一来一回，时间乘以速度（速度参数里设定的：P波，S波，导波：P波算的某个网格幅值+S波算的某个网格幅值），再除以2进行画圆，若网格在圆内部，则取这个点的幅值作为这个网格的值。综合起来就是16个通道的所有**幅值的绝对值**（因为幅值有正负）相加，得到某个网格的幅值。即偏移图，通过颜色表示幅值。

折线图，偏移图Y=0那条线上的幅值。

### 叠加信号偏移

再偏移。手动取时间段，将时间段内所有的的偏移图结果（2min），相加再除（取均值）。

# 5. 干涉提取+再提取+偏移

---

> * 实时计算：干涉源提取+再提取+偏移成图。
> * 历史计算：干涉源提取+偏移成图。再提取需要手动点执行。
>
> * 所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
>
> > 若用【背景】原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。（读表到类型变量`hzi::mining_classId`）
> >
> > 若用【全时】原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。

| -                    | 说明                                                  |
| -------------------- | ----------------------------------------------------- |
| `getPCO_parm(true)`  | 读取实时计算参数表`e_mining_PCOSignalParm`到`pcoParm` |
| `setPCOLocParm()`    | 读取参数到`pcoLocParm`                                |
| `setPCOCalChn()`     | 读取参数到`pcoCalChnParms`                            |
| `setSignalChnInfo()` | 读取参数到`pcoExtractChnParms`。自相关/互相关。       |

### 库表

| 表名                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | **9类型数据**。提取图数据                                    |
| e_mining_pcodata_frm_info      | **10类型数据。**偏移图数据                                   |
|                                |                                                              |
| e_mining_PCOSignalParm         | **实时计算参数，信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **历史计算参数，信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。`Notch_jobs`是陷波滤波类型，0-奇偶倍，1-奇数倍，2-偶数倍，3-一倍。`notchF`是陷波频率，目前实时计算时陷波频率还是写死50hz。 |
| e_mining_PCOLocParm            | **实时/历史计算，坐标等参数值。回采位置/回采方向/日进尺/回采位置更新日期**等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | 回采位置/回采位置对应时间戳/日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | 当前使用的通道的设备/编号/类型                               |
| e_chns_config_history          | 从中读取通道历史信息参与历史计算                             |
|                                |                                                              |
|                                |                                                              |

## （0）所有用到提取+再提取流程算法的函数汇总

> [!TIP]
>
> 在这里总结一下所有会用到这些流程的函数，方便后续增/改算法时，不会遗漏

| `ms_mining.cpp-handleSignalProcess` | 调用该函数的                                                 |
| ----------------------------------- | ------------------------------------------------------------ |
|                                     | `/handerSignal/:from_time/:to_time/:time_len/:devId`         |
|                                     | `/handerSignalMining/:from_time/:to_time/:time_len/:devId`   |
|                                     | `/handerTunnelSignal/:start_loc/:end_loc/:time_len`          |
|                                     |                                                              |
|                                     | `threadHanleData`                                            |
|                                     | `threadHanleData_tunnel`，这个函数被`handleTimeStamp_tunnel`调用。这个函数被很多地方调用。 |

| `ms_mining.cpp--getPCO_parm()` | -    |
| ------------------------------ | ---- |
|                                |      |
|                                |      |
|                                |      |
|                                |      |

### 道内均衡

代码中所有保存道内均衡参数的类型：

```cpp
//PCOSignalProcess.hpp
struct PCOSignalParm
    
//ms_mining.hpp
struct PCODeAGC
```

| 道内均衡 | 用到的地方                                                   | 函数功能                                                    | 上层调用                                                     |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
|          | `ms_mining.cpp--getPCO_parm()`                               | 从库表读参数                                                |                                                              |
|          | `PCOSignalProcess.cpp--L241`，并行计算函数`ParallelCorrelation::operator()` | 实时计算                                                    | `ms_mining.cpp--handleSignalProcess()`                       |
|          |                                                              |                                                             |                                                              |
|          | `ms_mining.cpp--handleExtSignalData_pianyi()`                | 读取指定时间段内的提取文件（9），生成偏移文件（10）         | 被接口`/handerExtSignalPianYi/:from_time/:to_time`调用。     |
|          | `ms_mining.cpp--parseDeAGC()`                                | `parseDeAGC()`从`methods`中解析json格式的算法参数参与计算。 | 被接口`/handerExtSignal/:samp_time/:typeId`调用。调用`processMethods()`进行再提取计算，写文件到99。`processMethods()`中调用`parseDeAGC()` |
|          | `PCOSignalProcess.cpp--PureCommonOperation::handleSignalData` | ` PureCommonOperation::handleSignalData`执行再提取算法。    | 被接口`/handerExtSignalParm/:samp_time/:typeId`调用。`handerExtSignalParm`，调用`handleExtSignalData`，调用`PureCommonOperation::handleSignalData` |
|          |                                                              |                                                             |                                                              |
|          | `PCOSignalProcess.cpp--L3232，handleDataFrameVec_test()`     | 测试用                                                      | `ms_mining.cpp--handleSignalProcess_test()`                  |
|          |                                                              |                                                             |                                                              |
|          |                                                              |                                                             |                                                              |



## （1）实时代码流程

> [!IMPORTANT]
>
> 实时：自动进行【提取+再提取+偏移】，保存提取文件9，保存偏移文件10，但不保存文件99（历史重算保存）。
>
> * `main.cpp--realTimeCal()`开个线程。
> * `ConnectServer.cpp--realTimeCal()`线程执行函数`while(1)`循环。
> * `ms_mining.cpp--threadHanleData()`循环执行。
>
> * 拼帧：`ms_mining.cpp--mergeMs()`：时间段内的1炮数据，拼成一个帧。多炮数据的多个帧存在`dfvec`里。
>
> * 提取+再提取：`ms_mining.cpp--handleSignalProcess(dfvec, true)`：先读表取计算参数。根据入参flag确定再提取若干操作的标志位，flag==true，则进行再提取；flag==false，不进行再提取。`handleSignalProcess`调用：
>
> > * `ms_miining.cpp--PureCommonOperation::handleDataFrameVec_signal`：并行计算函数，其中包含的操作依次有：【预处理】、【信号加窗】、【相关计算】、【滑动时窗】、【一维频域滤波】、【反褶积】、【一维频域滤波】、【道内均衡】（AGC、指数增益）、【道间均衡】、【反射波提取】，这些操作都有标志位决定是否执行。
> >
> >   结果存于`pOutSignal`。
> >
> > * 计算偏移图数据：`isUseCSP=0`【无CSP道集提取】，其中调用`PureCommonOperation::CalMigration(pOutSignal,pOut_tmp)`，计算偏移图数据。
> >
> >   结果存于`pOut_tmp`。
> >
> > * 保存偏移图数据文件10类型：`saveResult(true)`，传入`true`表示进行异常提取。将`pOut_tmp`中数据保存于10类型文件。入库表`e_mining_pcodata_frm_info`。
> >
> > * 保存提取数据文件9类型：将`pOutSignal`中数据保存为9类型文件。入库表`e_mining_signaldata_frm_info`。
>
> 

### ※拼帧

> [!NOTE]
>
> * `ms_mining.cpp`中`mergeMs()`。
> * `MergeMs`是把指定时间段内的（若干次采样）若干个6/3原始数据文件的数据拼成1个帧。
> * 每个6/3原始数据文件，只包含1次采样时间内的数据。
> * 每个6/3原始数据文件都包含了所有通道1次采样的数据。

```cpp
if (dev_id == 0)
{
    int devId = hzi::sysDevMask;
    //按channels分组，按各组条数降序排列。取1条记录，即channels条数最多。
    auto rslt0 = conn.executeQuery(
        "select channels,count(1) as number from e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?) and dev_id = ? GROUP BY channels ORDER BY "
        "count(1) desc limit 1",
        hzi::mining_classId, fromtime, endtime, devId);
    if (rslt0.next())
    {
        chns0 = rslt0.getInt("channels");   //获取通道数
    }

    auto rslt = conn.executeQuery(
        "SELECT samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?)  AND channels = ?  and dev_id = ? ORDER BY "
        "samp_time ASC",
        hzi::mining_classId, fromtime, endtime, chns0, devId);

    while (rslt.next())
    {
        pnts0 = rslt.getInt("ch_pnts");		//获取1次采样的点个数
        auto pathstr = rslt.getString("frm_loc");	//数据文件路径
        pnts += pnts0;  //[fromtime,endtime]时间段内一个通道的所有点数之和
        pathVector.push_back(pathstr);  //每个数据文件的路径
    }
    if (pnts0 == 0 || pnts == 0 || chns0 == 0)
        return tl::make_unexpected("DataFrame::merge: The data for that time period is empty");
   
    DataFrame newDF(chns0, pnts); // 所有通道在时间段内的所有点，拼一个大的帧，帧数据大小chns0*pnts*4B
    string path = Config::dataRoot + "/";
    for (int i = 0; i < pathVector.size(); i++)
    {
        auto filePath = path + pathVector[i];	//原始数据文件路径
        if (!fs::exists(filePath))
            return tl::make_unexpected("DataFrame::merge: file Path error");
        std::ifstream ifs(filePath);
        auto fileSize = fs::file_size(filePath);
        DataFrame fileDF(chns0, pnts0);	//保存一个数据文件的小帧
        ifs.read(fileDF.upHead.get(), 32); //从数据文件读数据头到fileDF帧
        // ifs.seekg(0);
        ifs.read(fileDF.upData.get(), fileSize - 32);   //从数据文件读数据体到fileDF帧
        ifs.close();
        
        //把fileDF帧中数据拷贝到大的数据帧里
        if (i == 0)	//第一次拷贝时，需要把小帧的头拷贝到大帧的头，改下点数为大帧存的点数
        {
            memcpy(newDF.upHead.get(), fileDF.upHead.get(), 32); 
            newDF.setPoints(pnts); // fileDF在memcpy时把newDF原本的pnts改成了pnts0，这里重新设置回来
        }

        //把每次采样的数据文件中的数据，遍历通道，拷贝到newDF中（外面i循环是数据文件数，ch循环对每个数据文件的通道数）
        for (int ch = 0; ch < chns0; ch++)
        {
            memcpy(newDF.upData.get() + ch * pnts * 4 + i * pnts0 * 4,
                   fileDF.upData.get() + ch * pnts0 * 4, pnts0 * 4);
        }
    }

    //返回拼好的大帧
    return std::move(newDF);
```

### ※提取+再提取

> [!NOTE]
>
> * 函数`handleSignalProcess(dfvec, true)`，传入false只进行提取。传入true时，才会提取+再提取。`dfvec`中存储多炮的数据，即多个拼帧得到的大帧。
>
> * 读表获取参数
>
>   | -                    | 说明                                                  |
>   | -------------------- | ----------------------------------------------------- |
>   | `getPCO_parm(true)`  | 读取实时计算参数表`e_mining_PCOSignalParm`到`pcoParm` |
>   | `setPCOLocParm()`    | 读取参数到`pcoLocParm`                                |
>   | `setPCOCalChn()`     | 读取参数到`pcoCalChnParms`                            |
>   | `setSignalChnInfo()` | 读取参数到`pcoExtractChnParms`。自相关/互相关。       |
>
> * `pOutSignal`用于保存并行计算处理结果。
> * `PureCommonOperation::handleDataFrameVec_signal`并行计算，对每一炮数据开个线程异步计算，依次执行：【加窗，预处理】，【信号加窗】，【滑动时窗】，【相关计算】，【一维滤波】，【反褶积】，【一维滤波】，【道内均衡】，【道间均衡】，【反射波提取】。
> * `pOut_tmp`用于保存偏移计算结果。

```cpp
/*
* 多炮数据处理
* 实时计算（flag=true）：
* 历史重算（flag=false）：只进行干涉源提取，不进行其他计算
*/
string handleSignalProcess(std::vector<DataFrame *> dfVec, bool flag, int dev_id)
{
    auto deltT = dfVec[0]->sampIntvl();//采样间隔
    auto tmStmp = dfVec[0]->sampTime();//采样时间（跟踪一下拼帧后的帧的采样时间是什么含义）
    auto devId = dfVec[0]->devMask();
    float speed_p, speed_s = 0;
    bool is_evenSpeed = 0;
    auto pntss = dfVec[0]->points();
    int useVType = 0; // 默认使用P波偏移，偏移类型（0-P波 ，1-S波 2-PS波)

    PureCommonOperation::PCOLocParm pcoLocParm;
    PureCommonOperation::PCOSignalParm pcoParm;
    bool outType = 0;
    int outSurLineId = 0; // 随采输出测线id 使用测线数量
    int isUseCSP = 0;
    bool ret = getPCO_parm(pcoParm, pcoLocParm, deltT, flag, outType, outSurLineId, isUseCSP, useVType, is_evenSpeed, speed_p, speed_s);

    auto conn = hzi::config.pConnPool->getConnection();

    double dateTime = (double)tmStmp / 1000.0;
    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(tmStmp, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    if (!hzi::config.ms_tunnel_listen)
    {
        hzi::tunnel_mining_loc = pcoLocParm.m_locx;
    }

    if (hzi::config.verbose)
        cout << " 回采位置：" << pcoLocParm.m_locx << endl;

    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }
    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }

    pcoParm.ms_components = hzi::config.ms_components;
    pcoLocParm.out_type = 1;

    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);

    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    // 先找出所有通道，进行分量和测线配置，然后删除不需要的通道  devId
    setPCOCalChn(pcoCalChnParms, hzi::sysDevMask, tmStmp, flag);

    for (int i = 0; i < 3; i++)
    {
        pcoParm.dataChnNO[i] = pcoParm.chnno;
    }

    if (pcoParm.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            auto chn_no = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            auto is_out = rslt_comp.getInt("is_out");
            if (is_out)
                pcoLocParm.out_type = id;
            if (flag)
            {
                // 实时计算
                pcoParm.dataChnNO[id - 1] = chn_no;
            }
            else
            {
                // 历史计算
                pcoParm.dataChnNO[id - 1] = chn_no_history;
            }
            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                    //  cout<<" 通道号："<<num<<" 分量："<<id<<" enb = "<<pcoCalChnParms[num-1].enb <<endl;
                }
            }
        }
    }

    // auto surveyLineCount = 1;//测线数量 1-机载式，2-双巷式，3-混合式
    // systemeType = 0 系统类型：0-双巷式，1-机载式，2-组合式'
    int lineArry[3] = {0};
    //  int mining_singalCount = 0;
    if (hzi::config.ms_mining_type == 1)
    {
        auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
        while (rslt_surveyLine.next())
        {
            auto id = rslt_surveyLine.getInt("id");
            // surveyLineCount = (id > surveyLineCount) ? id : surveyLineCount;
            auto chnsList = rslt_surveyLine.getString("chnsList");

            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            lineArry[id - 1] = chns_List.size();
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].id = id; //测线id
                    // cout<<" 通道号："<<num<<" 测线："<<id<<endl;
                }
            }
        }
        // mining_singalCount = getSignalChnCount(pcoParm.systemeType ,pcoParm.ImageType,lineArry[0],lineArry[1],lineArry[2],hzi::config.ms_components);

        for (int i = 0; i < 3; i++)
        {
            if (dev_id != 0)
            {
                if (lineArry[i] != 0 && dev_id == i + 1)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
            else
            {
                if (lineArry[i] != 0)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
        }
    }

    //随掘
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        //  pcoLocParm.is_exclude_directWaves = true;
        if (pcoParm.ms_components > 1)
        {
            auto chnno_tmp = pcoParm.dataChnNO[0];
            pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
        }
        else
        {
            pcoLocParm.fx = pcoCalChnParms[pcoParm.chnno - 1].x;
            pcoLocParm.fy = pcoCalChnParms[pcoParm.chnno - 1].y;
            pcoLocParm.fz = pcoCalChnParms[pcoParm.chnno - 1].z;
        }
    }

    if (dev_id != 0)
    {
        // 指定测线数据处理 取对应基站的坐标 默认基站号与测线号对应
        pcoCalChnParms.erase(
            std::remove_if(
                pcoCalChnParms.begin(),
                pcoCalChnParms.end(),
                [dev_id](const PureCommonOperation::PCOCalChn &elem)
                {
                    return elem.id != dev_id;
                }),
            pcoCalChnParms.end());
    }
    // 在此区分随掘和随采的信号提取通道数量 随采根据测线来决定

    int vecSize = dfVec.size();//炮数
    auto chns = dfVec[0]->channels();//

    PureCommonOperation::PCOExtractChn pcoExtractChnParms;
    setSignalChnInfo(pcoExtractChnParms, pcoCalChnParms, pcoParm, chns);
    // cout<<" count = "<<pcoExtractChnParms.count
    //     <<" , chnno = "<<pcoExtractChnParms.chnNoVec.size()
    //     <<" , coechnno = "<<pcoExtractChnParms.coeChnNoVec.size()<<",chns = "<<chns<<endl;

    auto valChnns = pcoExtractChnParms.count;
    // auto valChnns =(hzi::config.ms_mining_type == 1) ? mining_singalCount : chns;
    auto valNum = valChnns * vecSize;//通道数*炮数
    // cout<<" valNum = "<<valNum<<endl;
    auto iGrdNum =
        pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    pcoParm.mining_fx = pcoLocParm.fx;
    pcoParm.mining_fy = pcoLocParm.fy;
    pcoParm.mining_fz = pcoLocParm.fz;
    pcoParm.chns_Count = valChnns;
    pcoParm.chns = chns;
    // // 历史重算 只进行干涉源提取
    // if (!flag)
    // {
    //     pcoParm.isCut = 0;
    //     pcoParm.isCalRandon = false;
    //     pcoParm.isSpikeDeconvolution = false;
    //     pcoParm.deAGCtype = 0;
    //     isUseCSP = 0;
    //     pcoParm.interChnAmpEqual_type = 0;
    // }
    // 采煤机定位 随采采煤机定位
    int sumCount_jh = 170;
    float dis = 1.75;
    if (hzi::config.ms_mining_type == 1 && hzi::start_jh != 0 && hzi::end_jh != 0)
    {
        //  float dis_y = (pcoLocParm.m_dYMax - pcoLocParm.m_dYMin)/100;
        float y = pcoLocParm.m_dYMin + hzi::start_jh * dis;
        float dis_y = (hzi::end_jh - hzi::start_jh) * dis / vecSize;

        pcoLocParm.fx = pcoLocParm.m_locx;
        pcoLocParm.fy = y;
        pcoLocParm.fz = pcoLocParm.fz;
        pcoLocParm.dis_y = dis_y;
    }
    // cout<<"size = "<<dfVec.size()<<" , 通道："<<dfVec[0]->channels()<<", 时间戳"<<std::to_string(dfVec[0]->sampTime())
    //     <<"震源位置："<<pcoLocParm.fx<<" ,"<<pcoLocParm.fy<<", 间隔："<<pcoLocParm.dis_y<<endl;;


    /*
    * 对每炮数据进行处理：加窗，预处理，滑动时窗，相关，一维滤波，反褶积，道内均衡，道间均衡，反射波提取
    */
    float **pOutSignal = new float *[valChnns * vecSize];
    for (int dex = 0; dex < vecSize; dex++)
    {
        for (int ch = 0; ch < valChnns; ++ch)
        {
            pOutSignal[ch + dex * valChnns] = new float[pcoParm.outLen];
            memset(pOutSignal[ch + dex * valChnns], 0,
                   sizeof(float) * pcoParm.outLen);
        }
    }

    if (!flag)// 历史重算 只进行干涉源提取
    {
        pcoParm.isCut = 0;//无滤波
        pcoParm.isCalRandon = false;//无反射波提取
        pcoParm.isSpikeDeconvolution = false;//无反褶积
        pcoParm.deAGCtype = 0;//无道内均衡
        isUseCSP = 0;// 无CSP道集提取
        pcoParm.interChnAmpEqual_type = 0;//无道间均衡
    }
    PureCommonOperation::handleDataFrameVec_signal(
        std::move(dfVec), pcoParm, &pcoCalChnParms[0], pOutSignal, pcoExtractChnParms);
    logInfo(" handleDataFrameVec_signal  endl ");
    //上面：结果存于pOutSignal：实时--提取+再提取，历史--提取


    bool isSavePianyi = true;
    // CSP道集提取 已经生成了偏移图，不用进行偏移了
    if (isUseCSP != 0)
    {
        // 随采 散射 CSP道集提取
        isSavePianyi = false;
        if (hzi::config.ms_mining_type == 1 && pcoParm.ImageType == 0)
        {
            PureCommonOperation::CSPTraceParm cspParm;
            cspParm.nComponentCount = hzi::config.ms_components;
            cspParm.iCalTraces = pcoExtractChnParms.count;
            cspParm.nSamplePoints = pcoParm.outLen - pcoParm.coefBegPt;
            cspParm.fSampleInterval = deltT;
            cspParm.nAdvanPoints = 0;
            cspParm.fPV = speed_p;
            cspParm.fSV = speed_s;
            int surLineNum = (pcoParm.systemeType == 0) ? 2 : ((pcoParm.systemeType == 1) ? 1 : 3);

            float **pSignal = new float *[valChnns * vecSize];
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < valChnns; ++ch)
                {
                    // pSignal[ch + dex * valChnns] = new float[cspParm.nSamplePoints];
                    pSignal[ch + dex * valChnns] = new float[static_cast<int>(cspParm.nSamplePoints)];
                    for (int i = 0; i < cspParm.nSamplePoints; i++)
                    {
                        pSignal[ch + dex * valChnns][i] = pOutSignal[ch + dex * valChnns][i + pcoParm.coefBegPt];
                    }
                }
            }

            getCSPTrace(tmStmp, pSignal, pcoCalChnParms, cspParm, pcoLocParm,
                        pcoExtractChnParms, surLineNum);
        }
    }
    else
    {
        // 三分量需要叠加时使用
        //  float* pOut = new float[iGrdNum];
        //  memset(pOut, 0, sizeof(float) * iGrdNum);
        // 多分量分别设置
        for (int com = 0; com < pcoParm.ms_components; com++)
        {

            auto pretime = pcoParm.coefBegPt;

            pcoLocParm.is_evenspeed = is_evenSpeed;

            float *pOut_tmp = new float[iGrdNum];
            memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

            if (useVType < 2)//P波偏移或S波偏移
            {
                // float* pOut_tmp = new float[iGrdNum];
                // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

                float *pSpeedBtr = new float[iGrdNum];
                memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                for (int i = 0; i < iGrdNum; i++)
                {
                    if (useVType == 0)
                    {
                        pSpeedBtr[i] = speed_p;
                    }
                    else
                    {
                        pSpeedBtr[i] = speed_s;
                    }
                }
                getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                             coal_z, layer_from, is_evenSpeed);

                auto pretime2 = pretime * deltT;
                if (hzi::config.ms_mining_type == 1)//随采
                {
                    if (pcoParm.ImageType == 2)
                    {
                        PureCommonOperation::CalMigration_mining(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                            com + 1, pcoExtractChnParms, outSurLineId);
                    }
                    else
                    {
                        isSavePianyi = false;
                    }
                }
                else//随掘
                {
                    PureCommonOperation::CalMigration(
                        pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                        com + 1);
                }

                if (hzi::config.verbose)
                {
                    cout << " CalMigration endl " << endl;
                }
            }
            else if (useVType == 2)//PS波偏移
            {
                for (int type = 0; type < useVType; type++)
                {
                    // float* pOut_tmp = new float[iGrdNum];
                    // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);
                    float *pSpeedBtr = new float[iGrdNum];
                    memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                    for (int i = 0; i < iGrdNum; i++)
                    {
                        if (type == 0)
                        {
                            pSpeedBtr[i] = speed_p;
                        }
                        else
                        {
                            pSpeedBtr[i] = speed_s;
                        }
                    }

                    getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                                 coal_z, layer_from, is_evenSpeed);
                    auto pretime2 = pretime * deltT;
                    if (hzi::config.ms_mining_type == 1)
                    {
                        if (pcoParm.ImageType == 2)
                        {
                            PureCommonOperation::CalMigration_mining(
                                pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                                pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                                pcoParm.ampType, com + 1, pcoExtractChnParms, outSurLineId);
                        }
                        else
                        {
                            isSavePianyi = false;
                        }
                    }
                    else
                    {
                        //随掘
                        PureCommonOperation::CalMigration(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                            pcoParm.ampType, com + 1);
                    }
                }
            }
            //上面：pOutSignal中结果经过偏移计算，结果存于pOut_tmp

            //保存偏移图，pOut_tmp
            bool is_save = true;//true表示进行异常提取，false表示不进行异常提取
            if (isSavePianyi)
                bool ret = saveResult(tmStmp, devId, iGrdNum, pcoLocParm, pOut_tmp, com, is_save, outType);
        }
    }

    // 写9类型文件
    if (hzi::config.ms_miningSignal)
    {
        // auto pretime = 0;
        unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
        char *pHead2 = pHeadData2.get();
        *(double *)(pHead2) = (double)tmStmp;
        // 19 代表随采，9是随掘
        auto classId2 = 9;
        // auto classId2 = (hzi::config.ms_mining_type == 1) ? 19 : 9;
        *(uint8_t *)(pHead2 + 8) = classId2;
        *(float *)(pHead2 + 9) = deltT;
        *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
        *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
        *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
        *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
        *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
        if (hzi::config.ms_mining_type == 1)
        {
            *(uint8_t *)(pHead2 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
            *(uint8_t *)(pHead2 + 29) = pcoParm.ImageType;   //'随采成像方式:0-散射，1-透射，2-爆炸成像'
        }
        auto conn21 = hzi::config.pConnPool->getConnection();
        conn21.execute(
            "INSERT INTO "
            "e_mining_signaldata_frm_info "
            "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
            "loc,fx,fy,fz,dis)"
            "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
            " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
            "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
            (uint8_t)devId,  // dev_id
            tmStmp / 1000.0, // samp_time
            classId2,        // class_id
            deltT,           // curt_ch
            valNum,          // channels
            vecSize,
            pcoParm.outLen, // ch_pnts
            (relLocFromTime(tmStmp) / std::to_string(classId2) /
             std::to_string(tmStmp))
            .c_str(), // frm_loc
            pcoLocParm.fx,
            pcoLocParm.fy,
            pcoLocParm.fz,
            pcoLocParm.dis_y);

        fs::path outSignalfileName(hzi::config.dataRoot);

        outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
            std::to_string(tmStmp);
        try
        {
            auto dir = outSignalfileName.parent_path();
            if (!fs::exists(dir))
            {
                fs::create_directories(dir);
            }
            std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
            ofs_Signal.write(pHead2, 32);
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < valChnns; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOutSignal[ch + dex * valChnns];
                    // if (!pcoCalChnParms[ch].enb)
                    //     continue;
                    ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
                }
            }
            ofs_Signal.close();
        }
        catch (std::exception &e)
        {
            string msg("error while writing to file:");
            msg += outSignalfileName.string();
            msg += ":";
            msg += e.what();
            if (hzi::config.verbose)
                cout << "msg = " << msg << endl;
            debugErr(msg);
            return "error";
        };
    }

    return std::to_string(tmStmp);
}
```

### ※计算偏移图数据

> [!NOTE]
>
> * `PureCommonOperation::CalMigration`

#### 加窗+预处理

![image-20250429111239334](D:\notes\笔记Img\image-202504291112393341)

* 加窗

  

* 预处理

#### 相关计算

对1炮数据：

* 取通道号，以及该通道号对应的因子道号，将因子道数据暂存到`coefData`。

  index遍历所有因子道（遍历通道号更好吧？），同一个index对应的某个通道号和其使用的因子道号。

  ![image-20250429140811344](D:\notes\笔记Img\image-202504291408113443)

##### 滑动时窗

若`pcoParm.isUseSlideWn==true`，则进行滑动时窗后，再相关计算。

否则直接相关计算。

`pcoParm.outLen`为输出点数。

**这1通道的相关计算结果在`tmpResult`中。**

再拷贝到到`tmpOut`中暂存供后续计算，`tmpOut`为记录了所有炮数的所有通道的计算结果。

![image-20250429141332632](D:\notes\笔记Img\image-202504291413326325)

![image-20250429141212378](D:\notes\笔记Img\image-202504291412123784)

![image-20250429141437245](D:\notes\笔记Img\image-202504291414372455)

![image-20250429142151631](D:\notes\笔记Img\image-202504291421516316)

##### 相关

#### 一维滤波

![image-20250429143704862](D:\notes\笔记Img\image-20250429143704862611)

遍历通道。

`pcoParm.isCut`为0-不滤波，1-时域滤波，2-频域滤波。

对`tmp_out`中暂存相关结果进行计算，`tmp_out[ch+dex*chns_Count]`中`ch+dex*chns_Count`为当前炮数的当前通道。

`Filter1dFD`进行频域滤波，`pcoParm.isStop`：false带通滤波，true带阻滤波。

`pcoParm.isNotchCut`是否进行陷波，调用`NotchFilter1dFD`陷波滤波。

* 频域滤波

  

* 带通滤波/带阻滤波

#### 陷波

* `getPCO_parm`从库表取参数时，`pcoParm.notchF`为陷波频率，从表`e_mining_PCOSignalParm`和`e_mining_PCOSignalParm_history`中读取。**`ms_mining.cpp-2066行`和`ms_mining.cpp-3215行`**，对于陷波频率的处理修改了，之前库表里存的是【50n】字符串，现在改为该字段直接存数值。至于50可以做奇偶倍，125不做奇偶倍只做一倍，由用户自己决定。

* 测试方法：只保留陷波，陷波带宽设定20。频域滤波，低截频：1，高截频：500；道内均衡：无；反褶积：无；反射波提取：无。点击执行。

  ![image-20250520163105526](D:\notes\笔记Img\image-20250520163105526.png)

```cpp
/*
	* 陷波
	* Notch_jobs ：陷波时剔除50hz的奇偶倍数：0-50hz的整数倍，0-奇偶倍（整数倍）1-奇数倍 2-偶数倍 3-一倍
	* NotchWn ：陷波时剔除范围宽度（陷波带宽）
	* int NotchType :（陷波修正方法）处理类型，0-剔除赋值0，1-线性差值
	*/
void NotchFilter1dFD(float* pData, int dataLen, float deltT, int Notch_jobs, float NotchWn, int NotchType, int NotchFreq) 
{
    if (pData == nullptr || dataLen < 1) {
        return;
    }

    float smpFreq_cy = 1000.0f / deltT;  // 采样频率
    int transPt = GetNextPower2(dataLen);
    float smpFreq = smpFreq_cy / transPt;
    // int NotchFreq = 50;  // 初始陷波频率
    int notchEdgePt = static_cast<int>(NotchWn / smpFreq);

    std::unique_ptr<float[]> pRe(new float[transPt]());
    std::unique_ptr<float[]> pIm(new float[transPt]());

    std::copy(pData, pData + dataLen, pRe.get());
    DataFFT(pRe.get(), pIm.get(), transPt, true);

    std::vector<float> pCoef_notch(2 * notchEdgePt + 1);
    GenWindowSeries(pCoef_notch.data(), pCoef_notch.size(), WFF_HAMMING);

    for (int multiplier = 1; NotchFreq * multiplier < smpFreq_cy / 2; ++multiplier) {
        bool applyNotch = (Notch_jobs == 0) ||
            (Notch_jobs == 1 && multiplier % 2 == 1) || 
            (Notch_jobs == 2 && multiplier % 2 == 0) ||
            (Notch_jobs == 3 && multiplier == 1);
        if (!applyNotch) continue;

        int notchIdx = static_cast<int>(NotchFreq * multiplier / smpFreq);
        for (int pt = -notchEdgePt; pt <= notchEdgePt; ++pt) {
            int idx = std::clamp(notchIdx + pt, 0, transPt / 2);
            if (NotchType == 0) {  // 删除频率成分
                pRe[idx] = 0;
                pIm[idx] = 0;
            } else if (NotchType == 1) {  // 插值
                pRe[idx] *= pCoef_notch[notchEdgePt + pt];
                pIm[idx] *= pCoef_notch[notchEdgePt + pt];
            }
        }
    }

    for (int ipt = transPt / 2 + 1; ipt < transPt; ++ipt) {
        pRe[ipt] = pRe[transPt - ipt];
        pIm[ipt] = -pIm[transPt - ipt];
    }

    DataFFT(pRe.get(), pIm.get(), transPt, false);
    std::copy(pRe.get(), pRe.get() + dataLen, pData);
}
```



#### 反褶积

![image-20250429155438319](D:\notes\笔记Img\image-2025042915543831971)

若启用滤波，则反褶积后，会再次进行滤波，且写死为带通滤波。

#### 道内均衡

* 指数增益：

  ![image-20250520163549425](D:\notes\笔记Img\image-20250520163549425.png)

  测试方法：选取提取图某个时间点（横坐标），查看所有通道的幅值，记录增益前的幅值。然后执行增益，再增益后的图中，相同时间点查看所有通道的幅值。比较点的幅值增大是不是符合`pData[i] *= expf(alpha * (i - ptBegId) * deltT_s)`关系。

  ![image-20250520164943164](D:\notes\笔记Img\image-20250520164943164.png)

  ![image-20250520165008364](D:\notes\笔记Img\image-20250520165008364.png)

#### 道间均衡

![image-20250429155753889](D:\notes\笔记Img\image-2025042915575388981)

#### 反射波提取

![image-20250429155950576](D:\notes\笔记Img\image-2025042915595057691)

计算结果存在`vtOutPut`中，`pcoParm.bNegtiveV`为提取类型：正速度/负速度。

![image-20250429164256173](D:\notes\笔记Img\image-202504291642561731)

把计算结果从`vtOutPut`拷贝到`tmp_out`（按照通道）

#### 自相关谱图

* 原理：

  

```cpp
cout<<"11111"<<endl;
        /*
        *   自相关谱图：时域+自相关+正fft
        */
        bool generateSelfCorrSpectrum = true;//是否生成自相关谱图
        const int pOutSignalSize = valChnns * vecSize;
        auto myDeleter = [pOutSignalSize](float** ptr)
        {
            for(int chIndex=0;chIndex<pOutSignalSize;chIndex++)
            {
                delete[] ptr[chIndex];
            }
            delete[] ptr;
        };
        unique_ptr<float*[], decltype(myDeleter)> pOutSelfCorrSpectrum(new float*[pOutSignalSize], myDeleter);
        for(int chIndex=0;chIndex<pOutSignalSize;chIndex++)
        {
            pOutSelfCorrSpectrum[chIndex] = new float[pcoParm.outLen];
            memset(pOutSelfCorrSpectrum[chIndex], 0, sizeof(float)*pcoParm.outLen);
        }

       
        // if(generateSelfCorrSpectrum && pcoParm.extractMethod == 0 && pcoParm.CorrType == 0) //时域+自相关：干涉谱图，11类型
        if(false)
        {
            cout<<"22222"<<endl;
            //对时域自相关信号执行fft
            unique_ptr<float[]> pChDataR = make_unique<float[]>(pcoParm.outLen);//暂存一个通道的数据
            unique_ptr<float[]> pChDataI = make_unique<float[]>(pcoParm.outLen);

            for(int dex=0;dex<vecSize;dex++)
            {
                cout<<"vecsize="<<dex<<endl;

                for(int ch=0;ch<valChnns;ch++)
                {
                    cout<<"ch="<<ch<<endl;

                    memset(pChDataR.get(), 0, sizeof(float)*pcoParm.outLen);
                    memset(pChDataI.get(), 0, sizeof(float)*pcoParm.outLen);
                    memcpy(pChDataR.get(), pOutSignal[ch + dex*valChnns], sizeof(float)*pcoParm.outLen);
                    PureCommonOperation::DataFFT(pChDataR.get(), pChDataI.get(), pcoParm.outLen, true);
                    for(int pt=0;pt<pcoParm.outLen;pt++)
                    {
                        // float frequencyPt = pt / deltT * pcoParm.outLen;  //横轴-频率：k*采样频率/采样点数
                        float AmplitudePt = sqrt(safePow(pChDataR[pt], 2) + safePow(pChDataI[pt], 2));//纵轴-幅值:实部虚部平方和的平方根
                        pOutSelfCorrSpectrum[ch+dex*valChnns][pt] = AmplitudePt;
                    }
                }
            }

            
            // 保存自相关谱图
            //  构造11文件头
            classId2 = 11;
            *(uint8_t*)(pHead2 + 8) = classId2;    //同类型9相比，文件头除了classId不同其他均相同

            auto conn21 = hzi::config.pConnPool->getConnection();
            conn21.execute(
                "INSERT INTO "
                "e_mining_selfcorrdata_frm_info "
                "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
                "loc,fx,fy,fz,dis)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
                "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
                (uint8_t)devId,  // dev_id
                tmStmp / 1000.0, // samp_time
                classId2,        // class_id
                deltT,           // curt_ch
                valNum,          // channels
                vecSize,
                pcoParm.outLen, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp)).c_str(), // frm_loc
                pcoLocParm.fx,
                pcoLocParm.fy,
                pcoLocParm.fz,
                pcoLocParm.dis_y);

            cout<<"33333"<<endl;

            fs::path outClassId11FileName(hzi::config.dataRoot);
            outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                                 std::to_string(tmStmp);
            try
            {
                auto dir = outClassId11FileName.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(outClassId11FileName, std::ofstream::binary);
                ofs_Signal.write(pHead2, 32);
                for (int dex = 0; dex < vecSize; dex++)
                {
                    for (int ch = 0; ch < valChnns; ++ch)
                    {
                        // if (!pcoCalChnParms[ch].enb)
                        //     continue;

                        int32_t* p32SelfCorrSpectrumEachChn = reinterpret_cast<int32_t*>(pOutSelfCorrSpectrum[ch+dex*valChnns]);
                        ofs_Signal.write((char*)p32SelfCorrSpectrumEachChn, pcoParm.outLen * 4);
                    }
                }
                ofs_Signal.close();
                cout<<"44444"<<endl;
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += outClassId11FileName.string();
                msg += ":";
                msg += e.what();
                if (hzi::config.verbose)
                    cout << "msg = " << msg << endl;
                debugErr(msg);
                return "error";
            };
        }
```



### ※保存10数据类型

> [!NOTE]
>
> * `saveResult`
>
> * 10的数据存在`pOut`。
>
>   为了`outType`可指定【偏移图】或【反射界面输出】，调用`PureCommonOperation::ReflactPlane`，进行反射提取。`pOut`中数据经过反射波提取，数据存于`pOut_2`。
>
> * 异常提取：通过fg判断是否进行异常提取。调用函数`saveLine()`
>
> * 截取偏移图数据，将`pOut`数据处理后存于`pOut_0`
>
> * 插入库表，保存偏移图数据文件路径
>
> * 调用`ofstream::write()`写入数据，默认的打开模式是 `std::ios::out`，它会清空文件内容并从头开始写入。
>
>   > - 如果文件 `fileName` 已经存在，文件的内容会被清空。
>   > - 如果文件不存在，会创建一个新文件。
>
> * 调用`writeSvg(pOut_0)`保存svg文件（配置文件）

```cpp
/*
* 保存偏移图的10类型数据文件
* fg：是否是实时计算，历史计算异常不提取结果。从偏移数据，提取异常调用函数saveLine()
* typeId：用于分量类型 0-X 1-Y 2-Z
* outType：输出类型，0-偏移图 1-反射界面输出
*/
bool saveResult(uint64_t tmStmp,
                int devId,
                int iGrdNum,
                PureCommonOperation::PCOLocParm pcoLocParm,
                float *&pOut,
                int typeId,
                bool fg, bool outType)
{
    bool flag = false;

    auto conn = hzi::config.pConnPool->getConnection();

    if (hzi::config.ms_mining_type == 2)
    { 
        // hzi::config.ms_mining_type == 2
        // 异常提取

        std::unique_ptr<float[]> pOut_2(new float[iGrdNum]);
        memset(pOut_2.get(), 0, sizeof(float) * iGrdNum);

        std::vector<PureCommonOperation::ELINE> lineVec;
        int flNum = 1;
        PureCommonOperation::EXTRACTPARA m_extractPara;
        m_extractPara.Reset();

        auto rslt_ext = conn.executeQuery(
            "SELECT * FROM e_tunnel_extractPara WHERE is_init = 0");
        if (!rslt_ext)
        {
            std::cerr << "Query returned no results." << std::endl;
            //  return;
        }
        if (rslt_ext.next())
        {
            m_extractPara.fAmpleScale = rslt_ext.getDouble("fAmpleScale");
            m_extractPara.fOverlapScale = rslt_ext.getDouble("fOverlapScale");
            m_extractPara.iMaxPlanes = rslt_ext.getInt("iMaxPlanes");
            m_extractPara.bExtAmple = rslt_ext.getInt("bExtAmple");
            m_extractPara.bExtNum = rslt_ext.getInt("bExtNum");
            m_extractPara.iAmpExtType = rslt_ext.getInt("iAmpExtType");
            m_extractPara.iNumExtType = rslt_ext.getInt("iNumExtType");
            m_extractPara.inputMaxEng = rslt_ext.getDouble("inputMaxEng");
        }

        //pOut中数据经过反射波提取，数据存于pOut_2
        PureCommonOperation::ReflactPlane(pOut, pOut_2.get(), flNum, &pcoLocParm,
                                          m_extractPara, &lineVec);

        //若成图：反射界面图，则把pOut_2拷贝到pOut。
        //若成图：偏移图，不拷贝，直接用pOut中数据进行后续写文件操作。
        if (outType)
        {
            memcpy(pOut, pOut_2.get(), sizeof(float) * iGrdNum);
        }

        float gLen = (pcoLocParm.m_dYGrdLen > pcoLocParm.m_dZGrdLen)
                         ? pcoLocParm.m_dYGrdLen
                         : pcoLocParm.m_dZGrdLen;
        if (hzi::config.verbose)
        {
            cout << "当前回采位置： " << pcoLocParm.m_locx
                 << " Y/Z 精度：" << gLen << ";异常提取结果：" << endl;
            for (int i = 0; i < lineVec.size(); i++)
            {
                // 先按照X Y 面计算

                cout << "   第 " << i + 1 << "个：起点坐标：(" << lineVec[i].fBeginTime << ","
                     << lineVec[i].nBeginTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fBeginTime << " ; " << lineVec[i].fXPos << " ; "
                     << "终点坐标:(" << lineVec[i].fEndTime << ","
                     << lineVec[i].nEndTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fEndTime << "; " << lineVec[i].fEndTime << endl;
            }
        }

        //异常提取
        if (fg)
        {
            saveLine(tmStmp, lineVec, pcoLocParm, fg);
        }
    }

    int XGrdNum =
        int(pcoLocParm.mark_len / pcoLocParm.m_dXGrdLen);
    int YGrdNum = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_iZGrdNum : pcoLocParm.m_iYGrdNum;

    auto iGrdNum_out =
        XGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    std::unique_ptr<float[]> pOut_0(new float[iGrdNum_out]);
    memset(pOut_0.get(), 0, sizeof(float) * iGrdNum_out);
    cout << "pcoLocParm.m_dir = " << pcoLocParm.m_dir << ",XGrdNum = " << XGrdNum << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
         << ",YGrdNum = " << YGrdNum << endl;
    // 截取偏移图数据
    for (int j = 0; j < YGrdNum; ++j)
    {
        for (int k = 0; k < pcoLocParm.m_iXGrdNum; ++k)
        {
            if (pcoLocParm.m_dir == 0)
            {
                // 取后面的数据
                if (k >= pcoLocParm.m_iXGrdNum - XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k - pcoLocParm.m_iXGrdNum + XGrdNum;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
            else
            {
                if (k < XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
        }
    }
    float minpOut = *std::min_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    float maxpOut = *std::max_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    // 有异常的位置拉起来能量
    cout << " XGrdNum = " << XGrdNum << " m_iYGrdNum = " << pcoLocParm.m_iYGrdNum << " pcoLocParm.m_iZGrdNum = " << pcoLocParm.m_iZGrdNum << endl;

    float dX = pcoLocParm.m_dXGrdLen;
    float dY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZGrdLen : pcoLocParm.m_dYGrdLen;
    float minY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZMin : pcoLocParm.m_dYMin;
    //  cout<<"dX =  "<<dX<<",dy= "<<dY<<",minY = "<<minY<<endl;

    int32_t *p32 = (int32_t *)pOut_0.get();
    unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
    char *pHead = pHeadData.get();
    *(double *)(pHead) = (double)tmStmp;
    auto classId = *(uint8_t *)(pHead + 8) = 10;//classid置10，偏移图
    *(uint8_t *)(pHead + 9) = devId;
    *(uint16_t *)(pHead + 10) = XGrdNum;
    // *(uint16_t*)(pHead + 10) = pcoLocParm.m_iXGrdNum;
    *(uint16_t *)(pHead + 12) = pcoLocParm.m_iYGrdNum;
    *(uint16_t *)(pHead + 14) = pcoLocParm.m_iZGrdNum;
    *(int32_t *)(pHead + 16) = *((int32_t *)&minpOut);
    *(int32_t *)(pHead + 20) = *((int32_t *)&maxpOut);
    *(int32_t *)(pHead + 24) = *((int32_t *)&dX);

    // auto conn3 = hzi::config.pConnPool->getConnection();
    
    
    /*
    * 插入库表，保存偏移图数据文件路径
    */
    conn.execute(
        "INSERT INTO "
        "e_mining_pcodata_frm_info "
        "(dev_id,samp_time,class_id,XGrdNum,YGrdNum,ZGrdNum,frm_loc)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE XGrdNum= values(XGrdNum),YGrdNum= "
        "values(YGrdNum)",
        (uint8_t)devId,        // dev_id
        tmStmp / 1000.0,       // samp_time
        classId,               // class_id
        XGrdNum,               // curt_ch  pcoLocParm.m_iXGrdNum XGrdNum
        pcoLocParm.m_iYGrdNum, // channels
        pcoLocParm.m_iZGrdNum, // ch_pnts
        (relLocFromTime(tmStmp) / std::to_string(classId) /
         std::to_string(tmStmp))
            .c_str() // frm_loc
    );

    
    /*
    * 写到文件
    */
    auto classId2 = (typeId == 0) ? 10 : (100 + typeId);//单分量文件名类型写10，多分量写100+typeId

    //10类型文件文件名
    fs::path fileName(hzi::config.dataRoot);
    fileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                std::to_string(tmStmp);

    //写10类型文件
    try
    {
        auto dir = fileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs(fileName, std::ofstream::binary);
        ofs.write(pHead, 32);
        ofs.write((char *)p32, iGrdNum_out * 4);
        //  ofs.write((char*)p32, iGrdNum * 4);
        ofs.close();
        flag = true;
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += fileName.string();
        msg += ":";
        msg += e.what();
        debugErr(msg);
        cout << msg << endl;
        return flag;
    };

    //配置文件中读取字段，是否保存偏移图svg文件到目录下
    if (hzi::config.ms_rslt_to_image)
    {
        //   cout<<" writeSvg "<<minpOut<<" , "<<maxpOut<<endl;
        string path = fileName.string() + ".svg";

        if (std::filesystem::exists(path))
        {
            fs::remove(path);
        }
        writeSvg(path, pOut_0.get(), XGrdNum, YGrdNum, dX, dY, pcoLocParm.m_dXMin, minY);
        //  cout<<" end writeSvg "<<path <<endl;
    }
    return flag;
}
```



### ※保存9数据类型

> [!NOTE]
>
> 没有函数，而是下面这段代码。
>
> `pOutSignal`中保存提取+再提取数据，写入到文件。
>
> 调用`ofstream::write()`写入数据，默认的打开模式是 `std::ios::out`，它会清空文件内容并从头开始写入。
>
> > - 如果文件 `fileName` 已经存在，文件的内容会被清空。
> > - 如果文件不存在，会创建一个新文件。

```cpp
// 写9类型文件
if (hzi::config.ms_miningSignal)//配置文件中字段
{
    // auto pretime = 0;
    
    //文件头pHead2
    unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
    char *pHead2 = pHeadData2.get();
    *(double *)(pHead2) = (double)tmStmp;	//第一炮数据的第一个数据文件的采样时间
    
    auto classId2 = 9;	// 19 代表随采，9是随掘
    // auto classId2 = (hzi::config.ms_mining_type == 1) ? 19 : 9;
    *(uint8_t *)(pHead2 + 8) = classId2;
    *(float *)(pHead2 + 9) = deltT;
    *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
    *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
    *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
    *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
    *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
    if (hzi::config.ms_mining_type == 1)	//随采
    {
        *(uint8_t *)(pHead2 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
        *(uint8_t *)(pHead2 + 29) = pcoParm.ImageType;   //'随采成像方式:0-散射，1-透射，2-爆炸成像'
    }
    
    //9文件路径入库表e_mining_signaldata_frm_info
    auto conn21 = hzi::config.pConnPool->getConnection();
    conn21.execute(
        "INSERT INTO "
        "e_mining_signaldata_frm_info "
        "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
        "loc,fx,fy,fz,dis)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
        "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
        (uint8_t)devId,  // dev_id
        tmStmp / 1000.0, // samp_time
        classId2,        // class_id
        deltT,           // curt_ch
        valNum,          // channels
        vecSize,
        pcoParm.outLen, // ch_pnts
        (relLocFromTime(tmStmp) / std::to_string(classId2) /
         std::to_string(tmStmp))
        .c_str(), // frm_loc
        pcoLocParm.fx,
        pcoLocParm.fy,
        pcoLocParm.fz,
        pcoLocParm.dis_y);

    //写文件
    fs::path outSignalfileName(hzi::config.dataRoot);
    outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp);
    try
    {
        auto dir = outSignalfileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
        //写文件头到文件
        ofs_Signal.write(pHead2, 32);	
        //写数据到文件
        for (int dex = 0; dex < vecSize; dex++)//vecSize为炮数
        {
            for (int ch = 0; ch < valChnns; ++ch)//valChnns为通道数，在setSignalChnInfo里赋值的
            {
                //数据体p32Signal
                int32_t *p32Signal = (int32_t *)pOutSignal[ch + dex * valChnns];
                // if (!pcoCalChnParms[ch].enb)
                //     continue;
                ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
            }
        }
        ofs_Signal.close();
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += outSignalfileName.string();
        msg += ":";
        msg += e.what();
        if (hzi::config.verbose)
            cout << "msg = " << msg << endl;
        debugErr(msg);
        return "error";
    };
}
```

## （2）历史重算代码流程

> [!IMPORTANT]
>
> 重算所得文件名（时间戳）入库表`e_mining_pcodata_frm_info`。
>
> | 用到的接口                                           | 功能                                                         |
> | ---------------------------------------------------- | ------------------------------------------------------------ |
> | `/handerSignal/:from_time/:to_time/:time_len/:devId` | 只提取+偏移，写文件9和10                                     |
> | `/handerExtSignalParm/:samp_time/:typeId`            | 读9文件，执行再提取算法流程，写99文件。进行偏移计算，写10文件。 |
> |                                                      |                                                              |
>
> * 调用链：
>
>   ```cpp
>   handerSignalProcess<--/handerSignal/:from_time/:to_time/:time_len/:devId
>           
>   setPCOLocParm,setPCOCalChn,setSignalChnInfo,<--processMethods<--handerExtSignal<-- /handerExtSignal/:samp_time/:typeId
>             
>   getPCO_parm,setPCOLocParm,setPCOCalChn,setSignalChnInfo,handleSignalData<--handleExtSignalData
>       <--/handerExtSignalParm/:samp_time/:typeId,/handerExtSignalPianYi/:from_time/:to_time
>   ```
>
>   
>
> 

### 点击【干涉源提取】

只做提取，这一步**只显示【提取图+偏移图】（只做提取基础上的偏移图）**

使用上方设定的时间范围，左侧【干涉源提取】条目下的参数。

会调用接口：

```cpp
//handerSignal/1743789660000/1743789720000/1/0
/handerSignal/:from_time/:to_time/:time_len/:devId
ms_commands.cpp--handerSignalProcess()
调用`mergeMs`拼帧
调用`handleSignalProcess(false)`只提取+偏移，写文件9和10，返回的时间戳作为response
    
//table/e_mining_pcodata_frm_info/frm_loc:str/class_id=10 order by samp_time
/table/:tblName/:cols/:where?


//data_file/2025/4/5/9/1743789665000
/data_file/:year/:month/:day/:type/:timestamp
获取9文件


//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id = 0
type_id前有个/没找到这个接口

//data_file/2025/4/5/99/1743789665000
/data_file/:year/:month/:day/:type/:timestamp  
获取99文件（注意：如果该99文件存在的话，也就是这个时间已经点击过执行做过再提取的话，就会有99。若是第一次进行历史重算就没有，会返回204 No Content）


//getLocInfo/1743789665000/mark_XLen,mining_locx,mining_dir,dXGrdLen,dYGrdLen
/getLocInfo/:timestamp/:cols


//data_file/2025/4/5/10/1743789665000
/data_file/:year/:month/:day/:type/:timestamp
获取10文件
```

### 点击【保存】

```cpp
//POST：config/e_mining_PCOSignalParm_history

//POST：update_columns/e_mining_PCOLocParm/1=1

//POST：config/e_tunnel_extractPara
```

### 点击【执行】

使用左侧设定参数，在提取文件的基础上，进行再提取。显示【提取图+再提取图+偏移图（提取+再提取上的偏移图）】

根据设定好的计算参数对当前选中时间戳的提取数据，进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`，并在再提取数据和再提取波形图的基础上，得到新的偏移图（提取+再提取的偏移图）。

会调用接口：

```cpp
//POST：config/e_mining_PCOSignalParm_history
//payload为页面左侧设定的参数值
//写参数到库表
/config/:tblName
    
//POST：update_columns/e_mining_PCOLocParm/1=1
//payload为e_mining_PCOLocParm中要更新的参数
/update_columns/:tblName/:condition

//POST：config/e_tunnel_extractPara
//payload为e_tunnel_extractPara中更新参数
/config/:tblName

//POST：/handerExtSignalParm/1747152060100/9
/handerExtSignalParm/:samp_time/:typeId
调用`ms_mining.cpp--handleExtSignalData(samp_time, typeId)`，typeId传文件类型9，读取9类型文件。
和`ms_mining.cpp--handleSignalProcess`类似，先通过4个取参数函数取参数，但读取历史参数表`e_mining_PCOSignalParm_history`。
读9文件数据保存到pData。
调用`PureCommonOperation::handleSignalData(pData, pOutSignal)`，pData数据经过处理得到再提取数据存于pOutSignal。
调用`PureCommonOperation::CalMigration()`把pOutSignal数据进行偏移计算，存于pOut_tmp。
调用`saveResult(pOut_tmp)`保存偏移图文件10。
pOutSignal中数据写文件到99。



//data_file/2025/5/14/99/1747152060100
获取99文件。

//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//getLocInfo/1747152060100/mark_XLen%2Cmining_locx%2Cmining_dir%2CdXGrdLen%2CdYGrdLen

//data_file/2025/5/14/10/1747152060100
获取10文件。

//table/e_tunnel_imgSetting/ampScale,scaleRatio

//data_file/2025/5/14/101/1747152060100
获取101文件？

//data_file/2025/5/14/102/1747152060100
获取102文件？
```

### ※保存99数据类型

点击【执行】后，会在`saveResult`保存再提取数据到99文件`ms_mining.cpp--4303`。

```cpp
auto classId2 = 99;
```

### 点击【同步】

```cpp
//POST：config/e_mining_PCOSignalParm_history

//POST：update_columns/e_mining_PCOLocParm/1=1

//POST：config/e_tunnel_extractPara

//POST：config/e_mining_PCOSignalParm
```

### 点击【树形图】

```cpp
//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//data_file/2025/5/14/99/1747152060100
获取99文件

//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//getLocInfo/1747152060100/mark_XLen%2Cmining_locx%2Cmining_dir%2CdXGrdLen%2CdYGrdLen

//data_file/2025/5/14/10/1747152060100
获取10文件

//table/e_tunnel_imgSetting/ampScale,scaleRatio

//data_file/2025/5/14/101/1747152060100

//data_file/2025/5/14/102/1747152060100
```

# 6. 数据文件类型及格式

---

> [!IMPORTANT]
>
> | 文件类型 | 功能                  |
> | -------- | --------------------- |
> | 3        | 原始数据：背景        |
> | 6        | 原始数据：全时        |
> |          |                       |
> | 9        | 干涉提取数据：        |
> | 10       | 偏移图数据            |
> | 99       | 9经过再提取流程后数据 |
> |          |                       |
> | 11       |                       |
>
> 



## （1）9文件头格式

> [!WARNING]
>
> 数据文件的头格式和`DataFrame`不同。

| 总长32B | 长度（单位bit） | 说明                                                    |
| ------- | --------------- | ------------------------------------------------------- |
| 0       | 8               | tmStmp。*(double *)(pHead2) = (double)tmStmp            |
| 8       | 8               | classId=9，类型                                         |
| 9       | 32              | deltT，采样间隔（单位ms）                               |
| 13      | 32              | valNum，可用通道总数                                    |
| 17      | 16              | vecSize，数据分组数（这个文件里有几组数据，也就是炮数） |
| 19      | 32              | outLen，数据长度（点数）                                |
| 23      | 32              | coefBegPt，超前点数                                     |
| 27      | 8               | devId，基站ID                                           |
| 28      | 8               | systemeType（系统类型：0-双巷式，1-机载式，2-组合式'）  |
| 29      | 8               | ImageType（'随采成像方式:0-散射，1-透射，2-爆炸成像'）  |
|         |                 |                                                         |



## （2）99文件头格式

> `ms_mining.cpp--handleExtSignalData`

| 总长32B | 长度（单位bit） | 说明                                         |
| ------- | --------------- | -------------------------------------------- |
| 0       | 8               | 时间戳。*(double *)(pHead2) = (double)tmStmp |
| 8       | 8               | 9                                            |
| 9       | 8               | deltT。*(float *)(pHead2 + 9) = deltT;       |
| 13      | 32              | valNum                                       |
| 17      | 16              | vecSize                                      |
| 19      | 32              | outLen                                       |
| 23      | 32              | coefBegPt                                    |
| 27      | 8               | devId                                        |
| 28      | 8               | sysType                                      |
| 29      | 8               | imageType                                    |
|         |                 |                                              |

## （3）11文件头格式

| 总长32B | 长度（单位bit） | 说明                                         |
| ------- | --------------- | -------------------------------------------- |
| 0       | 8               | 时间戳。*(double *)(pHead2) = (double)tmStmp |
| 8       | 8               | 9                                            |
| 9       | 8               | deltT。*(float *)(pHead2 + 9) = deltT;       |
| 13      | 32              | valNum                                       |
| 17      | 16              | vecSize                                      |
| 19      | 32              | outLen                                       |
| 23      | 32              | coefBegPt                                    |
| 27      | 8               | devId                                        |
| 28      | 8               | sysType                                      |
| 29      | 8               | imageType                                    |
|         |                 |                                              |

## （4）10文件头格式

| 总长32B | 长度（单位bit） | 说明                                         |
| ------- | --------------- | -------------------------------------------- |
| 0       | 8               | tmStmp。*(double *)(pHead) = (double)tmStmp; |
| 8       | 8               | classid=10                                   |
| 9       | 8               | devId                                        |
| 10      | 16              | XGrdNum                                      |
| 12      | 16              | pcoLocParm.m_iYGrdNum                        |
| 14      | 16              | pcoLocParm.m_iZGrdNum                        |
| 16      | 32              | minpOut                                      |
| 20      | 32              | maxpOut                                      |
| 24      | 32              | dX                                           |
|         |                 |                                              |

# 6. 异常预测

### 库表

| -                  | -                                                            |
| ------------------ | ------------------------------------------------------------ |
| e_tunnel_lineInfo  |                                                              |
| e_tunnel_threshold |                                                              |
| e_tunnel_errorinfo | 由表`e_tunnel_lineInfo`和表`e_tunnel_threshold`共同得出表`e_tunnel_errorinfo`记录 |
|                    |                                                              |
|                    |                                                              |

### 代码

实时计算。对每次计算得到的偏移图中异常进行保存，保存到表`e_tunnel_lineInfo`。

`ms_mining.cpp-366-saveResult()`中先通过函数`saveLine()`保存提取异常结果到表`e_tunnel_lineInfo`。

**`ms_mining.cpp-5328-getWarningInfo()`**中通过查表`e_tunnel_threshold`和表`e_tunnel_lineInfo`，进行【k-mean聚类】得到【异常预测】结果（也即预测的地质分层面位置与夹角），保存到表`e_tunnel_errorinfo`。

**查询表`e_tunnel_errorinfo`绘制到【巷道探测示意图】。**

# 7. 预警

### 配置文件

```json
"warningTimeSyncIntval":2,//预警发送消息间隔（查表间隔），单位：min
"is_used_warning":false,//is_Used_warning接口返回值的是否使用预警（代码里实际没用它作为判断）
"warningTimeSync":false,//启用预警（实际有效的）
```

### 库表

| 表名                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| e_warningInfo_parm    | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts         | **记录了所有的微震事件。**用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info        | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
| e_warning_parm        | 暂时未用                                                     |
|                       |                                                              |

### 代码

`main.cpp-syncWarningInfo()`在子线程循环运行下面逻辑，线程每隔`hzi::config.warningTimeSyncIntval`时间休眠一次：

* 为了兼容之前代码`getWarningMsg()`函数名未修改，其中只做根据当前时间获取预警时间段的功能。调用`doWarningMsgProcess()`。

* `doWarningMsgProcess()`中，地震和电法分开。

  有地震，则查表`e_warning_level_value`获取：`msFrequency 微震频次`，`highEnergyNum 大能量事件`，`msLocation 异常区域个数`，这3个预警变量的蓝橙红等级阈值，存在`warningLevelMapMS`。**若只有地震，则表中只存地震的等级阈值，作为异常处理依据，若缺少，则抛出异常。电法同理。**

  有电法，则查表获取`e_sp_variation 自电变化量`，`ee_p_variation 视电阻率变化量`，这2个预警变量的蓝橙红等级阈值，存在`warningLevelMapEE`。**若只有电法，则表中只存电法的等级阈值。**

  若两者耦合都有，则表中需都存。

  而后分别按照下面计算各自的预警变量。

* 这5个量的值是计算得来。查表`e_msevt_rslts`（记录所有微震事件）和表`e_warningInfo_parm`（通过微震事件记录的参数计算得到5个预警变量时的一些阈值）。

* 遍历表`e_msevt_rslts`中每条记录，计算得到5个预警变量的值，代码中实际只计算了：微震频次，大能量，异常区域个数。

* 构造msg信息。`msLevelVec`分别保存：【微震频次，大能量，异常区域个数】的预警等级，计算：大于对应预警变量的阈值即为蓝橙红。

  `getMsWarningLevel()`通过`msLevelVec`中保存的【微震频次，大能量，异常区域个数】3个预警等级，综合计算，返回0/1/2/3到**【`msLevel`微震预警等级】，作为微震3个参数计算得到的预警等级**。若为1则蓝色，不为1则橙色，保存到`warningType`。

* 然后，根据电法信息，得到【电法预警等级`leveL_sp`】，作为电法2个参数计算得到的预警等级。

  再通过一定逻辑，`warningType`中已有的微震预警等级，结合电法预警等级`leveL_sp`，得到最终的【综合预警等级`warningType`】，以及【最终的msg信息】。

  `warningType`，`msLevel`，`leveL_sp`，`msg`入库表`e_warning_Info`。

* 最后，预警发送逻辑：给用户组(msg)发送蓝色和处理后的非蓝色，同时运维组也发一份(告知已发送给用户)

  ```mysql
  string sqlQuery = "SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`=1 AND `is_sent_user`=0 
  UNION 
  SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`> 1 AND `is_handle`= 1 AND `is_sent_user`= 0 "; // 取最新的一条
  ```

  蓝色（`warningType`=1）且未发送给用户，非蓝色（`warningType`> 1）且已被运维处理（`is_handle`= 1）且未发送给用户（`is_sent_user`= 0 ），这些信息发送给用户（alarm）和运维（msg)。

  ```cpp
  string cmdMsg("./send_message.sh \"msg\" \"" + string(" 【预警已发送给用户】 ") + msgTmp + "\"");// 发运维
  string cmdAlarm = "./send_message.sh \"alarm\" \"" +  msgTmp + "\""; // 发用户
  ```

  发送成功，则将表`e_warning_Info`中字段`is_sent_user`置1，表示已发送给用户。

### 预警重算

从表`e_msevt_rslts`中重新查询该时间段的微震事件，进行预警的逻辑计算，得到新的预警记录update入库表`e_warning_Info`。（工程人员会修改表`e_msevt_rslts`中的微震记录，之前的记录是系统自动判别的。）

# 8. 掘进里程和偏移距

目的：迎头每天都在向前移动，可以通过【当前掘进里程-偏移距】得到每天第一个传感器的坐标。

**流程：**

每天【掘进里程】和【偏移距】自动增加（当每日进尺和实际一样时，保持自动增加就行。当实际每日进尺和设定不一致时可手动修正），但是【偏移距】不会每天改，只有当偏移距过大的时候，会挪动一组传感器到距离迎头一定位置处。这时偏移距就是新的传感器距离迎头距离了，手动修改【偏移距】。

**代码：**

* 每天【掘进里程】和【偏移距】自动增加：

  `client_handle_data.cpp-185`

  ```cpp
  mining_locx = (m_dir == 0) ? (mining_locx + days * dayStep) : (mining_locx - days * dayStep);
  //mining_locx掘进里程每天增加，hzi::firstChn_locx靠近迎头传感器坐标保持不变，因此相减得新的偏移距，偏移距也会增加，并显示在页面上
  hzi::heading_mil = mining_locx - hzi::firstChn_locx;
  auto ret1 = updateTunnelCurStatus(mining_locx, hzi::heading_mil, hzi::isConnected,hzi::isRunning, "更新掘进位置", false);//将新的掘进里程和偏移距入库
  ```

* 偏移距就是新的传感器距离迎头距离了，手动修改【偏移距】：

  `client_handle_data.cpp-433`

  ```cpp
  auto constDic = hzi::tunnel_mining_loc - hzi::heading_mil - hzi::firstChn_locx;
  //此时偏移距hzi::heading_mil是更新过的，减小了的。hzi::tunnel_mining_loc - hzi::heading_mil是挪过来的检波器和迎头的距离。即新的hzi::firstChn_locx。再减去旧的hzi::firstChn_locx，就是新旧传感器（最靠近迎头）距离迎头距离的差值。
  ```

  `client_handle_data.cpp-472`

  ```cpp
  "values(loc_x) + ?, loc_y=values(loc_y),loc_z=values(loc_z)";
  conn.execute(sql.c_str(), (double)localtime, (double)ts,constDic);//把e_chns_config_tunnel里每个检波器的坐标都加constDic
  hzi::firstChn_locx = hzi::tunnel_mining_loc - hzi::heading_mil;//经过前面的更新，将hzi::firstChn_locx更新为新的
  ```

      #### 回采位置历史记录

增加表`e_mining_PCOLocParm_history`，在表`e_mining_PCOLocParm`上增加触发器，当表`e_mining_PCOLocParm`：

新增一条记录时，在history表INSERT一条记录。当修改一条记录时，在history表修改该记录。时间戳统一为当天0点。

# 9. 页面

---

## （1）首页

### 里程状态与偏移距

![image-20250409154122217](D:\notes\笔记Img\image-20250409154122217.png)

> 基准传感器（之前代码里写死为通道1，后面改为在挪动的时候可指定通道n）距离迎头距离。4个传感器一组，距离过远把最远那一组移到迎头处。

* 调用接口

```cpp
 url = "../setHeadingMil/" + electrodeRadio + "/" + 1;
                    } else {
                        url = "../setHeadingMil/" + electrodeRadio + "/" + 0;
```

### 巷道探测示意图

> 显示预测的地质异常（地质分层的位置和角度）

![image-20250422131919742](D:\notes\笔记Img\image-2025042213191974211)

## （2）系统

### 工程参数

#### 停止监测

下发命令字:5,设备地址:1,字节数:22,命令标识:101327

#### 启动监测

250408 09:12:50 下发命令字:2,设备地址:1,字节数:54,命令标识:101328
250408 09:12:50 下发命令字:5,设备地址:1,字节数:22,命令标识:101329
250408 09:12:55 下发命令字:3,设备地址:1,字节数:278,命令标识:101330
250408 09:13:15 下发命令字:4,设备地址:1,字节数:38,命令标识:101331

#### 通道配置

> * 用户修改指定基站连接的通道配置信息。
> * 显示的是表`e_chns_config`。

* 修改【工程位】（location2）/【地层位】（location1）/【状态】（state_id），调用接口`/table/`，载荷为`dev_id`，`chn_no`+`location2`/`location1`/`state_id`，修改库表`e_chns_config`中字段。

  其中state_id中状态从库表`p_chn_states`读取。

#### 采集置参

点击【保存】后，调用接口`/cmds/:cmd_id/:dev_id?`3次，`cmd_id`分别为2/5/3，其中3时带payload：

```json
{
    "ms_samp_intvl_id": 2,//修改采样间隔为0.20ms
    "ms_samp_pnts_id": 8,
    "ms_ahead_pnts_id": 6,
    "ms_trig_id": 1,
    "ms_default_thrshld": 5,
    "ms_trig_puls_wid": 3,
    "ms_bg_chk_win_id": 13,
    "ms_bg_up_win_id": 9,
    "ms_ring_thrshld": 200,
    "trig_chn_judgWn": 600,
    "msDateType": 1,
    "trig_chns": 3,
    "trig_time_win": 300,
    "ee_type_id": 1,
    "ee_pw_time_id": 6,
    "ee_voltage_id": 3,
    "ee_m_order_id": 0,
    "ee_m_wid_id": 0,
    "ee_time_schm": 0,
    "ee_times_id": 3,
    "ee_timetable": [
        0,
        7200,
        14400,
        21600,
        28800,
        37200,
        43200,
        50400,
        57600,
        64800,
        72000,
        79200
    ],
    "ee_time_intvl": 30,
    "ee_samp_intvl_id": 8,
    "ee_samp_pnts": 25,
    "ee_voltage_schm": 0,
    "ee_start_atonce": 0,
    "sp_samp_intvl_id": 8,
    "sp_samp_pnts": 250,
    "tmpr_samp_intvl_id": 13,
    "tmpr_up_win_id": 9,
    "coupl_threshold": 201,
    "coupl_samp_intvl_id": 1,
    "coupl_samp_pnts_id": 7,
    "coupl_ahead_pnts_id": 4,
    "auto_gain": 1,
    "gain_id": 3
}
```







### 随掘监测

#### 实时参数

* 将参数保存到表`e_mining_PCOSignalParm`和`e_mining_PCOLocParm`。

| 页面参数                   | 库表参数`e_mining_PCOSignalParm` | 参数说明                                                     |
| -------------------------- | -------------------------------- | ------------------------------------------------------------ |
| 用户参数->【拼接数据类型】 | `class_id`                       | 实时计算取用的数据类型，是【全时/背景】。`threadHanleData()` |
| 用户参数->【监测频度】     | `dataFreq`                       |                                                              |
| 干涉源提取->【数据时长】   | `dataLen`                        | 数据时长（单位时间min)（`时间段/数据时长=炮数`），历史计算代码里是`time_len`即页面上的【分段时长】，实时计算代码里用的是`hzi::miningDateLen` |
| 干涉源提取->【因子时长】   | `coeLen`                         | 因子系数长度(时间单位：min)                                  |
| 干涉源提取->【超前点数】   | `coefBegPt`                      | CSP道集提取用到。                                            |
| 干涉源提取->【输出点数】   | `outLen`                         | 输出及其长度(时间单位ms)                                     |
| 干涉源提取->【因子道】     | `chn_no`                         | 选用因子通道号                                               |
|                            |                                  |                                                              |
|                            |                                  |                                                              |
|                            |                                  |                                                              |

#### 





## （3）监测

### 实时数据

#### 微震全时

![image-20250417103359063](D:\notes\笔记Img\image-202504171033590631)

## （4）随掘

### 随掘地震

> **该页面上属于历史重算。**
>
> **历史重算目的：通过偏移图进行验证输入的参数的效果。把效果好的参数填入实时参数内，然后进行自动处理，并保存为文件。**

#### 树形图

> **查询表`e_mining_pcodata_frm_info`获取数据时间戳。**表`e_mining_pcodata_frm_info`若没记录，表`e_mining_signaldata_frm_info`即使有记录树形图也不会有选项。

* 点击树形图的时间戳后：调用接口`/data_file/:year/:month/:day/:type/:timestamp`

![image-20250415161308369](D:\notes\笔记Img\image-20250415161308369.png)

* 参照园区试验系统->监测->微震事件，解决需求【自动干涉后记录有效标记，无效删除】，在表【e_mining_signaldata_frm_info】中增加字段【isValid】，让用户自己给树形图中项目增加是否有效的标记。

#### 干涉源提取

> * 点击黄色按钮【干涉源提取】。
>
> * 页面上的干涉源提取属于历史重算。只做干涉源提取+偏移（干涉提取图+干涉提取基础上的偏移图），再提取+偏移需手动执行。
>
> * 手动选择时间段，进行干涉（互相关或自相关）得到`提取数据(class_id=9)`和`干涉提取波形图`。并在提取数据和提取图的基础上，按照左侧设定的偏移参数进行偏移得到`偏移数据(class_id=10)`的`偏移图`。
>
> * 重算所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
>
>   > 若用背景原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。
>   >
>   > 若用全时原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。
>
> 时间段不要选太大，一般几分钟，否则数据太多响应很慢。
>
> 分段时长，一般设置和时间段一样大。

* 分段时长：`时间段/分段时长=炮数`。代码逻辑中，时间戳转ms，（开始-结束）/分段时长，得到`dataSize`，即炮数。若干炮数的数据叠加（简单的幅值叠加）。

  ![image-20250416141111347](D:\notes\笔记Img\image-20250416141111347.png)

* 调用接口`/handerSignal/:from_time/:to_time/:time_len/:devId`（time_len即分段时长），回调`handleSignalProcess(dfvec, false,dev_id)`，只进行干涉提取。

* 从表`e_mining_PCOSignalParm_history`中查询`hzi::miningFreq`，`hzi::miningDateLen`，`hzi::mining_classId`。

* 内部调用`mergeMs`拼接帧数据，再调用`handleSignalProcess`进行处理。

* 调用`handleSignalProcess(dfvec, false,dev_id)`，其中`false`表示进行历史计算。

* **但页面上，和【实时参数-数据时长】会写入库表`dataLen`不同的是。历史计算的【分段时长】并没有入库。**

#### 再提取

> * 属于历史计算。
>
> 根据设定好的计算参数对当前选中时间戳的提取数据，**进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`**，并在再提取数据和再提取波形图的基础上，得到新的偏移图。
>
> * **需手动点击【执行】，调用接口`/handerExtSignalParm/:samp_time/:typeId`，回调`handerExtSignalParm`，调用函数`handleExtSignalData`根据时间戳读取上面干涉源提取得到的类型9文件，使用提取文件再次进行后续处理。在`handleExtSignalData`里调用了`PureCommonOperation::handleSignalData`**

![image-20250415161001067](D:\notes\笔记Img\image-20250415161001067.png)

* 点击【执行】后会依次调用接口`/config/:tblName`，回调`setConfig`，将页面上的参数写入表`e_mining_PCOSignalParm_history`。

* 接口`/handerExtSignalParm/:samp_time/:typeId`，回调handleExtSignalData`读取类型9文件进行除干涉提取以外的计算处理。

  ![image-20250415161431325](D:\notes\笔记Img\image-20250415161431325.png)

![image-20250415161517845](D:\notes\笔记Img\image-20250415161517845.png)

![image-20250415161559236](D:\notes\笔记Img\image-20250415161559236.png)

#### 提取图上选项

![image-20250509111846311](D:\notes\笔记Img\image-20250509111846311-1746760727617-1.png)

## （5）分析

### 日报发布

### 日报查询

| -                                    | -                                                            |
| ------------------------------------ | ------------------------------------------------------------ |
| /daily_sheet_dates                   | 获取日报pdf文件文件名的json。                                |
| /post_daily_sheet/:name              | 将日报pdf文件以【年-月-日.pdf】的名称作为参数name，重命名文件，二进制类型，发送到后端。 |
| /daily_sheet/:year/:month/:day/:file | 从服务器获取日报pdf文件。                                    |

前端页面里在代码里拼的url，使用的`daily_sheet`获取的pdf，使用`iframe`打开：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test pdf</title>
</head>

<body>
    <iframe src="../daily_sheet/2022/3/15/DailySheet.pdf" frameborder="0"></iframe>
</body>

</html>
```







# 4. 配置文件

---

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],

	//"semt"微震系统
	//"semt_carousel"轮播图微震系统
	//"tunnel"长沙铁建
	//"tunnel_1"随掘
	//"mining"随采
    "serve_for": "tunnel_1",
    "ms_tunnel_listen":false,
    "http_port": 11507,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": true, //随采
    "ms_miningSignal": true,//
    "save_full_msdata": false,
    "ms_tunnel": true,//
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 2,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",//本地服务器数据库
    "data_root": "/var/kwang/frame_data"//本地服务器数据路径
    // "mysql_url": "mysql://192.168.74.118:3309/semtdb1?user=hzidba&password=dzaqZHk3",//地下坑道随掘数据库
    // "data_root": "/home/kwang/workspace/kengdao_tunnel"//地下坑道随掘数据路径
}
```

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.134",
            "device_port": 5086,
            "server_port": 5086
        }
    ],
    //"serve_for": "tunnel_1",
    "serve_for": "semt",
    "http_port": 11507,
    "realtime_interval": 1,
    "link_device": true,
    "time_sync": false,
    "timesync_interval": 10,
    
    "ms_experimental": false,
    "multi_chn_trig": false,
    "ms_grid_step": 0.1,
   
    "ms_tunnel_listen":false,    // 修改成是否有tcp通讯
    "warningType":0,  // warningType 异常预警计算类型（约定 1：铁建移动检波器时异常聚类  2：根据时间进行聚类提取 3：样本数量 4：提取次数）
    "ms_interface_type":0, //采集页面维度类型 0-XY 1-XZ 2-XYZ 
    "ms_mining_type":0,    //随采类型 0-无随采 1-随采 2-随掘
    "ms_components":1,     //微震通道分量设置，默认单分量
    "ms_rate": 0.8,
    "ms_mining":true,
    "ms_miningSignal":true,
    "ms_locating":true,
    "ms_tunnel":true,
    "save_full_msdata":true,
    "ms_trigger":true,
    "is_used_warning":true,

    "warningTimeSyncIntval":2,
    "warningTimeSync":true,
    "tunnel_server":"192.168.72.110",
    "tunnel_port":3002,

    "ftpUrl":"ftp://192.168.74.232:21/shfz/411081005643/WZ/",
    "ftpUserName":"ftpUser",
    "ftpPassWord":"testFTP123456",
    "upWSData":true,

    "digest_duration": 10,
    "optical_strain":true,
    "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/var/kwang/frame_data",
    //"data_root": "/home/kwang/workspace/yuanqu",
    "project_name":"库尔勒金川煤矿",
    "msg_receivers":"WangKun",
    "alarm_receivers":"WangKun",
    "leader_receivers":"GuoJinShuai",
    "probe_to":{
        "min_x":50,
        "max_x":50,
        "min_y":50,
        "max_y":50,
        "min_z":50,
        "max_z":10
    }
}
```

# 5. 通道类型

---

| type_id | 数据类型                  | 通道数                              | 通道label           |
| ------- | ------------------------- | ----------------------------------- | ------------------- |
| 0       | 微震采集                  | datachns[2/3/6]                     | dataChnLabel[2/3/6] |
| 1       | 电法采集                  | datachns[0/1]                       | dataChnLabel[0/1]   |
| 2       | 电法发射eeChannel（激电） |                                     |                     |
| 3       | 电磁采集                  |                                     |                     |
| 4       | 温度采集                  | datachns[4]                         |                     |
| 5       | 电法B极                   | datachns[0]+datachns[2]+datachns[4] | dataChnLabel[5]     |
| 6       | 电法N极                   |                                     |                     |

# 6. 接口

---

> 接口名：routes.cpp
>
> 回调函数：commands.cpp，ms_commands

## 接口模板

```cpp
//GET请求 
Routes::Get(RoutesManager::router, "/devices",
              Routes::bind(&cmd::getDevices));

//POST请求 
Routes::Post(RoutesManager::router, "/save_devices",
              Routes::bind(&cmd::saveDevices));

//request解析
if(!request.hasParam(":from_time") || !request.hasParam(":to_time"))//判断参数是否存在
{
  response.send(Http::Code::Bad_Request, "缺少参数：起止时间");
  return;
}
uint64_t fromTime = request.param(":from_time").as<uint64_t>();
uint64_t endTime = request.param(":to_time").as<uint64_t>();

//response相关
response.headers().add<Http::Header::ContentType>(MIME(Text, Plain));//设定response响应头

//发送
response.send(Http::Code::Expectation_Failed, "重算失败");//直接传字符串
string err = "error";
response.send(Http::Code::Expectation_Failed, "重算失败：" + err); //传字符串+string
response.send(Http::Code::Expectation_Failed, err.c_str());//只传string要转char*
```

```cpp
  void getDevices(const Rest::Request &request, Http::ResponseWriter response)
  {
    try
    {
      response.headers().add<Http::Header::ContentType>("application/json");
      //string devices = "{";
      string devices="{\"devices\":[";
      string id;
      string device_ip;
      string device_port;
      string server_port;
      auto iter = hzi::config.devicesMap.begin();
      for (; iter != hzi::config.devicesMap.end(); iter++)
      {
        id = std::to_string(iter->second.id);
        device_ip = iter->second.devIp;
        device_port = std::to_string(iter->second.devPort);
        server_port = std::to_string(iter->second.serverPort);
        std::ostringstream oss;
        oss << "{" << "\"id\":" << id << ",\"device_ip\":\"" << device_ip << "\",\"device_port\":" + device_port + ",\"server_port\":" + server_port + "}";
        string device = oss.str();
        // string device = std::format("{id: {0}, device_ip: {1}, device_port: {2}, device_port: {3}}",id,device_ip,device_port,sever_port);
        devices += device;
        devices += ",";
      }
      devices.pop_back();
      devices += "]}";
      response.send(Http::Code::Ok, devices.c_str());
    }
    catch(const std::exception &e)
    {
      response.send(Http::Code::Bad_Request, e.what());
    }
  }
```

## apifox测试接口

```url
https://192.168.74.37:11507/devices
https://192.168.74.37:11507/save_devices/sys_config.json
```

## 状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | 成功                                                         |
| 405    | 接口的方法类型搞错了。比如一个接口是POST方法，发了GET请求    |
| 204    | 成功响应但是没有返回内容，No Content                         |
| 413    | HTTP 状态码 **413 Content Too Large**（内容过大）表示客户端发送的请求实体超过了服务器定义的大小限制。服务器可能会关闭连接或返回一个 *Retry-After* 头字段 |
| 417    | HTTP 417 错误，即**“Expectation Failed”**                    |
|        |                                                              |



## 接口汇总

| 我写的或修改过的接口                | 功能                                                         | 用法                                              |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| /upload_save_warningImg/:name       | 上传图片并入库                                               | name传图片名称，包括后缀名                        |
| /upload_doc/:mime/:name             | 文件上传：图片，pdf，xlsx，csv，zip                          | mime传后缀名，name传文件名包括后缀名              |
| /download_doc/:mime/:name           | 下载文件：图片，pdf，xlsx，csv，zip                          |                                                   |
| /configFilePath                     | 获取配置文件路径                                             |                                                   |
| /firstChnNO                         | 获取基准通道号                                               |                                                   |
| /devices                            | 获取配置文件中devices字段信息                                |                                                   |
| /update_devices/:jsonName           | 修改配置文件中devices字段信息                                | jsonName传配置文件名，包括etc/                    |
| /semt                               | 用户登录。改了`verifyUser`函数。                             |                                                   |
| /nopswd                             |                                                              |                                                   |
| /warning_recalc/:from_time/:to_time | 预警历史重算：e_warning_info表删除指定时间段内已有预警信息，从e_msevt_rslts中重新筛选记录经过计算入库。 |                                                   |
| /table/:tblName/:delCondition?      |                                                              | 我增加了：function类型，用于传SQL函数作为插入值。 |
|                                     |                                                              |                                                   |

| 接口汇总                                                     | 功能                                                         | 使用方法                                              | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------- | ------------------------------------------------------------ |
| /update_columns/:tblName/:condition                          | 修改已有记录的字段值                                         |                                                       |                                                              |
| /table/:tblName/:delCondition?                               | 插入（修改）记录或删除记录                                   |                                                       | delCondition传"true"则清空表，传其他字符串则会作为删除WHERE后的条件。                                                                                                                                                                                 若payload传json，则会继续执行插入（修改）操作：`schema`字段为数组`{"schema":[ {"name":"mining_date", "type":"string"}, {"name":"mining_locx", "type":"float"}, {"name":"day_step", "type":"float"}],"values":[["2025-04-27 00:00:00.0000", 1300, 10],["2025-04-28 00:00:00.0000", 1300, 11]]}`，传表所有字段名`name`和类型`type`（string，float，double，int64）；`values`传字段的对应值。注意：datetime类型字段，后台没专门写，type写string。我增加了：function类型，用于传SQL函数作为插入值。 |
|                                                              |                                                              |                                                       |                                                              |
| /setHeadingMil/:typeId/:isWarning                            | 修改偏移距                                                   |                                                       |                                                              |
| /config/:tblName                                             |                                                              |                                                       | 根据传入json的`is_init`字段：为true时，先删除指定表中`is_init==1`的记录。为false时，先`TURNCATE`清空表。最后，把记录值`INSERT`插入表，is_init置1。 |
| /handerSignal/:from_time/:to_time/:time_len/:devId           | 历史计算                                                     |                                                       |                                                              |
| /handerSignalMining/:from_time/:to_time/:time_len/:devId     | 历史计算（mining？）                                         |                                                       |                                                              |
| /download/:from_time/:to_time/:is_csv/:file_name             | 选中时间段内原始数据（根据hzi::mining_classId决定类型3/6）拼帧并打包为zip下载 | is_csv=0-bin文件/1-csv文件/2-qfx文件。file_name未用。 |                                                              |
| /download/:type_id/:from_time/:to_time/:is_csv/:file_name/:only_ms_valid? |                                                              |                                                       |                                                              |
| /samp_conf/:tblName/:itmNames/:fromInit?                     |                                                              |                                                       |                                                              |
| /daily_sheet/:year/:month/:day/:file                         | 从data_root下获取文件                                        |                                                       |                                                              |
| /daily_sheet_dates                                           | 以json形式返回data_root下的年月日的pdf文件，文件名类似2025-5-1.pdf。json形式是年字段下数组为月数组，月数组下为日字段对应文件的路径。 |                                                       |                                                              |
| /post_daily_sheet/:name                                      |                                                              |                                                       |                                                              |
| /data_file/:year/:month/:day/:type/:timestamp                |                                                              |                                                       |                                                              |
| /handerExtSignal/:samp_time/:typeId                          | 回调：`handerExtSignal`，回调调用`processMethods`，这个函数。使用提取信号再次进行后续的再提取和偏移。 |                                                       |                                                              |
| /handerExtSignalParm/:samp_time/:typeId                      | 回调：`handerExtSignalParm`，回调调用`handleExtSignalData`   |                                                       |                                                              |
| /handerExtSignalPianYi/:from_time/:to_time                   | 用指定时间段的提取文件（9），调用saveResult()生成偏移文件（10） |                                                       |                                                              |
|                                                              |                                                              |                                                       |                                                              |
|                                                              |                                                              |                                                       |                                                              |
| **日报**                                                     |                                                              |                                                       |                                                              |
| /daily_sheet_dates                                           | 获取日报pdf文件文件名的json。                                |                                                       | 遍历`data_root`下所有目录（看作年份目录），再遍历年份目录下的目录（看作月份目录），再遍历月份目录下的目录（看作日目录），将年-月-日.pdf作为文件名。最后将年，月，日写为json的树状结构，日作为字段，文件名作为值。json字符串发送给前端。json形如：`{2025: {5: {1: "2025-5-1.pdf", 2: "2025-5-2.pdf"}}}` |
| /post_daily_sheet/:name                                      | 将日报pdf文件以【年-月-日.pdf】的名称作为参数name，重命名文件，二进制类型，发送到后端。 |                                                       |                                                              |
| /daily_sheet/:year/:month/:day/:file                         | 从服务器获取日报pdf文件。                                    |                                                       |                                                              |
|                                                              |                                                              |                                                       |                                                              |
|                                                              |                                                              |                                                       |                                                              |
|                                                              |                                                              |                                                       |                                                              |
|                                                              |                                                              |                                                       |                                                              |





# 7. 数据库

---

> * 使用开源库`libzdb`
>
> * 凡是查表，一定要考虑表为空的情况，增加查不到记录时的边界条件判断，增加软件健壮性。
>
> ```cpp
> Connection conn = hzi::config.pConnPool->getConnection();
> ```

## 查询

```cpp
//zdbpp.h
int columnCount() {
            return ResultSet_getColumnCount(t_);
        }
        
        const char *columnName(int columnIndex) {
            except_wrapper( RETURN ResultSet_getColumnName(t_, columnIndex) );
        }
        
        long columnSize(int columnIndex) {
            except_wrapper( RETURN ResultSet_getColumnSize(t_, columnIndex) );
        }

        void setFetchSize(int prefetch_rows) {
            ResultSet_setFetchSize(t_, prefetch_rows);
        }

        int getFetchSize() {
            return ResultSet_getFetchSize(t_);
        }

        bool next() {
            except_wrapper( RETURN ResultSet_next(t_) );
        }
        
        bool isnull(int columnIndex) {
            except_wrapper( RETURN ResultSet_isnull(t_, columnIndex) );
        }
        
        const char *getString(int columnIndex) {
            except_wrapper( RETURN ResultSet_getString(t_, columnIndex) );
        }
        
        const char *getString(const char *columnName) {
            except_wrapper( RETURN ResultSet_getStringByName(t_, columnName) );
        }
        
        int getInt(int columnIndex) {
            except_wrapper( RETURN ResultSet_getInt(t_, columnIndex) );
        }
        
        int getInt(const char *columnName) {
            except_wrapper( RETURN ResultSet_getIntByName(t_, columnName) );
        }
        
        long long getLLong(int columnIndex) {
            except_wrapper( RETURN ResultSet_getLLong(t_, columnIndex) );
        }
        
        long long getLLong(const char *columnName) {
            except_wrapper( RETURN ResultSet_getLLongByName(t_, columnName) );
        }
        
        double getDouble(int columnIndex) {
            except_wrapper( RETURN ResultSet_getDouble(t_, columnIndex) );
        }
        
        double getDouble(const char *columnName) {
            except_wrapper( RETURN ResultSet_getDoubleByName(t_, columnName) );
        }
        
        template <typename T>
        std::tuple<const void*, int> getBlob(T v) {
            int size = 0;
            const void *blob = nullptr;
            if constexpr (std::is_integral<T>::value)
                except_wrapper( blob = ResultSet_getBlob(t_, v, &size) );
            else
                except_wrapper( blob = ResultSet_getBlobByName(t_, v, &size) );
            return {blob, size};
        }
        
//返回时间戳，（time_t是时间戳epoch到现在的seconds)
        time_t getTimestamp(int columnIndex) {
            except_wrapper( RETURN ResultSet_getTimestamp(t_, columnIndex) );
        }
        
        time_t getTimestamp(const char *columnName) {
            except_wrapper( RETURN ResultSet_getTimestampByName(t_, columnName) );
        }
        
//返回datetime，（tm是结构体存有年月日时分秒）
        struct tm getDateTime(int columnIndex) {
            except_wrapper( RETURN ResultSet_getDateTime(t_, columnIndex) );
        }
        
        struct tm getDateTime(const char *columnName) {
            except_wrapper( RETURN ResultSet_getDateTimeByName(t_, columnName) );
        }

struct tm
{
  int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
  int tm_min;			/* Minutes.	[0-59] */
  int tm_hour;			/* Hours.	[0-23] */
  int tm_mday;			/* Day.		[1-31] */
  int tm_mon;			/* Month.	[0-11] */
  int tm_year;			/* Year	- 1900.  */
  int tm_wday;			/* Day of week.	[0-6] */
  int tm_yday;			/* Days in year.[0-365]	*/
  int tm_isdst;			/* DST.		[-1/0/1]*/

# ifdef	__USE_MISC
  long int tm_gmtoff;		/* Seconds east of UTC.  */
  const char *tm_zone;		/* Timezone abbreviation.  */
# else
  long int __tm_gmtoff;		/* Seconds east of UTC.  */
  const char *__tm_zone;	/* Timezone abbreviation.  */
# endif
};
```

```cpp
string sqlQuery="";
Connection conn = hzi::config.pConnPool->getConnection();
auto rslt = conn.executeQuery(sqlQuery.c_str(),val,val,val);
//或是直接写字符串
auto rslt = conn.executeQuery("",val,val,val);

//常用获取字段函数
rslt.getInt("field");
rslt.getDouble("field");
rslt.getString("field");

//或者
bool ret = queryDb(conn,"SELECT * FROM e_users where user_name=? and password=PASSWORD(?)",user, pswd)?true:false;
```

```cpp
//查询有记录则返回，否则返回字符串异常
template <typename... Args>
tl::expected<ResultSet, std::string> queryDb(Connection &conn, const char *sql, Args... args) 
{
  try 
  {
    ResultSet result = conn.executeQuery(sql, args...);
    if (result.next()) 
    {
      return result;
    } 
    else 
    {
      return tl::make_unexpected("not found in query: " + std::string(sql));
    }
  } 
  catch (sql_exception& e) //sql_exception定义在zdbpp.h中
  {
    return tl::make_unexpected("sql error for " + std::string(sql) + ": " + std::string(e.what()));
  }
  catch (std::exception& e) //sql_exception定义在zdbpp.h中
  {
    return tl::make_unexpected(std::string(e.what()));
  }
}
```



## 插入/删/改（若存在则更新）

```cpp
string sql = "INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)";
conn.execute(sql.c_str(), val,val,val);

//或
conn.execute("INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)", val1,val2,val3,val4,val5,val6,val7);
```

## 存储过程

```cpp
//prepareStatement的sql语句需要直接在括号内写字符串，不能先定义为string再传值
Connection conn = hzi::config.pConnPool->getConnection();
PreparedStatement prp = conn.prepareStatement("INSERT INTO e_tunnel_locInfo (mining_loc,tmstamp) values(?,?) ON DUPLICATE KEY UPDATE tmstamp = values(tmstamp)");
conn.beginTransaction();
prp.bind(1, mining_locx);
prp.bind(2, (double)tmstamp);//时间戳转成double再存
prp.execute();
conn.commit();
```

```cpp
function "zdb::PreparedStatement::bind(int, int)" (declared at line 394)
function "zdb::PreparedStatement::bind(int, long long)" (declared at line 398)
function "zdb::PreparedStatement::bind(int, double)" (declared at line 402)
function "zdb::PreparedStatement::bind(int, time_t)" (declared at line 406)
```

## 时间戳相关

### unix时间戳（int64_t）直接存库和取

库表字段数据类型设为`bigint`，11位，但存入库中不直接存uint64_t，而是强转为double再存入。

用`getDouble("field")`从查询语句结果中获取值。

```cpp
//获取表内字面值，强转long long int。（uint64_t无法获取字面值）
auto msgSentToUsers = conn.executeQuery("...");
uint64_t tm = msgSentToUsers.getDouble("tm");
cout<<"tm="<<tm<<endl;//和数据库中所存的值不等
cout<<"tm="<<static_cast<long long>(tm)<<endl;//和数据库中所存字面值相等
auto tmTmp = static_cast<long long>(tm);
conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", tmTmp);

//但这里为什么uint64_t可以取数据库字面值？
string sqlMs = "SELECT * FROM `e_msevt_rslts` WHERE samp_time >=" + std::to_string(fromsampTime) +
                   " and samp_time <= " + std::to_string(endsampTime) + " and validity = 1";
auto rslt_ms = conn.executeQuery(sqlMs.c_str());
```

### unix时间戳（int64_t）转成datetime存库和取

库表字段数据类型设为`datetime`，4位，在sql语句中调用函数`FROM_UNIXTIME()`将unix时间戳转成`datetime`插入。

用`getDateTime("field")`从查询结果中获取值。

```cpp
uint64_t tmStmp = dfVec[0]->sampTime();

conn21.execute(
            "INSERT INTO "
            "e_mining_signaldata_frm_info "
            "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
            "loc,fx,fy,fz,dis)"
            "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
            " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
            "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
            (uint8_t)devId,  // dev_id
            tmStmp / 1000.0, // samp_time
            classId2,        // class_id
            deltT,           // curt_ch
            valNum,          // channels
            vecSize,
            pcoParm.outLen, // ch_pnts
            (relLocFromTime(tmStmp) / std::to_string(classId2) /
             std::to_string(tmStmp))
                .c_str(), // frm_loc
            pcoLocParm.fx,
            pcoLocParm.fy,
            pcoLocParm.fz,
            pcoLocParm.dis_y);
```



## 表更新

```cpp
//where?表示where可选，可不传值
//SELECT [cols冒号左侧为字段名field1,field2,...] FROM [tblName] [where];
//response：{"code":0,"data":[{"field1":"field1Val"},{"field2":"field2Val"},...]}
Routes::Get(RoutesManager::router, "/table/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData));//表查询
Routes::Get(RoutesManager::router, "/table1/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData1));//queryTblData1用的是pTempConnPool
```

```cpp
//UPDATE tblName set [请求体updates字段值] where [condition]
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));

//
Routes::Post(RoutesManager::router, "/update/:tblName/:refCol/:updateCol",
               Routes::bind(&cmd::updateColumnRef));

//delCondition传true：delete from [tblName]
//传where语句：delete from [tblName] where ...
//若请求体中有schema和values，遍历json数组schema获取要更新的字段名，遍历json数组value获取要更新的字段的值。请求体中还应有type，指明字段值的类型是string/float/double/int64：insert into [tblName] (field1, field2,...)values('value11','value12',...),('value21','value22',...) on duplicate key update field1=values(value1),field2=values(value2)...;插入多条记录，若有主键相同的记录改为update修改(on duplicate key)
Routes::Post(RoutesManager::router, "/table/:tblName/:delCondition?",
               Routes::bind(&cmd::updateTable));//表增删改


//UPDATE [tblName] set [请求体updates字段值] where [condition].
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));
```

* `response.headers().add<Http::Header::ContentType>("text/plain; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `text/plain`。这表示服务器返回的内容是纯文本格式
* `response.headers().add<Http::Header::ContentType>("application/json; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `application/json; charset='utf-8'`。这表示服务器返回的内容是JSON格式，并且使用UTF-8字符集进行编码。

## 上传图片

```cpp
Routes::Post(RoutesManager::router, "/upload_image/:name",
               Routes::bind(&cmd::uploadImage));

void uploadImage(const Rest::Request &request, Http::ResponseWriter response) {
  response.headers().add<Http::Header::ContentType>(
      "text/plain; charset='utf-8'");
  string name = request.param(":name").as<string>();
  if (request.body().empty() || name == "undefined") {
    response.send(Http::Code::No_Content, "没有传入图片！");
    return;
  } // 理论上，严谨的写法，还需要判断传入的 MIME type 是不是图片

  try {
    string path = "assets/images/" + name;
    std::ofstream fout(path);
    fout.write(request.body().data(), request.body().size());
    fout.close();
  } catch (std::exception &e) {
    string reason = "图片 " + name + " 写入目录错误：" + e.what();
    logErr(reason);
    response.send(Http::Code::Expectation_Failed, reason);
    return;
  }
  response.send(Http::Code::Ok, "图片 " + name + " 上传成功！");
}
```

## 上传数据文件

```cpp
Routes::Post(RoutesManager::router, "/upload_DateFile/:name",
               Routes::bind(&ms_comm::uploadDateFile));


void uploadDateFile(const Rest::Request &request,
                    Http::ResponseWriter response) {
  if (request.body().empty()) {
    response.send(Http::Code::No_Content, "The request body is empty");
    return;
  }
  string name = request.param(":name").as<string>();
  cout << " name = " << name << endl;
  try {
    if (0) {
      //电法反演数据处理
      string fileName2 = "test/1111.dat";
      std::ifstream dat_data("test/1111.dat", std::ios::in);
      string line_dat;

      if (!dat_data.is_open()) {
        return;
      }

      char deli = (fileName2.find(".dat") != std::string::npos) ? '\t' : ',';

      std::vector<string> words_dat; // 声明一个字符串向量
      std::vector<vector<float>> dataVec;

      // 读取数据
      while (std::getline(dat_data, line_dat)) {
        words_dat.clear();
        split_String(line_dat, deli, words_dat);
        //  cout<<" words_dat.size() = "<<words_dat.size()<<endl;
        if (words_dat.size() == 4) {
          vector<float> tmpData;
          tmpData.push_back(atof(words_dat[0].c_str()));
          tmpData.push_back(atof(words_dat[1].c_str()));
          tmpData.push_back(atof(words_dat[2].c_str()) - 720);
          tmpData.push_back(atof(words_dat[3].c_str()));
          dataVec.push_back(tmpData);
          // cout<<atof(words_dat[0].c_str())<<","
          //     <<atof(words_dat[1].c_str())<<","
          //     <<atof(words_dat[2].c_str())<<","
          //     <<atof(words_dat[3].c_str())<<endl;
        }
      }

      float dx = 5;
      float dy = 4;
      float dz = 20;
      float max_x, min_x, max_y, min_y, max_z, min_z;
      max_x = 960;
      min_x = 0;
      max_y = 510;
      min_y = 0;
      max_z = -575;
      min_z = -820;

      int xSize = int((max_x - min_x) / dx);
      int ySize = int((max_y - min_y) / dy);
      int zSize = int((max_z - min_z) / dz);
      cout << " size = " << dataVec.size() << " ," << xSize << " ," << ySize
           << "," << zSize << endl;
      //初始化网格
      vector<vector<vector<GridCell>>> grid;
      initializeGrid(grid, xSize, ySize, zSize);

      for (int i = 0; i < dataVec.size(); i++) {
        auto x = dataVec[i][0];
        auto y = dataVec[i][1];
        auto z = dataVec[i][2];
        auto p = dataVec[i][3];
        int x_index = int((x - min_x) / dx);
        int y_index = int((y - min_y) / dy);
        int z_index = int((z - min_z) / dz);
        // cout<<x_index<<" ,"<<y_index<<","<<z_index<<" ,"
        //     <<x_index<<" ,"<<y_index<<","<<z_index<<endl;
        GridCell cell;
        cell.hasValue = true;
        cell.value = p;
        cell.r = 1;
        cell.intersectValues.push_back(p);
        grid[x_index][y_index][z_index] = cell;
      }

      //克里金插值
      debugLog(" start applyKrigingInterpolation");
      int variogramType = 0; // 0 表示球状模型。1 表示指数模型。2 表示高斯模型。
      applyKrigingInterpolation(grid, xSize, ySize, zSize, variogramType);
      debugLog(" end applyKrigingInterpolation");

      // 2023-12-18 4:00:00
      uint64_t fromsampTime = 1702843200000;
      //保存结果
      auto classId = 30;
      int file_type = 3;
      int constSize = 16; // x,y,z,p 16字节
      unique_ptr<char[]> pHeadData = std::make_unique<char[]>(64);
      char *pHead = pHeadData.get();
      *(double *)(pHead) = (double)fromsampTime;
      *(uint16_t *)(pHead + 8) = constSize; //

      fs::path fileName(hzi::config.dataRoot);

      fileName /= relLocFromTime(fromsampTime) / std::to_string(classId) /
                  std::to_string(fromsampTime) / std::to_string(file_type);
      auto dir = fileName.parent_path();
      if (!fs::exists(dir)) {
        fs::create_directories(dir);
      }
      std::ofstream ofs(fileName, std::ofstream::binary);
      ofs.write(pHead, 64);
      for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
          for (int k = 0; k < zSize; ++k) {
            if (!grid[i][j][k].hasValue)
              continue;
            float x = min_x + i * dx + dx / 2.0;
            float y = min_y + j * dy + dy / 2.0;
            float z = min_z + k * dz + dy / 2.0;

            unique_ptr<char[]> pGridData = std::make_unique<char[]>(constSize);
            char *pGrid = pGridData.get();
            *(uint32_t *)(pGrid) = *((int32_t *)&x);
            *(uint32_t *)(pGrid + 4) = *((int32_t *)&y);
            *(uint32_t *)(pGrid + 8) = *((int32_t *)&z);
            *(uint32_t *)(pGrid + 12) = *((int32_t *)&grid[i][j][k].value);
            //   cout<<x<<","<<y<<","<<z<<","<<grid[i][j][k].value<<endl;
            ofs.write(pGrid, constSize);
          }
        }
      }

      ofs.close();
      cout << "OK" << endl;
      autoHandleData(fromsampTime);
      response.send(Http::Code::Ok, "OK");
      return;
    }

    // Read the request body (the CSV file) into a stringstream

    // std::ifstream csv_data("test/GathEP-X.csv", std::ios::in);
    // string line;
    // if (!csv_data.is_open())
    // {
    //       return;
    // }

    std::stringstream csv_data(request.body().data());

    std::string line;

    std::vector<string> words; // 声明一个字符串向量
    string word;
    string fileHead;
    // 读取标题行
    std::getline(csv_data, fileHead);
    split_String(fileHead, ',', words);
    int chns = 0;
    int points = 0;
    float deltT = 0;
    int prepoint = 0;
    cout << " 1 fileHead = " << fileHead << endl;
    if (words.size() >= 4) {
      chns = atoi(words[0].c_str());
      points = atoi(words[1].c_str());
      deltT = atof(words[2].c_str());
      prepoint = atoi(words[3].c_str());
    }
    cout << " chns = " << chns << " points = " << points << " deltT = " << deltT
         << " prepoint = " << prepoint << endl;

    float **pData = new float *[chns];
    for (int ch = 0; ch < chns; ++ch) {
      pData[ch] = new float[points];
    }
    int index = 0;
    // 读取数据
    while (std::getline(csv_data, line)) {
      words.clear();
      split_String(line, ',', words);
      if (words.size() >= chns) {
        for (int ch = 0; ch < chns; ++ch) {
          pData[ch][index] = atof(words[ch].c_str());
          // if(index < 3){
          //     cout<<pData[ch][index]<<"  ";
          // }
        }
      }
      //  if(index < 3)cout<<endl;
      index++;
    }
    //写入微震事件
    if (0) {
      // unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
      // char* pHead = pHeadData.get();
      const float voltageCoef = 3000.0 / 8388607.0;
      // for (int ch = 0; ch < chns; ++ch) {
      //   for(int pnt = 0;pnt <points;pnt++){
      //     pData[ch][pnt] /= voltageCoef;
      //   }
      // }
      cout << " -- 101 --" << chns << "," << points << endl;
      DataFrame msDf(chns, points);
      cout << " -- 1 --" << endl;
      auto tm = nowMS();
      msDf.setSampTime(tm);
      cout << " -- 2 --" << endl;
      msDf.addDevMask(1);
      cout << " -- 3 --" << endl;
      msDf.setDevMask();
      cout << " -- 4 --" << endl;
      msDf.setClassId(2);
      cout << " -- 5 --" << endl;
      msDf.setHeadValue(19, deltT);
      cout << " -- 61 --" << endl;
      int32_t *p32 = reinterpret_cast<int32_t *>(msDf.upData.get());
      for (int ch = 0; ch < chns; ++ch) {
        for (int pt = 0; pt < points; ++pt) {
          float value = pData[ch][pt];
          int32_t originalValue = static_cast<int32_t>(value * 8388607.0 / 3.0);
          p32[ch * points + pt] = originalValue;
        }
        // std::memcpy(msDf.upData.get() + ch * points * sizeof(float),
        // pData[ch], points * sizeof(float));
      }
      msDf.save();
      //   for (int i = 0; i < 10; ++i) {
      //     std::cout << p32[i] << " ";
      // }
      response.send(Http::Code::Ok, "OK");
      return;
    }

    logInfo("start handleSignalProcess_test");
    // string filepath =
    //     test_mining(pData, points, chns, deltT, prepoint);
    string filepath =
        handleSignalProcess_test(pData, points, chns, deltT, prepoint);
    logInfo(filepath);
    string rslt("{");
    rslt += "\"ms_miningSignal\": \"";
    rslt += std::to_string(hzi::config.ms_miningSignal);
    rslt += "\",";
    rslt += " \"tm\": \"";
    rslt += filepath;
    rslt += "\" } ";
    response.headers().add<Http::Header::ContentType>(
        "application/json; charset='utf-8'");
    // cout << " rslt = " << rslt << endl;

    response.send(Http::Code::Ok, rslt);
    // std::thread(test_scan).detach();
    //  fs::path peerPath(filepath);
    //  if (fs::exists(peerPath)) {
    //      Http::serveFile(response, peerPath.c_str());
    //  } else {
    //      response.send(Http::Code::No_Content, "no_content");
    //  }
    logInfo("endl handleSignalProcess");

  } catch (std::exception &e) {
    logErr(e.what());
    response.send(Http::Code::Expectation_Failed, " uploaded failed!");
    return;
  }
  // response.send(Http::Code::Ok, " uploaded successfully!");
}

```

```cpp
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],
    "serve_for": "semt",
    "http_port": 11504,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": false,
    "ms_miningSignal": false,
    "save_full_msdata": false,
    "ms_tunnel": false,
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 0,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://192.168.74.113:3308/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/home/yzheng/workspace/yuanqu"
}
```

## 变量与表对应

| 变量                                           | 表名                                                 | 说明 |
| ---------------------------------------------- | ---------------------------------------------------- | ---- |
| hzi::viewSpace                                 | e_space                                              |      |
| hzi::densityGrays                              | p_density_grays                                      |      |
| hzi::densityColors                             | p_density_colors                                     |      |
| hzi::msEvtCnf.sampIntvl                        | p_samp_intvls                                        |      |
| hzi::msEvtCnf.msAheadPnt                       | p_points                                             |      |
| hzi::msEvtCnf.pulsWid，hzi::msEvtCnf.ringThrld | e_ms_samp_config                                     |      |
| hzi::msEvtCnf.msThrldsMap                      | e_chns_config（chn_label，ms_trig_thrld,is_ms_trig） |      |
| hzi::viewSpace                                 | e_speed                                              |      |
| hzi::viewSpace.vtispeed_vector                 | e_vti_speeds                                         |      |
| hzi::chnState                                  | e_chns_config（chn_label, state_id）                 |      |
|                                                |                                                      |      |

## 表说明

| 表名                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
|                                |                                                              |
| **参数配置**                   |                                                              |
| e_send_frm_log                 | 服务器向设备发送的命令的日志                                 |
| e_station_info                 | 基站监测，【基站检测应答帧】参数入库                         |
| e_dev_clock                    | 时间校准，【时间校准应答帧】参数入库                         |
| e_dev_config_ack               | 参数配置，【参数配置应答帧】参数入库                         |
| e_users                        | 用户名，密码                                                 |
| e_space                        | 系统-工程参数-空间参数（设定这张表中所存参数：**原点坐标/巷道xyz的范围/网格宽度**等坐标常数）。数据计算时，`getPCO_parm`函数查出存到`PureCommonOperation::PCOLocParm`变量里。 |
| e_info                         | 系统-工程参数-工程参数                                       |
| p_data_types                   | 数据类型编号说明type_id                                      |
| e_tunnel_cur_status            | 存储【掘进位置】【偏移距】【超前距离】【back_distance】【forward_distance】等巷道参数 |
|                                |                                                              |
| e_chns_config_tunnel           | 通道的配置等参数。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn` |
| e_chns_config                  | **用户输入的通道信息**。比如坐标。                           |
| e_chns_config_history          | **通道的历史信息（因为通道会移动，坐标也会改变，而历史计算需要历史的通道的数据）**。通道更新`e_chns_config`时触发器会自动更新该表。代码中用到该表都是查询。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn`变量。 |
|                                |                                                              |
| e_tunnel_serverInfo            | 服务器的ip和port                                             |
| e_tunnel_model_info            |                                                              |
|                                |                                                              |
| e_ms_samp_config               | 保存【采集置参->微震采集参数】修改                           |
| p_samp_intvls                  | 【采样间隔】与id对应关系                                     |
| p_points                       | 【采样点数】和【超前点数】与id                               |
| p_ms_trigs                     | 【触发方式】与id                                             |
|                                |                                                              |
|                                |                                                              |
|                                |                                                              |
|                                |                                                              |
| **干涉提取**                   |                                                              |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | 9类型数据，提取图数据                                        |
| e_mining_pcodata_frm_info      | 10类型数据，偏移图数据                                       |
| e_mining_PCOSignalParm         | **实时计算参数，信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **历史计算参数，信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。 |
| e_mining_PCOLocParm            | **实时/历史计算，坐标等参数值。回采位置/回采方向/日进尺/回采位置更新日期**等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | 回采位置/回采位置对应时间戳/日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | 当前使用的通道的设备/编号/类型：0-微震采集，1-电法采集，2-电法发射，3-电磁采集，4-温度采集，5-电法B极，6-电法N极 |
| e_chns_config_history          | 从中读取通道历史信息参与历史计算                             |
|                                |                                                              |
|                                |                                                              |
| **偏移**                       |                                                              |
|                                |                                                              |
| e_data_digest                  |                                                              |
|                                |                                                              |
| **界面提取**                   |                                                              |
| e_tunnel_line_info             | 界面提取，保存从偏移图中提取的：起始点坐标，终止点坐标，与横轴夹角等信息。 |
| e_tunnel_error_info            | 保存对`e_tunnel_line_info`进行【聚类】算法后，得到的【地质异常】（即地质分层） |
|                                |                                                              |
|                                |                                                              |
|                                |                                                              |
| **预警**                       |                                                              |
| e_warningInfo_parm             | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts                  | 记录了所有的微震事件。用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value          | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info                 | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
|                                |                                                              |
| **随采**                       |                                                              |
| e_mining_surveyLines           |                                                              |
|                                |                                                              |

# 8. 登录

---

## （1）验证用户名密码

>  表`e_users`中存的`password`就只是`PASSWORD(password)`

```cpp
//commands.cpp
//body传plain/text，形如：【username=admin&password=Hzi12345!】
void login(const Rest::Request &request, Http::ResponseWriter response)
{}
    
//login中调用的verifyUser重载是下面的：用于分别验证用户名和密码。
//user和pswd都是传明文
bool verifyUser(string user, string pswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  auto ret = queryDb(conn, "SELECT * FROM e_users where user_name=? and password=PASSWORD(?)", user, pswd)
                 ? true : false;
  return ret;
}
```

```cpp
//接口
Routes::Post(RoutesManager::router, "/auth_user", Routes::bind(&cmd::authUser));

void authUser(const Rest::Request &request, Http::ResponseWriter response)
{
  Document bodyDoc;
  if (bodyDoc.Parse(request.body().c_str()).HasParseError())
  {
    response.send(Http::Code::Bad_Request, "用户认证格式错");
  }
  string userPswd = bodyDoc["user_pswd"].GetString();
  response.headers().add<Http::Header::ContentType>("text/plain");
  verifyUser(userPswd)
      .map([&](auto r)	{ response.send(Http::Code::Ok, "user_verified:ok"); })
      .map_error([&](auto err)	{ response.send(Http::Code::Unauthorized, "user_verified:failed"); });
}


//authUser调用的verifyUser重载是下面的：
//传入参数userPswd是：形如【user:password】这样的字符串，再base64编码后的字符串。
tl::expected<int, string> verifyUser(string userPswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  //SELECT FROM_BASE64(?)解码base64
  return queryDb(conn, "SELECT FROM_BASE64(?) as user", userPswd.c_str())
      .and_then([&](ResultSet userPsw) -> tl::expected<int, string>
                {
    				auto user = string(userPsw.getString("user"));
    				auto colonPos = user.find(":");
    				if (colonPos != string::npos) 
                    {
    				  auto userName = user.substr(0, colonPos);
    				  auto psw = user.substr(colonPos + 1);
                        //PASSWORD()为MySQL中自带函数，用于对密码进行单向加密，生成的加密字符串无法直接还原为原始密码，主要用于安全存储密码。
    				  return queryDb(conn,
    				                 "SELECT * FROM e_users where user_name=? and "
    				                 "password=PASSWORD(?)",
    				                 userName, psw)
    				      .and_then([&](auto r) { return tl::expected<int, string>(0); });
    				} 
                })
      .or_else([&](auto e) -> tl::expected<int, string>
               {
    			cout << "error:" << e << "\n";
    			return tl::make_unexpected(string("error verifying user:") + e); 
               });
}
```

## （2）修改密码

```cpp
//接口
Routes::Post(RoutesManager::router, "/password/:user/:pswd", Routes::bind(&cmd::changePswd));

void changePswd(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":user").as<string>();
  auto pswd = request.param(":pswd").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  try
  {
    conn.execute("UPDATE e_users set password=PASSWORD(?) where user_name=?",
                 pswd, userName);
    response.send(Http::Code::Ok, "ok");
  }
  catch (sql_exception &err)
  {
    response.send(Http::Code::Bad_Request, err.what());
  }
  // conn.close();
}
```

## （3）用户是否存在

```cpp
//接口
Routes::Get(RoutesManager::router, "/users/:name", Routes::bind(&cmd::userExists));

void userExists(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":name").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  queryDb(conn, "SELECT * from e_users where user_name=?", userName.c_str())
      .map([&](auto r)
           { response.send(Http::Code::Ok, "ok"); })
      .map_error([&](auto err)
                 {
      if (err.find("not found") != string::npos) {
        response.send(Http::Code::Not_Found, "not found");
      } else {
        response.send(Http::Code::Bad_Request, err);
      } });
  // conn.close();
}
```



# 9. 数据采集

---

## （1）原始帧

### 命令字（cmd_id）

| **命令功能** | **命令字** | **字节数****(Byte)** |
| ------------ | ---------- | -------------------- |
| 基站检测     | **0x01**   | 1                    |
| 时间校准     | **0x02**   | 1                    |
| 采集置参     | **0x03**   | 1                    |
| 启动监测     | **0x04**   | 1                    |
| 停止监测     | **0x05**   | 1                    |
| IP地址设置   | **0x06**   | 1                    |
| 连接检测     | **0x07**   | 1                    |
| 对时         | **8**      | 1                    |
| 对时         | **9**      | 1                    |

### 原始信号类型（class_id）

| **类型**       | **通信值**  | **定义**                             |
| -------------- | ----------- | ------------------------------------ |
| 自电数据       | 0x00        | 电法通道实时监测采集信号             |
| 激电数据       | 0x01        | 主动发射引起的激发电场采集信号       |
| 微震触发数据   | 0x02        | 微震通道阈值触发引起的微震采集信号   |
| 微震极值数据   | 0x03        | 微震通道一定时窗内的背景极大值       |
| 温度数据       | 0x04        | 温度通道实时采集的信号               |
| 震电磁耦合数据 | 0x05        | 微震通道耦合阈值引起的全通道采集信号 |
| 微震背景数据   | 0x06        | 微震通道环境背景实时采集信号         |
| 伽玛传感器数据 | 0x0b （11） | 伽马传感器实时采集数据               |

### 数据区

| **字节序号** | **大小（字节）** | **功能**                         | **参数说明**                                                 |
| ------------ | ---------------- | -------------------------------- | ------------------------------------------------------------ |
| D0~D7        | 8                | 采集时间                         | 采集时间8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00 UTC |
| D8           | 1                | 数据类型classId                  | **类型**            **属性**            **说明**                  0x00            自电数据            自然电位信号                  0x01            激电数据            发射电法采集信号                  0x02            微震触发数据            微震触发信号                  0x03            微震极值数据            微震时窗极值信号                  0x04            温度数据            实时温度信号                  0x05            震电磁耦合数据            震电磁‘耦合’信号                  0x06            背景数据            实时采集的背景信号 |
| D9           | 1                | 是否包含电流通道                 | 0x0：否 0x1:是                                               |
| D10~D11      | 2                | 包含通道数                       | 数据量包含数据通道数                                         |
| D12~D15      | 4                | 每通道包含点数                   | 每通道数据点数                                               |
| D16          | 1                | 发射帧序号                       | 电法发射帧序号                                               |
| D17~D18      | 2                | 信号触发通道号                   | 用于微震的信号触发时值最大的通道                             |
| D19          | 1                | 激电发射电压                     | **发射电压**            **说明**                  24V            参考通信值约定中的电压**类型**。                  48V                  72V                  96V |
| D20          | 1                | 该帧数据采集时刻激电是否正在采集 | 0x00:否 0x01:是                                              |
| D21          | 1                | 对时模块网络状态                 | 0x00:失联  0x01:正常                                         |
| D22~D29      | 8                | 对时模块时间信息                 | 8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00  UTC |
| D30          | 1                | 激励电法发射模式                 | 0x00:单正 0x01:正负正 0x02:M序列                             |
| D31          | 1                | 触发通道数                       |                                                              |

* 数据区：电流数据+电压数据
* 电流数据：4字节表示一个电流值，第一个字节最高位为符号位!  总点数为每通道包含点
* 电压数据：4字节表示一个电压值，第一个字节最高位为符号位! 总点数为电法发射采集模式：（包含通道数-1）*每通道包含点数；其余模式：包含通道数*每通道包含点
* 温度数据：2字节表示一个温度值



## （2）数据帧DataFrame（上位机中使用的）



### 数据类型（从什么原始信号构建的数据帧）

**可看库表`p_data_types`：**

![image-20250411173017037](D:\notes\笔记Img\image-20250411173017037.png)

| df.classId() | 数据类型                                  |
| ------------ | ----------------------------------------- |
| 1            | 激电                                      |
| 2            | 微震事件                                  |
| 3            | 微震背景（采样间隔2ms，每个通道2500点）   |
| 4            | 温度数据                                  |
| 5            | 耦合数据                                  |
| 6            | 微震全时（采样间隔0.5ms，每个通道5000点） |
|              |                                           |
| 9            | 提取                                      |
| 10           | 偏移                                      |
| 99           | 再提取                                    |

| 文件头     |            |                                           |          |                        |
| ---------- | ---------- | ----------------------------------------- | -------- | ---------------------- |
| 位置(字节) | 大小(字节) | 定义                                      | 数据类型 | 说明                   |
| 0          | 8          | 采样时间                                  | double   | 时间戳，毫秒           |
| 8          | 1          | 采样数据类型id                            | uint     | 按协议定义             |
| 9          | 1          | 是否包含电流通道                          | uint8_t  | 1:包含； 0:不包含      |
| 10         | 2          | 包含通道数                                | uint16_t | DataFrame::setChannels |
| 12         | 4          | 每通道数据点数                            | uint32_t | DataFrame::setPoints   |
| 16         | 1          | 激电发射帧序号或微震触发通道号            | uint8_t  |                        |
| 17         | 1          | 激电发射或微震触发基站ID号,主要用于多基站 | uint8_t  |                        |
| 18         | 1          | 保留                                      |          |                        |
| 19         | 4          | 采样间隔                                  | float    | 毫秒                   |
| 23         | 1          | 激电激发类型id                            | uint8_t  | 按协议定义             |
| 24         | 1          | 激电发射电压id                            | uint8_t  |                        |
| 25         | 1          | 该帧数据采集时刻激电是否正在采集          | uint8_t  | 0x00:否，0x01:是       |
| 26         | 1          | 设备拼接掩码                              | uint8_t  | 对应拼接设备ID         |
| 27         | 1          | 是否为拼接帧                              |          |                        |
| 28         | 1          | 激电电压模式                              | uint8_t  | 0:固定；1:智能         |
| 29         | 4          | 保留                                      |          |                        |

| 数据区     |                          |                                      |          |                                |
| ---------- | ------------------------ | ------------------------------------ | -------- | ------------------------------ |
| 位置(字节) | 大小(字节)               | 定义                                 | 数据类型 | 说明                           |
| 32         | 通道数x 每通道数据点数x4 | 原始采样数据值按通道、数据点顺序存放 | int      | 含电流通道时，第一道为电流数据 |

* 字节序：小字节序（高位在后，低位在前）
* 协议：指本公司《微震电法并行物理场监测系统采集通信约定》 
* 数据值： int类型的采样原始数据，未乘系数 
* 从系统页面下载数据文件名约定： yyyy_mm_dd_采集数据类型 id_采样时间戳.semt.bin 

# 10. 微震计算

---

> `ms_mining.cpp`

## （1）函数

| 函数名                                                       | 参数含义 | 函数功能说明                     |
| ------------------------------------------------------------ | -------- | -------------------------------- |
| `string handleSignalProcess(std::vector<DataFrame*> dfVec,bool flag,int dev_id)` |          | 对数据帧进行计算，保存到提取文件 |
|                                                              |          |                                  |

### handleSignalProcess

![call_graph_incoming](D:\notes\笔记Img\call_graph_incoming.svg)

![call_graph_outgoing](D:\notes\笔记Img\call_graph_outgoing.svg)

# 11.日志

---

![日志路径](D:\notes\笔记Img\日志路径.png)

# 12. 上传文件发送文件

---

## （1）文件指定格式上传/下载

> * 发送文件到前端，通过字节流：
>
>   ```cpp
>   //依赖库pistache
>   auto stream = response.stream(Http::Code::Ok);
>   while(ifs.gcount() > 0)
>   {
>       stream.write(bufTmpPtr, ifs.gcount());
>       stream << flush;
>       ifs.read(bufTmpPtr, fileSize);
>   }
>   ifs.close();
>   stream << ends;
>   ```
>
> * 发送文件到前端，通过`serveFile`
>
>   ```cpp
>   //函数原型
>   Http::serveFile(ResponseWriter& writer, const std::string& fileName,
>             const Mime::MediaType& contentType = Mime::MediaType());
>   ```
>
>   ```cpp
>   //依赖库pistache
>   Http::serveFile(res, fig, MIME(Application, Png));
>   ```

```cpp
/*
* 上传
*/ 

Routes::Post(RoutesManager::router, "/upload_doc/:mime/:name",
             Routes::bind(&cmd::uploadDocument));

void uploadDocument(const Rest::Request &request, Http::ResponseWriter response) 
{
    response.headers().add<Http::Header::ContentType>(MIME(Text, Plain));                          
    if(!request.hasParam(":name") || !request.hasParam(":mime"))
    {
        response.send(Http::Code::Bad_Request, "缺少参数");
        return;
    }
    string filename = request.param(":name").as<string>();
    string fileMime = request.param(":mime").as<string>();

    if (request.body().empty()) 
    {
        response.send(Http::Code::No_Content, "没有传入文件");
        return;
    }

    fs::path filePath("assets/images/");
    filePath /= filename;
    if (!fs::exists(filePath.parent_path())) 
    {
        response.send(Http::Code::Expectation_Failed, "Invalid path");
        return;
    }

    try 
    {
        //根据格式保存文件
        std::ofstream ofs;
        //图片
        if(fileMime == "png" || fileMime == "jpg" || fileMime == "jpeg" || fileMime == "gif" || fileMime == "bmp")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "pdf")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "xlsx")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "csv")
        {
            ofs.open(filePath);
        }

        if (!ofs.is_open())
        {
            response.send(Http::Code::Expectation_Failed, "failed to create: " + filename);
            return;
        }
        
        ofs.write(request.body().data(), request.body().size());
        ofs.close();
        response.send(Http::Code::Ok, filename + " uploaded!");
    } 
    catch (std::exception &e) 
    {
        logErr(e.what());
        response.send(Http::Code::Expectation_Failed, "Failed to upload: " + filename);
        return;
    }
}
```

```cpp
Routes::Get(RoutesManager::router, "/download_doc/:mime/:name", Routes::bind(&cmd::downloadDocument)); 

void downloadDocument(const Rest::Request &request, Http::ResponseWriter response)
{
    // response.headers().add<Http::Header::ContentType>(
    //   MIME3(Application, OctetStream, Zip));
    if(!request.hasParam(":name") || !request.hasParam(":mime"))
    {
        response.send(Http::Code::Bad_Request, "缺少参数");
        return;
    }

    string filename = request.param(":name").as<string>();
    string fileMime = request.param(":mime").as<string>();

    if (filename == "undefined") {
        response.send(Http::Code::No_Content, "没有指定pdf文件名");
        return;
    }

    fs::path filePath("assets/");//文件存储目录
    filePath /= filename;
    if (!fs::exists(filePath) || !fs::is_regular_file(filePath)) {
        cout << "file not exists: " << filePath.string() << endl;
        response.send(Http::Code::Expectation_Failed, "file not exists:" + filename);
        return;
    }

    try
    {
        std::ifstream ifs;
        if(fileMime== "png" || fileMime == "jpg" || fileMime == "jpeg" 
           || fileMime == "gif" || fileMime == "bmp" || fileMime == "pdf")
        {
            ifs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "csv" || fileMime == "xlsx")
        {
            ifs.open(filePath);
        }    

        if (!ifs.is_open())
        {
            cout << "failed to open file: " << filePath << endl;
            response.send(Http::Code::Expectation_Failed, "failed to open: " + filename);
            return;
        }  

        if(fileMime == "png")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Png));
        }
        else if(fileMime == "jpg")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
        }
        else if(fileMime == "jpeg")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
        }
        else if(fileMime == "gif")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Gif));
        }
        else if(fileMime == "bmp")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Bmp));
        }
        else if(fileMime == "pdf")
        {
            response.headers().add<Http::Header::ContentType>("application/pdf; charset=utf-8");
        }
        else if(fileMime == "csv")
        {
            response.headers().add<Http::Header::ContentType>("text/csv; charset=utf-8");
        }
        else if(fileMime == "xlsx")
        {
            response.headers().add<Http::Header::ContentType>("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet; charset=utf-8");
        }

        //保存到文件
        int64_t fileSize = fs::file_size(filePath);
        unique_ptr<char[]> bufTmp = make_unique<char[]>(fileSize);
        char* bufTmpPtr = static_cast<char*>(bufTmp.get());
        ifs.read(bufTmpPtr, fileSize);
        auto stream = response.stream(Http::Code::Ok);
        while(ifs.gcount() > 0)
        {
            stream.write(bufTmpPtr, ifs.gcount());
            stream << flush;
            ifs.read(bufTmpPtr, fileSize);
        }
        ifs.close();
        stream << ends;
    }
    catch(const std::exception& e)
    {
        cout << "failed to download:" << filename << endl;
        logErr(e.what());
        response.send(Http::Code::Expectation_Failed, "failed to download: " + filename);
        return;
    }
}
```

## （2）zip压缩/解压缩

> [!NOTE]
>
> 库：`libzip`
>
> 目录：`usr/include/zip.h`

### 压缩

* `zip_open`创建zip文件，返回`zip_t*`
* `zip_source_file`打开文件为一个source，返回`zip_source_t*`
* `zip_file_add`把source添加到zip实现把文件添加到zip，返回`zip_int64_t`。错误时返回-1，调用`zip_source_free(source)`释放source。
* `zip_close`关闭zip文件。

```cpp
/*
* 打包压缩文件
*/
#include <stdlib.h>
#include <zip.h>
struct fileNode 
{
    string fileName;//文件名
    fs::path filePath;//文件路径
};

//zipPath形如/tmp/hzisemt.zip
//isRandomSuffix=true表示加上随机后缀生成临时文件，此时zipPath中路径将被改为加上后缀后的路径
//isRandomSuffix=false表示直接使用传入路径作为zip路径

//这里是随机生成zip临时文件名为/tmp/hzisemt.zip.XXXXXX，然后下载该文件。
//若想指定下载的zip文件名，可去掉mkstemp64按照文件名模板自动生成随机文件名的代码，而使用从request中解析出的filename
tl::expected<bool, string> packZip(const vector<fileNode>& fileList, string* zipPath, bool addRandomSuffix)
{
    //入参判断
    if(fileList.size()==0 || zipPath==nullptr)	
        return tl::make_unexpected(string("入参非法"));
    
    bool failure = false;
    int filesAddZipCount = 0;	//成功添加到zip中的文件数
    string zipPathSuffix = ".XXXXXX";
    string zipPathTmpStr = *zipPath + zipPathSuffix;
    char* zipPath_;//最后使用的zip路径
    
    if(addRandomSuffix)
    {
        *zipPath = zipPathTmpStr;
        memset(zipPath_, zipPathTmpStr.c_str(), zipPathTmpStr.size());
        zipPath_ = zipPathTmpStr.c_str(); //char zipName[] = "/tmp/hzisemt.zip.XXXXXX";
        
        int fd = mkstemp64(zipPath_);//mkstemp64会根据替换zipName中的XXXXXX为随机数字并创建临时文件，返回该文件的描述符
        close(fd);	//调用方通过zip文件名访问，不通过fd读写
    }
    else
    {
        zipPath_ = zipPath->c_str();
    }
    
    //创建zip文件
    zip_t* z = zip_open(zipPath_, ZIP_CREATE | ZIP_TRUNCATE, nullptr);
    if (!z) 
    {
        // 获取系统错误信息
        char sys_errbuf[256];
        zip_error_t error;
        zip_error_init_with_code(&error, error_code);
        snprintf(sys_errbuf, sizeof(sys_errbuf), 
                 "无法创建zip文件: %s (系统错误码: %d)",
                 zip_error_strerror(&error), 
                 zip_error_system_type(&error));
        zip_error_fini(&error);
        
        return tl::make_unexpected(string("zip_open failed:") + string(sys_errbuf));
    }
    
    //遍历文件下载列表
    for (auto file : files) 
    {
        //打开文件为一个source(把source添加到zip中实现添加文件到zip)
        zip_source_t* source = zip_source_file(z, file.filePath.c_str(), 0, 0);
        if (!source) 
        {
            if (fs::exists(zipPath_))
            	remove(zipPath_);	//打包失败，把生成的zip删除
            return tl::make_unexpected(string("zip_source_file failed"));
        }
        
        //把source添加到zip中，并返回该文件在zip中的index 
        zip_int64_t index = zip_file_add(z, file.fileName.c_str(), source, ZIP_FL_ENC_RAW);
        if (-1 == index/* || -1 == zip_set_file_compression(z, index, ZIP_CM_STORE, 0)*/) 
        {
            zip_source_free(source);//index=-1，文件保存失败，释放source，跳出循环终止后续文件的添加
            if (fs::exists(zipPath_))
                remove(zipPath_);	
            
            // 直接获取当前zip实例的错误信息
            const zip_error_t* zerror = zip_get_error(z);
            std::string errmsg = "添加文件失败: " + 
                std::string(zip_error_strerror(zerror)) +
                " (系统错误码: " + 
                std::to_string(zip_error_system_type(zerror)) + ")";
            
            return tl::make_unexpected(string("zip_file_add failed:") + errmsg);
        } 
        ++filesAddZipCount;//成功添加文件数+1
    }
    
    if (zip_close(z) == -1) //文件添加完毕，关闭zip
    {
        if (fs::exists(zipPath_))
            remove(zipPath_);	
        
        // 获取关闭时的错误信息
        const zip_error_t* zerror = zip_get_error(z);
        std::string errmsg = "关闭zip文件失败: " + 
            std::string(zip_file_strerror(z));

        // 注意：zip_close失败后需要手动保留错误信息
        zip_discard(z); // 必须调用以避免内存泄漏
        return tl::make_unexpected(string("zip_close failed:") + errmsg);
    }

    if (filesAddZipCount == 0) //zip内没文件
    {
        if (fs::exists(zipPath_))
            remove(zipPath_);	
    	return tl::make_unexpected(string("zip为空！"));
    }
    
    return true;
}
```

### 解压缩

* 使用`zip_open`打开一个压缩文件，并使用`zip_get_num_entries`获取压缩文件中的条目数。

* 遍历每个条目，使用`zip_stat_index`获取条目的基本信息。

* 使用`zip_fopen_index`打开条目，使用`zip_fread`读取其中的数据，并将解压后的数据写入本地文件。

```cpp
/*
* 解压缩，返回文件名列表
*/
#include <zip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


vector<string>& unPackZip(string zipPath, string zipUnPackPath)
{
    int err = 0;
    struct zip* zipfile = zip_open(zipPath.c_str(), ZIP_CHECKCONS, &err);
    if (!zipfile) 
    {
        printf("zip open failed: %d\n", err);
        return 1;
    }

    zip_int64_t num_entries = zip_get_num_entries(zipfile, 0);
    for (zip_int64_t i = 0; i < num_entries; i++) 
    {
        struct zip_stat stat;
        zip_stat_index(zipfile, i, 0, &stat);
        printf("the file name is: %s\n", stat.name);

        struct zip_file *entry = zip_fopen_index(zipfile, i, 0);
        if (!entry) 
        {
            printf("fopen index failed\n");
            continue;
        }

        FILE *fp = fopen(stat.name, "w+");
        if (!fp) 
        {
            printf("create local file failed\n");
            zip_fclose(entry);
            continue;
        }

        char buf[1024];
        zip_int64_t len = 0;
        while (len < stat.size) 
        {
            int read = zip_fread(entry, buf, sizeof(buf));
            if (read < 0) {
                printf("read file failed\n");
                break;
            }
            fwrite(buf, 1, read, fp);
            len += read;
        }

        fclose(fp);
        zip_fclose(entry);
    }

    zip_close(zipfile);
    return 0;
}
```

## （3）文件列表打包zip下载

> 打包函数+文件下载接口

```cpp
/*
* 数据保存为bin/csv/qfx，打包zip并下载
*/
Routes::Get(RoutesManager::router,
              "/download/:from_time/:to_time/:is_csv/:file_name",
              Routes::bind(&ms_comm::downloadRawDateFile));


void downloadRawDateFile(const Rest::Request &request,
                         Http::ResponseWriter response) {
  uint64_t fromTime = request.param(":from_time").as<uint64_t>();
  uint64_t toTime = request.param(":to_time").as<uint64_t>();
  auto isCsvId = request.param(":is_csv").as<int>();
  int dev_id = 0;

  auto conn = hzi::config.pConnPool->getConnection();

  auto rslt0 = conn.executeQuery(
      "SELECT dataFreq,dataLen,class_Id  FROM `e_mining_PCOSignalParm`");
  if (rslt0.next()) {
    hzi::miningFreq = rslt0.getInt("dataFreq");
    hzi::miningDateLen = rslt0.getInt("dataLen");
    hzi::mining_classId = rslt0.getInt("class_Id");
  }
  debugLog(" downloadRawDateFile start mergeMs1");
  // mergeEngDenity(fromTime, toTime);

  // response.send(Http::Code::No_Content, "此时间段内无数据！");
  // return;

  mergeMs(fromTime, toTime,dev_id)
      .map([&](DataFrame df) {
        auto dftmp = std::move(df);
        auto chns = dftmp.channels();
        auto tmStmp = dftmp.sampTime();
        auto deltT = dftmp.sampIntvl();
        auto points = dftmp.points();
        auto pretime = 0;

        int32_t *p32 = (int32_t *)dftmp.upData.get();
        // 开始下载数据
        struct fileNode {
          float sampIntvl;
          string fileName;
          string frmLoc;
          string csvLoc;
        };

        std::vector<fileNode> files; // 下载文件列表
        fileNode file;
        //  file.frmLoc = path.string();
        // file.csvLoc = "/tmp" +
        // file.frmLoc.substr(file.frmLoc.find_last_of('/'));
        file.csvLoc = "/tmp/" + std::to_string(tmStmp);
        // + (isCsv ? ".csv" : ".bin");
        file.fileName = std::to_string(tmStmp);
        float tmpf;
        vector<vector<float>> v;
        v.resize(chns);
        for (int ch = 0; ch < chns; ++ch) {
          v.at(ch).resize(points);
          for (int pt = 0; pt < points; ++pt) {
            v.at(ch).at(pt) = p32[ch * points + pt] * 3000.0 / 8388607.0;
          }
        }
        if (isCsvId == 0) {
          try {
            file.csvLoc += ".bin";
            file.fileName += ".bin";
            std::ofstream ofs(file.csvLoc, std::ofstream::binary);
            ofs.write(dftmp.upHead.get(), 32);
            ofs.write((char *)dftmp.upData.get(), chns * points * 4);
            ofs.close();

          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败：" + file.csvLoc);
            return;
          }

        } else if (isCsvId == 1) {
          file.csvLoc += ".csv";
          file.fileName += ".csv";
          try {
            std::ofstream ofs(file.csvLoc);
            ofs << chns << ',' << points << ',' << deltT << ',' << (int)pretime
                << std::endl;

            for (int j = 0; j < points; ++j) {
              for (int k = 0; k < chns; ++k) {
                ofs << v.at(k).at(j) << ",";
              }
              ofs << std::endl;
            }
            ofs.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败：" + file.csvLoc);
            return;
          }
        } else if (isCsvId == 2) {
          file.csvLoc += ".qfx";
          file.fileName += ".qfx";
          STQfxFileHead fhQfx;
          STQfxTraceHead thQfx;
          fhQfx.nTraceCount = chns;
          fhQfx.nSamplePoints = points;
          fhQfx.fSampleInterval = deltT;
          fhQfx.nAdvanPoints = (int)pretime;
          if (fhQfx.nTraceCount < 1 || fhQfx.nSamplePoints < 1 ||
              fhQfx.fSampleInterval < 1e-9f) {
            response.send(Http::Code::Expectation_Failed,
                          "文本数据文件错误：" + file.csvLoc);
            return;
          }

          fhQfx.uchSurveyUnit = QFX_SSU_MV;
          std::ofstream ofsQfx(file.csvLoc);
          ofsQfx.write(reinterpret_cast<char *>(&fhQfx), sizeof(STQfxFileHead));

          thQfx.nSamplePoints = fhQfx.nSamplePoints;
          thQfx.fSampleInterva = fhQfx.fSampleInterval;

          try {
            for (int k = 0; k < chns; ++k) {
              thQfx.uchTraceType = 1;
              thQfx.nTraceNum = thQfx.nOrgTraceNum = k + 1;
              ofsQfx.write(reinterpret_cast<char *>(&thQfx),
                           sizeof(STQfxTraceHead));
              for (int j = 0; j < points; ++j) {
                ofsQfx.write((char *)&v[k][j], sizeof(float));
              }
            }
            ofsQfx.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败 2：" + file.csvLoc);
            return;
          }
        }
        files.push_back(file);

#pragma region 生成压缩文件
        bool failure = false;
        char fileName[] = "/tmp/hzisemt.zip.XXXXXX";
        int fd = mkstemp64(fileName), filesCnt = 0;//返回的fd没用到，后面用文件名读写的文件
        if (files.size() > 0) 
        {
          zip_t *z = zip_open(fileName, ZIP_CREATE | ZIP_TRUNCATE, nullptr);
          if (z) {
            for (auto file : files) {
              zip_source_t *source =
                  zip_source_file(z, file.csvLoc.c_str(), 0, 0);
              if (source) {
                zip_int64_t index = zip_file_add(z, file.fileName.c_str(),
                                                 source, ZIP_FL_ENC_RAW);
                if (-1 == index/* || -1 == zip_set_file_compression(z, index, ZIP_CM_STORE, 0)*/) {
                  failure = true;
                  zip_source_free(source);
                  break;
                } else {
                  ++filesCnt;
                }
              }
            }
            int ret = zip_close(z);
            if (-1 == ret) {
              failure = true;
            }
          }
        }
        if (failure) {
          if (fs::exists(fileName)) {
            remove(fileName);
          }
          response.headers().add<Http::Header::ContentType>(
              "text/plain; charset='utf-8'");
          response.send(Http::Code::Expectation_Failed,
                        "无法生成 zip 压缩文件！");
          return;
        }
        if (0 == filesCnt) {
          response.headers().add<Http::Header::ContentType>(
              "text/plain; charset='utf-8'");
          response.send(Http::Code::No_Content, "此时间段内无数据！");
          return;
        }
#pragma endregion
        response.headers().add<Http::Header::ContentType>(
            MIME3(Application, OctetStream, Zip));
        constexpr int MAX_BUFFER_SIZE = 512;
        char streamBuffer[MAX_BUFFER_SIZE] = {};
        auto stream = response.stream(Http::Code::Ok);
        
        std::ifstream ifs(fileName);//通过文件名读文件
        
       	ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        while (ifs.gcount() > 0) {
          stream.write(streamBuffer, ifs.gcount());
          stream << flush;
          ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        }
        ifs.close();
        stream << ends;
        close(fd);
      })
      .map_error([&](auto err) {
        if (hzi::config.verbose) {
          std::stringstream ss;
          logErr(ss.str());
        }
        response.headers().add<Http::Header::ContentType>(
            "text/plain; charset='utf-8'");
        response.send(Http::Code::Expectation_Failed, "NO data");
        return;
      });
}
```

## 



# 13. 时间戳

---

## （1）unix毫秒时间戳和`YYYY-MM-DD HH:MM:SS.mmm`字符串互转

```cpp
// unix毫秒时间戳（单位ms）转YYYY-MM-DD HH:MM:SS.mmm字符串
std::string timestampToString(int64_t timestamp_ms) 
{
  // Convert milliseconds to seconds and remainder milliseconds
  std::time_t seconds = timestamp_ms / 1000;
  int milliseconds = timestamp_ms % 1000;

  //使用std::localtime函数将seconds（以秒为单位的时间）转换为本地时间，结果存储在tm结构体中
  std::tm *tm = std::localtime(&seconds);

  //存储格式化后的时间字符串（不包括毫秒部分）。大小为24，足以存储"YYYY-MM-DD HH:MM:SS"格式的字符串
  //将tm结构中的时间信息格式化为"YYYY-MM-DD HH:MM:SS"格式的字符串，并存储在buffer中
  char buffer[24];
  std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm);

  //将buffer中的字符串和毫秒部分拼接起来
  //std::setfill('0')设置填充字符为'0'，std::setw(3)设置字段宽度为3，确保毫秒部分总是三位数字，不足时前面补零。
  std::ostringstream oss;
  oss << buffer << '.' << std::setfill('0') << std::setw(3) << milliseconds;

  return oss.str();
}
```

```cpp
// Function to convert a formatted date-time string back to a timestamp in
// milliseconds
int64_t stringToTimestamp(const std::string &datetime_str) 
{
  std::tm tm = {};
  int milliseconds = 0;

  // Manually parse the string "YYYY-MM-DD HH:MM:SS.mmm"
  if (sscanf(datetime_str.c_str(), "%4d-%2d-%2d %2d:%2d:%2d.%3d", &tm.tm_year,
             &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec,
             &milliseconds) != 7) 
  {
    throw std::runtime_error("Failed to parse date-time string");
  }

  // Adjust fields for tm structure
  tm.tm_year -= 1900; // tm_year is years since 1900
  tm.tm_mon -= 1;     // tm_mon is 0-based (0 = January)

  // Convert to time_t (seconds since epoch) and add milliseconds
  std::time_t seconds = std::mktime(&tm);
  if (seconds == -1) 
  {
    throw std::runtime_error("Failed to convert to time_t");
  }

  return static_cast<int64_t>(seconds) * 1000 + milliseconds;
}
```

## （2）将yyyy-MM-dd hh:mm:ss字符串转成yyyyMMddhhmmss字符串

```cpp
std::string convertDateFormat(const std::string& date_str) 
{
    if (date_str.empty()) {
        throw std::invalid_argument("Input date string is empty");
    }

    // 检查输入长度是否符合 "YYYY-MM-DD HH:MM:SS"
    if (date_str.size() != 19) {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 提取并验证格式
    std::string year = date_str.substr(0, 4);
    std::string month = date_str.substr(5, 2);
    std::string day = date_str.substr(8, 2);
    std::string hour = date_str.substr(11, 2);
    std::string minute = date_str.substr(14, 2);
    std::string second = date_str.substr(17, 2);

    // 确保字符的位置符合标准格式
    if (date_str[4] != '-' || date_str[7] != '-' || date_str[10] != ' ' || 
        date_str[13] != ':' || date_str[16] != ':') {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 合并为目标格式
    std::string result = year + month + day + hour + minute + second;
    return result;
}
```



## （3）给定UTC获得北京时间（东八区时间）年/月/日

```cpp
fs::path relLocFromTime(uint64_t timestamp) 
{
  int64_t milli = timestamp + (int64_t)8 * 60 * 60 * 1000; // UTC时间加8h转localtime
  auto mTime = std::chrono::milliseconds(milli);
  auto tp = std::chrono::time_point<std::chrono::system_clock,
                                    std::chrono::milliseconds>(mTime);
  auto tt = std::chrono::system_clock::to_time_t(tp);
  std::tm *date = std::gmtime(&tt);
  //date->tm_year + 1900获取年，date->tm_mon + 1获取月，date->tm_mday获取日
  //构建一个年/月/日文件路径
  return fs::path(to_string(date->tm_year + 1900)) /
         to_string(date->tm_mon + 1) / to_string(date->tm_mday);
}
```



# 14. 字符串处理

---

## （1）字符分割

```cpp
//deli作为分割，从origStr中分割出子字符，保存到vals中
void splitStr(const string &origStr, char deli, std::vector<string> &vals) {
    string str = origStr;

    while (!str.empty()) {
        auto pos = str.find_first_of(deli);
        if (pos == string::npos) {
            // 如果找不到分隔符，将剩余字符串作为最后一个部分
            vals.push_back(str);
            break;
        } else {
            // 提取当前部分并更新剩余字符串
            vals.push_back(str.substr(0, pos));
            str = str.substr(pos + 1); // 更新剩余字符串
        }
    }
}
```

# 15. 数学计算

---

## （1）整数幂计算

```cpp
//base^power
int safePow(int base, unsigned int power) 
{
  if (power == 0) 
  {
    return 1;
  }
  int p = 1;
  for (int i = 0; i < power; i++) 
  {
    p *= base;
  }
  return p;
}
```

## （2）双精度数值格式化为保留两位小数的字符串

```cpp
// 格式化函数：将双精度数值格式化为保留两位小数的字符串
std::string formatDouble(double value, int fmat) {
  std::ostringstream oss;
  oss << std::fixed << std::setprecision(fmat) << value;
  std::string str = oss.str();

  // If the number is an integer, remove the decimal part
  if (std::fabs(value - static_cast<int>(value)) < 1e-9) {
    str.erase(str.find('.'));
  } else {
    // Remove trailing zeros
    str.erase(str.find_last_not_of('0') + 1, std::string::npos);
    // If there is a dangling decimal point, remove it
    if (str.back() == '.') {
      str.pop_back();
    }
  }

  return str;
}
```

## （3）计算字节形式存储的整数的均值

```cpp
double avg(const char *p, int from, int to) {
  int64_t sum = 0;
  for (int i = from; i < to; i++) {
    sum += *(int32_t *)(p + i * 4);
  }
  return sum / (to - from);
}
```

## （4）fabsf

> `fabsf` 是一个 C 标准库中的数学函数，用于计算单精度浮点数的绝对值。
>
> ```cpp
> float fabsf(float x);
> ```
>
> 

# 16.异常

---

## （1）使用tl::expected库处理异常

>  expected，替代bool或返回码。
>
> 好处：简便的将异常的详细信息返回到调用处使用。可链式调用。

```cpp
static tl::expected<Document, string> jsonDocFromFile(string const &file) {
    FILE *fp = fopen(file.c_str(), "r");
    if (!fp)
      return tl::make_unexpected("failed opening file: " + file);

    char readBuf[1024];
    FileReadStream frs(fp, readBuf, sizeof(readBuf));
    Document doc;

    if (doc.ParseStream<kParseCommentsFlag>(frs).HasParseError()) {
      return tl::make_unexpected("jsonDocFromFile: invalid json file:" + file);
    }
    return std::move(doc);
  }
```

* 比较and_then与or_else，map与map_erro的区别

```cpp
//and_then和or_else 
return jsonDocFromFile(jsonConf).and_then([&](Document doc) -> tl::expected<Config, string> 
     	{
            ...
        })
     	.or_else([&](string unexpect) -> tl::expected<Config, string>
    	{
            ...
        });
```

```cpp
//map和map_error

```

## （2）throw抛异常

throw抛异常后，代码将终止，不会执行throw之后的语句。

throw一般用于抛异常到上层代码，让其捕获处理。

但目前来说，写代码，最好那里发生哪里捕获哪里处理，不要往上层抛。

## （3）多个catch

多个catch，前面的catch捕获异常后，后面的catch不会再捕获异常并处理。
