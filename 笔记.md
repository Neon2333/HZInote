

# 0. bug总结

## （1）偏移图不显示

* 配置文件`ms_mining_type`没有或为0，导致接口`/ms_mining`返回false，从而不渲染偏移图。
* `PCOLocParm`的`mark_xLen`字段控制偏移图横轴范围，页面【实施参数-前方监测距离】修改。

## （2）波形图不显示

* 配置文件`ms_miningSignal`要设为true
* 



# 1. 系统概述与业务

---

> [!NOTE]
>
> 硬件：主要分为三个部分，即传感器，[数据采集器](https://baike.baidu.com/item/数据采集器/5133325?fromModule=lemma_inlink)、时间同步、数据通信、服务器等部分。
>
> 传感器将地层运动（地层速度或加速度）转换成一个可衡量的电信号。非地震传感器也可以用于微地震网络的案例。
>
> **数据采集器负责将来自传感器的[模拟电信号](https://baike.baidu.com/item/模拟电信号/15567035?fromModule=lemma_inlink)转换成数字信号。**数据可以连续记录，或采用触发模式，通过触发算法来确定是否记录传输微震事件数据。
>
> 微震数据同时传输到一个中央计算机或本地磁盘进行储存或处理。微震系统可以采用多种数据通讯手段，以适应不同的系统环境需要。
>
> 微震系统的软件：由系统配置管理软件，微震波形数据处理软件，,微震事件的可视化及解释软件，微震事件实时显示软件等组成。

* 传感器：基站上有根线，线的远端是1号，近端是16号。1号靠近迎头。每个传感器线上固定间距5m。

* 采集器：将传感器模拟电信号采样为离散的数字电信号。

* 当前掘进里程（掘进位置）：迎头的位置（每天更新）

* 【系统-工程参数-工作面名称/工作面长度和宽度】工作面：大巷侧面是煤层，从大巷侧面垂直开的巷道叫工作面，进风面/出风面以及最后横向挖通构成一个U字形，中间很薄的一层是煤层。可能高度600米只有3米的煤层，其他是岩层。

* 掘进是什么？目的是什么？：主要判断前面有没有构造：水/断层之类的，提前知道，有相应方法处理。

* 【系统-工程参数-空间参数】将煤底层位置设为（0，0，0）

* 【系统-工程参数-通道配置】**S1表示基站，GR01表示第一个传感器**。（问题：矿上把传感器位置放反了，把线的近端放在了靠近迎头。代码里逻辑可能后面要修改。）

* 【采集置参】：关注**采样间隔**

* 【数据存储策略】：为了节省内存，设定不存储指定的数据。

* 【系统-随掘监测-数据提取】：【1-最小比例~1+最大比例】作为比例，乘以【平均能量时窗】内数据（背景数据）的均值。用【时窗】内数据（背景数据）进行比较，判断是否在掘进。（用背景数据进行判断。全时数据数据量太大）

  判断是否正在掘进过程：通过1h内数据，计算平均值，平均值乘以比例作为基准。后面时窗即以2min为单位计算平均值，若在范围内，则判断这个时窗内为正在掘进。

* 【系统-随掘监测-实时参数】：用全时数据，根据设定参数自动进行提取处理。（随掘地震那里的设定，是为了修改参数值，通过偏移图看效果，找到最适合的参数，填入实施参数的设定参数进行自动提取。）

  监测前方距离：超前探测距离。

  拼接数据类型：一般是微震全时，即在全时数据的基础上进行提取，得到提取图。

![image-20250606092913411](D:\notes\笔记Img\image-20250606092913411.png)

# 2. 随掘地震概述

---

【目的】：监测掘煤前方的地质结构，提前预知水/岩石/煤的存在，做好措施。

【软件系统】：通道采集原始信号，经过干涉源提取生成提取数据和【图提取】。再经过滤波/振幅均衡/反褶积/反射波提取/偏移，得到偏移数据和【偏移图】。最后，通过【界面提取】，从偏移图中提取界面的坐标点和与横轴夹角。最后通过【聚类】算法，对提取的界面进行处理，找出真正的地质异常（也就是分层面），绘制在【首页的巷道探测示意图】。

波在介质中传播，当介质的密度突然发生改变时会发生反射。使用传感器接收反射波，通过系统处理，发现不同介质的分层。随掘系统，波的震源是掘锚机，通道（传感器）打在两侧的墙壁上。掘锚机的波向后首先到达传感器，这个波叫做直达波，在提取图上表现为最左侧的一些波，提取前需要去掉；而且因为通道号越大距离掘锚机越远，直达波到达的越晚，所以各个通道的直达波波形是从左上角向右下角。向前的波经过地质遇到分层会反射回来，再次被传感器收到，这个波是我们需要的。

# 3. 测试环境搭建

---

### 数据路径

数据放入：`var/kwang/frame_data/2025/4/5`

3-背景原始数据

6-全时原始数据

9-提取数据

10-偏移数据

99-再提取数据

### 库表设置

* `var/kwang/frame_data/2025/4/5/6`和`var/kwang/frame_data/2025/4/5/3`下文件的名称需和表`e_data_frm_info`记录保持一致。
* `var/kwang/frame_data/2025/4/5/9`下文件名称要和表`e_mining_signaldata_frm_info`保持一致
* `var/kwang/frame_data/2025/4/5/10`下文件名称要和表`e_mining_pcodata_frm_info`保持一致
* `e_chn_types`
* `e_chns_config`
* `e_chns_config_history`
* `e_chns_config_tunnel`
* `e_mining_PCOLocParm`
* `e_mining_PCOSignalParm`
* `e_mining_PCOSignalParm_history`
* `e_tunnel_extractPara`

```cpp
./aaa会在终端显示实时日志
nohup ./aaa &就是在后台启动，日志就在nohup.out
```

## 测试环境

* 配置文件使用：

  目录下已挂载2025年3/5/6/7月份历史数据，MySQL使用的是地下坑道随掘系统的数据库。

  ```cpp
   //地下坑道随掘
      "mysql_url": "mysql://192.168.74.118:3309/semtdb1?user=hzidba&password=dzaqZHk3",//地下坑道随掘数据库
      "data_root": "/home/kwang/workspace/kengdao_tunnel"//地下坑道随掘数据路径
  ```

* 使用自己本地的https链接登录即可使用地下坑道随掘历史数据和数据库进行测试



# 4. 微震参数含义

---

### 干涉提取

* 塑形：选取若干点数，在波形边缘进行，防止吉布斯效应。

* 因子道：所有道和该道进行互相关。

* 互相关：互相关函数，在频率进行。某道和因子道，取某道所有点和因子道第一个点相乘，得到所有点结果相加，再除以点数。得到和因子道第一个点的互相关结果。再和因子道第二个点……以此类推，得到某道所有点的互相关结果。

  因子道和自身自相关。

* 因子时长：`转成ms，除以采样间隔`得到`pcoParm.coeLen`。

### 滤波

> * 作用：消除50HZ的信号干扰
>
> * 原理：
>
> 

### 偏移

传感器发送信号，一来一回，时间乘以速度（速度参数里设定的：P波，S波，导波：P波算的某个网格幅值+S波算的某个网格幅值），再除以2进行画圆，若网格在圆内部，则取这个点的幅值作为这个网格的值。综合起来就是16个通道的所有**幅值的绝对值**（因为幅值有正负）相加，得到某个网格的幅值。即偏移图，通过颜色表示幅值。

折线图，偏移图Y=0那条线上的幅值。

### 叠加信号偏移

再偏移。手动取时间段，将时间段内所有的的偏移图结果（2min），相加再除（取均值）。

# 5. 配置文件

---

```json
//sys_config.kwang.json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],

    "serve_for": "tunnel_1",
    "ms_tunnel_listen":false,
    "http_port": 11507,
    "realtime_interval": 5,
    
    "link_device": false,
    
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": true, 
    "ms_mining_type": 2,
    "ms_miningSignal": true,
    "save_full_msdata": false,
    "ms_trigger":true,
    "ms_tunnel": true,
    "warningType": 1,
    "ms_interface_type": 1,
    "digest_duration": 5,
    "optical_strain": false,
    
    // "warningTimeSync":true,//hzi::config.warningTimeSync，是否启用预警（实际有效的）
    // "warningTimeSyncIntval":5,//预警发送消息间隔（查表间隔），单位：min
    // "is_used_warning":false,//is_Used_warning接口返回值的是否使用预警（代码里实际没用它作为判断）
    // "msg_receivers":"WangKun",
    // "alarm_receivers":"GuoJinShuai",
    // "leader_receivers":"GuoJinShuai",
    
    //开发环境
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",//本地服务器数据库
    "data_root": "/var/kwang/frame_data"//本地服务器数据路径

    //园区环境
    // "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",//园区（测试）数据库
    // "data_root": "/var/yuanqu"//园区历史路径（实时：/var/frame_data）
    

    //地下坑道随掘
    // "mysql_url": "mysql://192.168.74.118:3309/semtdb1?user=hzidba&password=dzaqZHk3",//地下坑道随掘数据库
    // "data_root": "/home/kwang/workspace/kengdao_tunnel"//地下坑道随掘数据路径


    //建庄
    // "mysql_url": "mysql://192.168.74.37:3307/semtdb1?user=hzidba&password=dzaqZHk3",
    // "data_root": "/var/kwang/frame_data"
}
```

```json
{
    "devices": 
    [
        {
            "id": 1,
            "device_ip": "192.168.70.134",
            "device_port": 5086,
            "server_port": 5086
        }
    ],
    //"semt"微震系统
	//"semt_carousel"轮播图微震系统
	//"tunnel"长沙铁建
	//"tunnel_1"随掘
	//"mining"随采
    "serve_for": "semt",
    "http_port": 11507,//访问时页面端口，config.httpPort
    "realtime_interval": 1,
    
    "link_device": true,//hzi::config.linkDevice，是否有设备连接（true时才会开启原始帧采集线程，false时中继relayConfig）
    //"sampler_ip":"",//中继时，上位采集主机的ip
    //"relay_port":"",//中继时，上位采集主机用于连接当前主机的port
    
    "time_sync": false,//hzi::config.timeSync，同步所有基站
    "timesync_interval": 10,//hzi::config.timeSyncIntval，每次同步所间隔的时间（单位：s）
    
 	"warningTimeSync":true,//是否启用预警（实际有效的）
    "warningTimeSyncIntval":2,//预警发送消息间隔（查表间隔），单位：min
    "tunnel_server":"192.168.72.110",
    "tunnel_port":3002,
    "warningType":0,  // warningType 异常预警计算类型（约定 1：铁建移动检波器时异常聚类  2：根据时间进行聚类提取 3：样本数量 4：提取次数）
    
    "ms_experimental": false,
    "multi_chn_trig": false,//是否设置微震事件多通道触发（多通道触发, 耗时太长，缓用）
    "ms_grid_step": 0.1,
   
    "ms_mining_type":0,    //hzi::config.ms_mining_type，随采类型：0-无随采，1-随采，2-随掘
    "ms_tunnel_listen":false,    // //hzi::config.ms_tunnel_listen，铁建项目，是否有tcp通讯
    
    "ms_interface_type":0, //采集页面维度类型 0-XY 1-XZ 2-XYZ 
  
    "ms_components":1,     //微震通道分量设置，默认单分量
    "ms_rate": 0.8,
    "ms_mining":true,//是否随采
    "ms_miningSignal":true,
    "ms_locating":true,
    "ms_tunnel":true,
    "save_full_msdata":true,//是否保存全时微震数据帧（入库+写文件）
    "ms_trigger":true,//是否保存微震事件
    "is_used_warning":true,//is_Used_warning接口返回值的是否使用预警（代码里实际没用它作为判断）

    "upWSData":true,//hzi::config.upWSData 
    "ftpUrl":"ftp://192.168.74.232:21/shfz/411081005643/WZ/",
    "ftpUserName":"ftpUser",
    "ftpPassWord":"testFTP123456",
    
    "enable_http":true,//hzi::config.enable_http
    
    "digest_duration": 10,
    "optical_strain":true,

    //"data_root": "/home/kwang/workspace/yuanqu",
    "project_name":"库尔勒金川煤矿",
    "msg_receivers":"WangKun",//预警运维组
    "alarm_receivers":"WangKun",//预警用户
    "leader_receivers":"GuoJinShuai",
    "probe_to":{
        "min_x":50,
        "max_x":50,
        "min_y":50,
        "max_y":50,
        "min_z":50,
        "max_z":10
    },
    
    
    //开发环境
    //"mysql_url": "mysql://218.23.107.89:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",//本地服务器数据库
    "data_root": "/var/kwang/frame_data"//本地服务器数据路径

    //园区环境
    // "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",//园区（测试）数据库
    // "data_root": "/var/yuanqu"//园区历史路径（实时：/var/frame_data）
    

    //地下坑道随掘
    // "mysql_url": "mysql://192.168.74.118:3309/semtdb1?user=hzidba&password=dzaqZHk3",//地下坑道随掘数据库
    // "data_root": "/home/kwang/workspace/kengdao_tunnel"//地下坑道随掘数据路径


    //建庄
    // "mysql_url": "mysql://192.168.74.37:3307/semtdb1?user=hzidba&password=dzaqZHk3",
    // "data_root": "/var/kwang/frame_data"
}
```



# ====================代码结构======================

# 6. 系统启动初始化

---

## （0）main入口

```cpp
//main.cpp
#include "Config.hpp"
#include "merge_frame.hpp"
#include "receiver.hpp"
#include "sender.hpp"
#include "socket.hpp"
#include "time_sync.hpp"
#include "tl/expected.hpp"
#include "web/commands.hpp"
#include "web/sse.hpp"
#include "kafka_producer.hpp"

#include "ConnectServer.hpp"
// #include "python/python.hpp"

#include "zdbpp.h"
#include <array>
#include <cstdio>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <pthread.h>
#include <stdexcept>
#include <string>
#include <thread>

#include "common.hpp"
#include "socket.hpp"
#include "web/http_server.hpp"

using std::cout;
using std::endl;
using namespace zdb;
using namespace sock;

namespace
{
    std::unordered_map<int, std::unique_ptr<char[]>> recvData;
    std::unordered_map<int, char *> pRecvData;
    //通过继承 std::thread 来创建一个自定义线程类 MyThread，并提供一个静态方法 setScheduling 来设置线程的调度策略和优先级
    //直接继承标准库中的类并不是一个好的实践。更好的方式是使用组合（Composition）而不是继承
    class MyThread : public std::thread
    {
        public:
        MyThread() {}
        static void setScheduling(std::thread &th, int policy, int priority)
        {
            sch_params.sched_priority = priority;
            //pthread_setschedparam 是 POSIX 线程库中的函数，用于设置线程的调度策略和优先级
            //native_handle() 方法来获取底层线程句柄
            if (pthread_setschedparam(th.native_handle(), policy, &sch_params))
            {
                std::cerr << "Failed to set Thread scheduling : " << std::strerror(errno)
                    << std::endl;
            }
        }
        static inline sched_param sch_params;
    };
}

#define CONSTCMDNUMBER 4
static inline std::map<const char *, const char *> helpMap = {
    {"-c", "        系统配置文件"},
    {"-l", "        取消实时微震定位计算，默认开启"},
    {"-a", "        取消实时视电阻率计算，默认开启"},
    {"-v", "        详细输出开关,默认关闭"},
    {"note:", "     指令任意可组合使用(-alc)，也可以分开使用(-a -c -l)  "
              "如需配置文件，文件名称放到最后 "}};
// 退出函数
inline void usage(int exit_value = 0)
{
  for (auto &helpdex : helpMap)
  {
    cout << helpdex.first << "  " << helpdex.second << endl;
  }
  exit(exit_value);
}

int main(int argc, const char *argv[])
{
  // const char*
  // pcmd[CONSTCMDNUMBER]={"etc/sys_config.json","verbose","Mslocating","AppResis"};
  std::shared_ptr<const char *[]> pcmd(new const char *[CONSTCMDNUMBER]
                                       {
                                         "etc/sys_config.json", "verbose", "Mslocating", "AppResis"
                                       });
  const char *fileName = pcmd[0];
  // const char*fileName;

  // auto pyExp = initPyInterpreter();
  // if (!pyExp) {
  //     cout << pyExp.error();
  //     exit(1);
  // } else {
  //     cout << "python interpreter initialized\n";
  // }
  bool b_IsContainsConfig = false;
  if (argc > 1)
  {
    for (int j = 1; j < argc; j++)
    {
      const char *pchar = argv[j];
      switch (pchar[0])
      { // 确定选项类型：-h,-d,-v,-l,-o;或者其他
      case '-':
      {
        for (int i = 1; i < (int)(strlen(pchar)); i++)
        {
          switch (pchar[i])
          {
            // 确定用户指定的选项：h,d,v,l,o
          case 'l': // 处理调试：
            pcmd[2] = "--disableMslocating";
            break;
          case 'v': // 处理调试：
            pcmd[1] = "--verbose";
            break;
          case 'c': // 处理调试：
            b_IsContainsConfig = true;
            break;
          case 'a': // 处理版本请求
            pcmd[3] = "--disableAppResis";
            break;

          default: // 无法识别的选项
            cout << "hzi:error:unrecognition option -:" << pchar << endl;
            usage(-1);
          }
        }

        break;
      }
      default: // 不以'-'开头，是文件名

        if (b_IsContainsConfig && strstr(string(pchar).c_str(), ".json"))
        {
          fileName = pchar;
          pcmd[0] = std::move(fileName);
          break;
        }
        else
        {
          cout << "不以'-'开头 file name:" << pchar << endl;
          usage(0);
          break;
        }
      }
    }
  }

  (argc > 1 ? hzi::init(CONSTCMDNUMBER, pcmd)
            : hzi::init("etc/sys_config.json"))
      .map([](auto r)
           {
        if (hzi::config.linkDevice) {
          if (hzi::config.verbose) {
            cout << "startReceiver thread setup\n";
          }
          std::thread receiver(startReceiver);
          receiver.detach();
        }
        if (hzi::config.timeSync) {
          if (hzi::config.verbose) {
            cout << "syncAllDevices thread setup\n";
          }
          std::thread timeSync(syncAllDevices);
          timeSync.detach();
        }
        if (hzi::config.warningTimeSync) {
          if (hzi::config.verbose) {
            cout << "syncWarningInfo thread setup\n";
          }
          std::thread timeSync(syncWarningInfo);
          timeSync.detach();
        }
        if (1) {
          if (hzi::config.verbose) {
            cout << "syncWarningLeader thread setup\n";
          }
          std::thread timeSync(syncWarningLeader);
          timeSync.detach();
        }
        
        if (hzi::config.ms_mining_type == 2 &&
            (!hzi::config.ms_tunnel_listen)) {
          if (hzi::config.verbose) {
            cout << "realTimeCal thread setup\n";
          }
          std::thread realtimeCal(realTimeCal);
          realtimeCal.detach();
        }
        if (hzi::config.ms_mining_type == 2 && hzi::config.ms_tunnel_listen) {
          if (hzi::config.verbose) {
            cout << "startConnect thread setup\n";
          }
          std::thread ConnectServer(startConnect);
          ConnectServer.detach();
        }
        if (hzi::config.upWSData) {
          if (hzi::config.verbose) {
            cout << "syncUpWSdata thread setup\n";
          }
          std::thread timeSync(syncUpWSdata);
          timeSync.detach();
        }

        if (true) 
        {
          // 初始化 Kafka 生产者
          if (!hzi::config.kafkaBrokers.empty() && !hzi::config.kafkaTopicMicroseismic.empty())
          {
            try
            {
              KafkaProducer::kafkaProducer = std::make_unique<KafkaProducer>(hzi::config.kafkaBrokers);
              std::cout << "Kafka producer initialized for microseismic data" << std::endl;

              if (hzi::config.verbose) 
              {
                cout << "msevtsSync thread start\n";
              }
              std::thread msevtsSync(syncMsevtsKafka);
              msevtsSync.detach();
            }
            catch (const std::exception &e)
            {
              std::cerr << "Failed to initialize Kafka producer: " << e.what() << std::endl;
              KafkaProducer::kafkaProducer = nullptr;
            }
          }
          else
          {
            std::cout << "Kafka not configured for microseismic, skipping" << std::endl;
          }
        }

        if (hzi::config.verbose) {
          cout << "hzi::init over\n";
        }
        if (hzi::config.enable_http) {
          cout << "http enabled\n";
          std::thread(start_http_server).join();
        } else {
          cout << "http disabled\n";
          // 仅采集时启动中继置参服务
          std::thread(sse::startConfRelayer).detach();
          std::thread(sse::startSSERelayer).join();
        }
        return 0; })
      .map_error([](auto err)
                 {
        std::cerr << "系统出错：" << err;
        return 1; });
}
```

## （1）程序启动参数

```cpp
#define CONSTCMDNUMBER 4
static inline std::map<const char *, const char *> helpMap = {
    {"-c", "        系统配置文件"},
    {"-l", "        取消实时微震定位计算，默认开启"},
    {"-a", "        取消实时视电阻率计算，默认开启"},
    {"-v", "        详细输出开关,默认关闭"},
    {"note:", "     指令任意可组合使用(-alc)，也可以分开使用(-a -c -l)  "
        "如需配置文件，文件名称放到最后 "}};
// 退出函数
inline void usage(int exit_value = 0)
{
    for (auto &helpdex : helpMap)
    {
        cout << helpdex.first << "  " << helpdex.second << endl;
    }
    exit(exit_value);
}

int main(int argc, const char *argv[])
{
    //程序执行参数：配置文件，3个命令参数
    //后续代码使用pcmd
    std::shared_ptr<const char *[]> pcmd(new const char *[CONSTCMDNUMBER]
                                         {
                                             "etc/sys_config.json", "verbose", "Mslocating", "AppResis"
                                         });
    /*
    * 对pcmd中存的配置文件名和3个命令参数进行操作
    */
    const char *fileName = pcmd[0];	//配置文件名
    bool b_IsContainsConfig = false;
    if (argc > 1)
    {
        for (int j = 1; j < argc; j++)//遍历每个参数
        {
            const char *pchar = argv[j];//pchar暂存各个当前参数
            switch (pchar[0]) // 确定选项类型：-h,-d,-v,-l,-o;或者其他
            { 
                case '-':	//argv[j]以'-'开头，是命令
                    {
                        for (int i = 1; i < (int)(strlen(pchar)); i++)
                        {
                            switch (pchar[i])
                            {
                                // 确定用户指定的选项：h,d,v,l,o
                                case 'l': // 处理调试：
                                    pcmd[2] = "--disableMslocating";//替换pcmd[2]
                                    break;
                                case 'v': // 处理调试：
                                    pcmd[1] = "--verbose";//替换pcmd[1]
                                    break;
                                case 'c': // 处理调试：
                                    b_IsContainsConfig = true; //表示替换配置文件
                                    break;
                                case 'a': // 处理版本请求
                                    pcmd[3] = "--disableAppResis"; //替换pcmd[3]
                                    break;
                                default: // 无法识别的选项
                                    cout << "hzi:error:unrecognition option -:" << pchar << endl;
                                    usage(-1);
                            }
                        }
                        break;
                    }
                default: // argv[j]不以'-'开头，是文件名
                    {
                        if (b_IsContainsConfig && strstr(string(pchar).c_str(), ".json"))//使用其他配置文件
                        {
                            fileName = pchar;
                            pcmd[0] = std::move(fileName);//替换pcmd[0]
                            break;
                        }
                        else
                        {
                            cout << "不以'-'开头 file name:" << pchar << endl;
                            usage(0);
                            break;
                        }
                    }
            }
        }
    }
    
    //使用pcmd决定程序执行的参数
    ...
}
```

## （2）init()

### Config::init()

| 表名          | -    |
| ------------- | ---- |
| p_chn_types   |      |
| e_chns_config |      |

```cpp
//这里argc==4，argv==pcmd
static tl::expected<int, string> init(int argc, std::shared_ptr<const char *[]> argv)
{
    if (argc == 4)
    {
        //调用Config::make(string const &jsonConf)读取配置文件json，构造Config类对象conf
        return Config::make(string(argv[0])).and_then([&](Config conf)
        {
         	config = conf;//复制给Config::config（类static变量）
         	cout << "config file: " << argv[0] << endl;
         	for (int k = 0; k < config.devicesMap.size(); k++)
         	{
         	    hzi::sysDevMask += (int)exp2(k);//hzi::sysDevMask以mask形式保存基站数量
         	}
         	if (string(argv[1]) == "--verbose")
         	    config.verbose = true;
         	if (string(argv[2]) == "--disableMslocating")//实时微震定位开关关闭
         	    config.disableMslocating = true;
         	if (string(argv[3]) == "--disableAppResis")//disable实时电阻率计算
         	    config.disableAppResis = true;
         	return initChanelsConfig().and_then([&](auto r)
         	                           { 
         	                           		return initChnLabels(); 
         	                           });
    	});
    }
    return 0;
}

//使用默认配置文件初始化Config对象
static tl::expected<int, string> init(string jFile)
{
    return Config::make(jFile).and_then([&](Config conf)
	{
	    if (hzi::config.verbose)
	    {
	        cout << "Config::make ok\n";
	    }
	    for (int k = 0; k < config.devicesMap.size(); k++)
	    {
	        hzi::sysDevMask += (int)exp2(k);
	    }
	    config = conf;
	    return initChanelsConfig().and_then([&](auto r)
	                               {
	                                   if (hzi::config.verbose)
                                       {
                                           cout << "initChanelsConfig ok\n";
	                                   }
	                                   return initChnLabels(); 
	                               });                  
	});
}
```

### Config::make()

| 初始化变量                | 数据来源             | 内容                                                        |
| ------------------------- | -------------------- | ----------------------------------------------------------- |
| Config::config.devicesMap | 配置文件             | (基站id，基站类Device)                                      |
| Config::config.probeTo    | e_ms_locating_params | 微震定位范围由边缘检波器延伸(minX,maxX,minY,maxY,minZ,maxZ) |
| Config::config.msDevs     | e_chns_config        | 微震基站数量                                                |
| Config::config.eDevs      | e_chns_config        |                                                             |

```cpp
//从配置文件路径读取配置文件，并初始化系统配置参数
//jsonConf-json路径
struct Config
{
    static tl::expected<Config, string> make(string const &jsonConf)
    {
        return jsonDocFromFile(jsonConf).and_then([&](Document doc)->tl::expected<Config,string> 
        {
          try {
            cout << "Parsing configuration\n";
            Config config;
            config.configFilePath = jsonConf;
            std::cout << "configFilePath:" << jsonConf << endl;
            setVal(config.httpPort, GetValueByPointer(doc, "/http_port"));
            if (doc.HasMember("sampler_ip")) {
              config.sampler_ip = doc["sampler_ip"].GetString();
            }
            if (doc.HasMember("ms_rate"))
              setVal(config.msRate, GetValueByPointer(doc, "/ms_rate"));
            return config;
          } catch (zdb::sql_exception &e) {
            return tl::make_unexpected(string("Config::make error: ") + e.what());
          } catch (std::exception &e) {
            return tl::make_unexpected(string("Config::make error: ") + e.what());
          }
        });
    }
    
    private:
    static void setVal(uint16_t &var, Value const *valp) {
        if (valp) {
            var = valp->GetUint();
        }
    }
    static void setVal(uint32_t &var, Value const *valp) {
        if (valp) {
            var = valp->GetUint();
        }
    }
    static void setVal(float &var, Value const *valp) {
        if (valp) {
            var = valp->GetFloat();
        }
    }
    
    public:
    //读取json文件到doc
    static tl::expected<Document, string> jsonDocFromFile(string const &file) {
        FILE *fp = fopen(file.c_str(), "r");
        if (!fp)
            return tl::make_unexpected("failed opening file: " + file);

        char readBuf[1024];
        FileReadStream frs(fp, readBuf, sizeof(readBuf));
        Document doc;

        if (doc.ParseStream<kParseCommentsFlag>(frs).HasParseError()) {
            return tl::make_unexpected("jsonDocFromFile: invalid json file:" + file);
        }
        return std::move(doc);
    }

    //doc保存到json文件
    static tl::expected<bool, string> saveToJsonFile(string const &jsonPath,
                                                     Document const &doc) {
        FILE *fp = fopen(jsonPath.c_str(), "wb");
        if (!fp)
            return tl::make_unexpected("failed opening file: " + jsonPath);

        char writeBuf[1024];
        FileWriteStream fws(fp, writeBuf, sizeof(writeBuf));
        PrettyWriter<FileWriteStream> writer(fws);
        doc.Accept(writer);
        fclose(fp);
        return true;
    }  
};
```

### Config::initChanelsConfig()

> * getSpeed()
>
> * readnoWorkHours()
>
> * initminingGeologyStructMap()
>
> * initTunnelLocInfo()
>
> * updateTunnelModelInfo()
>
>   计算采空比，入库`e_tunnel_model_info`
>
> * initTunnelGeologyStructMap()

| 初始化变量                                                   | 数据来源                 | 内容                                                         |
| ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| reChannelsLabels（vec）                                      | e_chns_config            | 电极接收通道的label，形如：R1GR01                            |
| eeChannelsLabels                                             |                          | 电极发射通道的label，形如：E1GR01                            |
| msChannelsLabels（vec）                                      |                          | 地震通道的label，形如：S1GR01                                |
| reChannelsNum                                                |                          | 电极接收通道的数量                                           |
| eeChannelsNum                                                |                          | 电极发射通道的数量                                           |
| msChannelsConfigsMap                                         |                          | (地震通道label，该通道的ChanelsConfig)                       |
| reChannelsConfigsMap                                         |                          | (电极接收通道label，该通道的ChanelsConfig)                   |
| eeChannelsConfigsMap                                         |                          | (电极发射通道label，该通道的ChanelsConfig)                   |
|                                                              |                          |                                                              |
| Config::config.devicesMap.second.dataChns                    | e_chns_config            | 该基站中对应各种类型的通道的数量，按p_data_types顺序         |
| Config::config.devicesMap.second.dataChnLabel                |                          | 该基站中各数据类型通道labels，按p_data_types顺序             |
| Config::config.devicesMap.second.minChns                     |                          | 该基站各通道类型起始通道编号，按p_chn_types顺序              |
|                                                              |                          |                                                              |
| hzi::msEvtCnf.msThrldsMap                                    | e_chns_config            | (微震通道label，微震触发阈值，是否用于微震触发)              |
|                                                              |                          |                                                              |
| **getSpeed()**                                               |                          |                                                              |
| hzi::viewSpace::xMax等                                       | e_space                  |                                                              |
| hzi::viewSpace::evenSpeed等                                  | e_speed                  |                                                              |
| hzi::viewSpace::vtispeed_vector                              | e_vti_speeds             |                                                              |
|                                                              |                          |                                                              |
| **readnoWorkHours()**，注意`is_saveFile()`函数的调用链       |                          |                                                              |
| hzi::ms_bjVec                                                | e_samp_workHours         | 不保存微震背景数据的时间段                                   |
| hzi::ms_qsVec                                                |                          | 不保存微震全时数据的时间段                                   |
| hzi::ee_jdVec                                                |                          | 不保存激励电法数据的时间段                                   |
| hzi::ms_ohVec                                                |                          | 不保存震电耦合数据的时间段                                   |
|                                                              |                          |                                                              |
| **initminingGeologyStructMap()**                             |                          |                                                              |
| hzi::miningFreq                                              | e_mining_PCOSignalParm   | 数据频度（单位时间 h)                                        |
| hzi::miningDateLen                                           |                          | 数据时长（单位时间min)                                       |
| hzi::mining_classId                                          |                          | 拼接数据类型（6 微震全时 3-微震背景）                        |
| hzi::miningGeologyStructMap                                  | e_mining_struct_vertices | 地质构造：(id，地质构造GeologyStruct)，GeologyStruct内保存按照id分组且按照`vert_no`排序的记录(按id分组，vert_no不同)。`geologymap.second.locVec[vert_no - 1][0]`存x，`geologymap.second.locVec[vert_no - 1][1]`存y。 |
|                                                              |                          |                                                              |
| **initTunnelLocInfo()**                                      |                          |                                                              |
| hzi::tunnel_mining_loc                                       | e_tunnel_locInfo         | 日掘进状态                                                   |
| hzi::heading_mil                                             |                          |                                                              |
| hzi::firstChnNO                                              |                          |                                                              |
| hzi::day_step                                                |                          |                                                              |
| hzi::firstChn_locx                                           |                          |                                                              |
| dir                                                          | e_mining_PCOLocParm      |                                                              |
| hzi::tunnel_server                                           | e_tunnel_serverInfo      | 服务器ip和端口                                               |
| hzi::tunnel_port                                             |                          |                                                              |
|                                                              |                          |                                                              |
| **initTunnelGeologyStructMap()**                             |                          |                                                              |
| 表为空则插入                                                 | e_geology_info           | 岩性id，岩性（沙灰煤泥），p波速度，s波速度                   |
| geoMap。e_tunnel_geology_info若为空，插入初始数据，否则读取到geoMap | e_tunnel_geology_info    | label：岩性符号（RCF），lithologyId：岩性ID（从1起）         |
| hzi::miningGeologyStructMap                                  | e_mining_struct_vertices | 同上，且增加了：x_max，x_min，y_max，y_min，speed_p，speed_c，speed_s的初始化。（某种岩性的分布范围？） |
|                                                              |                          |                                                              |
| **setRotationMatrix()**                                      |                          |                                                              |
| hzi::rotationMatrixZ                                         | e_model_matrix           | 局部坐标系->大地坐标系旋转矩阵，只平移和绕z轴旋转            |
|                                                              |                          |                                                              |

### initChnLabels()

| 初始化变量                                | 数据来源      | 内容                                                     |
| ----------------------------------------- | ------------- | -------------------------------------------------------- |
| hzi::config.devicemap.second.dataChnLabel | e_chns_config | 各个基站的各数据类型通道的label                          |
| hzi::chnState                             | e_chns_config | 所有通道的(label,state_id)，state_id：正常/损坏/耦合不佳 |

# 7. startReceiver()

---

| 初始化变量                       | 数据来源                                      | 内容                                                         |
| -------------------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| serverPortList                   | `hzi::config.devicesMap[i].second.serverPort` | 与每个基站通信的服务器端口号                                 |
| hzi::config.deviceConnections    | serverPortList.size()                         | 基站连接数                                                   |
| hzi::config.MaxDeviceConnections | serverPortList.size()                         |                                                              |
|                                  |                                               |                                                              |
| **startReceiver2()**             |                                               | 对每个基站的数据开一个线程调用该函数处理接收                 |
| hzi::config.devSockMap           | hzi::config.devicesMap和clientfd              | (devicemap.second.id，new_sock)基站的id和服务器分配给该基站的client sockfd |
|                                  |                                               |                                                              |
| **handle_buf()**                 |                                               | 双缓冲区处理数据接收和粘包，从接收缓冲区中查找并提取完整的数据帧，将帧交给独立线程`receive_frame`处理，剩余数据存入备用缓冲区。 |
|                                  |                                               |                                                              |
| **receive_frame()**              |                                               | 初步处理回传（下位机--->上位机服务器）原始帧数据             |
|                                  |                                               |                                                              |
| **※handleRecvCmd()**             |                                               | 根据命令字cmd_id处理各类应答帧                               |
|                                  |                                               |                                                              |
| **recvBaseStationCheck()**       |                                               | 基站检测应答帧，解析并入库                                   |
| e_station_info                   |                                               | 基站设备信息入库。（设备信息是和基站连接后，由基站设备取回的基站信息，使用过程中不可修改） |
|                                  |                                               |                                                              |
| **recvClockCalibr()**            |                                               | 时间校准应答帧，解析并入库                                   |
| e_dev_clock                      |                                               | 时间基准                                                     |
|                                  |                                               |                                                              |
| **recvConfig()**                 |                                               | 采集置参应答帧，解析并入库                                   |
| e_dev_config_ack                 |                                               | 发射板是否置参成功                                           |

> [!NOTE]
>
> 原始应答帧接收，处理。
>
> * startReceiver2()——-多线程接收基站数据：每个线程在不同port上accept接收基站连接
>
>   > * handle_buf()——双缓冲区处理TCP粘包，获得一个原始数据帧buf
>   >
>   >   > ```cpp
>   >   > /*
>   >   > * buf1：当前处理数据缓冲区
>   >   > * pBuf1：记录buf1当前数据处理位置
>   >   > * buf2：处理粘包数据缓冲区
>   >   > * pBuf2：记录buf2当前数据处理位置
>   >   > *
>   >   > * 帧头不完整时，该次处理结束，数据留在buf1缓冲区里，记录待处理数据长度在mapbytesSum[port]中
>   >   > * 数据长度不足succs时，处理同上
>   >   > * 数据长度足够succs时，将buf1中数据所有权转移到receive_frame中处理，buf1清空，等待下一次while循环
>   >   > * 处理完一帧后，如果buf1中还有数据，将剩余数据放到buf2中，记录待处理长度在mapbytesSum[port]中
>   >   > */
>   >   > ```
>   >   >
>   >   > * receive_frame()——处理完整的一个原始数据帧buf
>   >   >
>   >   >   > * sync2()——若原始帧是cmd_id==8，说明接收到的是下位机sync1的应答帧，则立刻取当前时间作为接收sync1应答帧时的时间戳，通过sync2帧发送给下位机。
>   >   >   >
>   >   >   > * handleRecvCmd()——根据`cmd_id`，分类处理原始数据帧。**（上位机不对cmd_id==5or6or7or8or9应答帧做处理）**
>   >   >   >
>   >   >   >   > * recvBaseStationCheck()——基站检测应答帧入库表`e_station_info`。但**先删除了指定基站的记录！**
>   >   >   >   > * recvClockCalibr()——时间校准应答应答帧入库表`e_dev_clock`。没有先删除记录。
>   >   >   >   > * recvConfig()——采集置参应答帧入库表`e_dev_config_ack`。没有先删除记录。
>   >   >   >   > * recvData()——监测数据
```cpp
//libcall.hpp
#ifndef LIBCALL_HPP
#define LIBCALL_HPP

#include <cerrno>
#include <cstring>
#include <string>
#include "tl/expected.hpp"

using std::string;

template <typename Func, typename... Args>
tl::expected<int, string> callLibFunc(Func func,
                                      string const& funcName,
                                      Args&&... args) {
    int ret = 0;
    string errMsg = funcName + " error";
    ret = func(std::forward<Args>(args)...);
    if (ret == -1) {
        // return tl::make_unexpected(errMsg + std::strerror(errno));
        return tl::make_unexpected(errMsg);
    }

    return ret;
}
#endif
```


```cpp
socket.hpp
#ifndef SOCKET_HPP
#define SOCKET_HPP

#include <atomic>
#include <errno.h>
#include <iostream>
#include <string.h>
#include <string>
#include <sys/socket.h>
#include <sys/types.h>

#include "libcall.hpp"
#include "tl/expected.hpp"

using std::string;

namespace sock {

const int MAXCONNS = 5;

tl::expected<int, string> create();
tl::expected<int, string> bindTo(int sock, int port);
tl::expected<int, string> connectTo(int sock, const string host, int port);
tl::expected<int, string> acceptOn(int sock);
tl::expected<int, string> read(int sock, void *buf, size_t len);
tl::expected<int, string> write(int sock, void *buf, size_t len,
                                socklen_t priority = 3);
tl::expected<int, string> close_sock(int sock);
class Server {
public:
  static tl::expected<Server, string> make(int port) {
    Server server;
    return sock::create()
        .and_then([&](auto sock) {
          server.sock_ = sock;
          return sock::bindTo(sock, port);
        })
        .and_then([&](auto r) {
          return callLibFunc(std::bind(listen, server.sock_, sock::MAXCONNS),
                             "Server::make/listen");
        })
        .and_then([&](auto r) { return tl::expected<Server, string>(server); });
  }

  tl::expected<int, string> accept() const;

private:
  int sock_;
};

class Client {
public:
  Client() {
    try {
      auto exp = sock::create();
      if (!exp) {
        throw std::runtime_error(string("建立sse中继socket出错：") +
                                 exp.error());
      }
      sock_ = exp.value();
    } catch (std::exception e) {
      throw e;
    }
  }

  //返回连接host:port的Client对象
  static tl::expected<Client, string> make(string host, int port) {
    Client client;
    return sock::create()
        .and_then([&](auto sock) {
          client.sock_ = sock;
          return sock::connectTo(sock, host, port);
        })
        .and_then([&](auto r) { return tl::expected<Client, string>(client); });
  }

  tl::expected<int, string> ensureConnected(string host, int port);

  tl::expected<int, string> read(void *buf, size_t len) const;
  tl::expected<int, string> write(void *buf, size_t len) const;
  inline int getsock() { return sock_; }
  inline void close() { sock::close_sock(sock_); }

private:
  string host_;
  int port_ = 0;
  int sock_ = 0;
};

}; // namespace sock
#endif
```
```cpp
//socket.cpp
#include "socket.hpp"
#include <arpa/inet.h>
#include <iostream>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <unistd.h>

#include "Config.hpp"

namespace sock {
namespace {
sockaddr_in addr;
};

tl::expected<int, string> create() {
  string errMsg = "sock::create error: ";
  int sock;
  return callLibFunc(std::bind(socket, AF_INET, SOCK_STREAM, 0),
                     "sock::create/socket")
      .and_then([&](int s) {
        sock = s;
        int on = 1;
        return callLibFunc(std::bind(setsockopt, sock, SOL_SOCKET, SO_REUSEADDR,
                                     &on, sizeof(on)),
                           "sock::create/setsockopt");
      })
      .and_then([&](auto r) { return tl::expected<int, string>(sock); });
}

tl::expected<int, string> bindTo(int sock, int port) {
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = INADDR_ANY;
  addr.sin_port = htons(port);

  return callLibFunc(
      std::bind(bind, sock, (struct sockaddr *)&addr, sizeof(addr)),
      "sock::bind/bind");
}

tl::expected<int, string> connectTo(int sock, const string host, int port) {
  // 设置连接超时
  // struct timeval timeout;
  // timeout.tv_sec = 5;  // 5 秒超时
  // timeout.tv_usec = 0;

  // // setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout,
  // // sizeof(timeout));
  // int optval = 1;
  // setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));

  // setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout,
  // sizeof(timeout));
  int enableKeepAlive = 1;
  int keepIdle = 1 * 60; // Start probes after 60 seconds of inactivity
  int keepInterval = 5;  // Interval between probes
  int keepCount = 3;     // Number of probes to be sent before declaring the
                         // other end as unreachable

  setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &enableKeepAlive,
             sizeof(enableKeepAlive));
  setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, &keepIdle, sizeof(keepIdle));
  setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, &keepInterval,
             sizeof(keepInterval));
  setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, &keepCount, sizeof(keepCount));

  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  return callLibFunc(
             std::bind(inet_pton, AF_INET, host.c_str(), &addr.sin_addr),
             "sock::connectTo/inet_pton")
      .and_then([&](auto r) -> tl::expected<int, string> {
        if (r == 0) {
          return tl::make_unexpected(
              "sock::connectTo/inet_pton: invalid host name");
        }
        return callLibFunc(
            std::bind(connect, sock, (struct sockaddr *)&addr, sizeof(addr)),
            "sock::connectTo/connect");
      });
}

tl::expected<int, string> acceptOn(int sock) {
  int len = sizeof(addr);
  return callLibFunc(
      std::bind(accept, sock, (sockaddr *)&addr, (socklen_t *)&len),
      "sock::acceptOn/accept");
}

tl::expected<int, string> read(int new_sock, void *buf, size_t len) {
  return callLibFunc(std::bind(recv, new_sock, buf, len, 0), "sock::read/recv");
}

tl::expected<int, string> write(int new_sock, void *buf, size_t len,
                                socklen_t priority) {
  if (priority > 0 && priority < 7) {
    setsockopt(new_sock, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority));
  }
  return callLibFunc(std::bind(send, new_sock, buf, len, MSG_NOSIGNAL),//处理对端关闭TCP连接继续向连接中写入数据时，不终止程序进程
                     "sock::write/send");
}
tl::expected<int, string> close_sock(int sock) {
  shutdown(sock, SHUT_RDWR);
  return callLibFunc(std::bind(close, sock), "sock::closeSock/close");
  // close(sock_);
}

tl::expected<int, string> Server::accept() const {
  return sock::acceptOn(sock_);
}

tl::expected<int, string> Client::read(void *buf, size_t len) const {
  return sock::read(sock_, buf, len);
}

tl::expected<int, string> Client::write(void *buf, size_t len) const {
  return sock::write(sock_, buf, len);
}
tl::expected<int, string> Client::ensureConnected(string host, int port) {
  int16_t tag = 0x0000;
  auto tryWrite = write(&tag, sizeof(tag));
  if (tryWrite) {
    cout << "connect ensured\n";
    return tryWrite;
  } else {
    return sock::create().and_then([&](auto sock) {
      sock_ = sock;
      host_ = host;
      port_ = port;
      cout << "created:socke:" << sock_ << ",host:" << host
           << ",port_:" << port_ << "\n";
      return sock::connectTo(sock_, host_, port_);
    });
  }
}
}; // namespace sock
```


```cpp
//receiver.hpp
#ifndef RECEIVER_HPP
#define RECEIVER_HPP

#include "tl/expected.hpp"

#include <string>

void startReceiver();
void startReceiver2(int port);
#endif
```

```cpp
//receiver.cpp
#include "receiver.hpp"
#include "common.hpp"
#include "recv_data.hpp"
#include "socket.hpp"
#include "time_sync.hpp"

#include <chrono>
#include <sstream>

using namespace sock;

namespace {
std::map<int, size_t> mapbytesSum;//(port待处理字节数)
std::atomic_int32_t running = 0;

}; // namespace

uint8_t connections = 0;

tl::expected<int, string> handleRecvCmd(uint8_t cmdId, uint32_t cmdSeq,
                                        uint8_t devAddr,
                                        std::unique_ptr<char[]> pData) {
  switch (cmdId) {
  case 1:
    return recvBaseStationCheck(cmdSeq, std::move(pData));//基站检测应答
    break;
  case 2:
    return recvClockCalibr(cmdSeq, devAddr, std::move(pData));//时间校准应答
    break;
  case 3:
    return recvConfig(cmdSeq, devAddr, std::move(pData));//采集置参
    break;
  case 4:
    return recvData(cmdSeq, devAddr, std::move(pData));//监测应答
  case 5:
  case 6:
  case 7:
  case 8:
  case 9:
    return 0;//cmd_id=5/6/7/8/9直接返回0

  default:
    return tl::make_unexpected("handleRecvCmd 错误: 无效命令字");
  }
  return tl::expected<int, string>(0);
}

void receive_frame(std::unique_ptr<char[]> buf, size_t bytesGot) {
  try {
    char *pBuf = buf.get();
    uint32_t head = *(uint32_t *)pBuf;
    if (head != 0x69686968) {
      std::stringstream ss;
      ss << "收到错误帧，非法帧头，丢弃此帧。帧头:0x" << std::hex << head
         << "\n";
      logErr(ss.str());
      return;
    }

    uint8_t addr = *(uint8_t *)(pBuf + 10); // 设备地址

    uint8_t cmd_id = *(uint8_t *)(pBuf + 11); // 命令字

    //收到下位机sync1应答帧
    if (cmd_id == 8) {
      auto now = high_resolution_clock::now();
      auto duration = now.time_since_epoch();
      auto microSecs = duration_cast<microseconds>(duration).count();

      sync2(addr, microSecs);//将接收到sync1应答帧的时间戳通过sync2发给下位机
      return;
    }

    int32_t cmd_seq = be32toh(*(int32_t *)(pBuf + 12)); // 命令标识

    size_t dataLen = bytesGot - 22;//数据区长度

    // int32_t checksum = be32toh(*(int32_t *)pBuf); //校验和

    uint16_t tail = *(uint16_t *)(pBuf + bytesGot - 2);
    auto classId = *(uint8_t *)(pBuf + 24);//监测数据回传帧（下位机--->采集主机），原始帧类型

    // 激电无效发射电极帧剔除
    bool invalidEmitFrm = false;
    uint8_t emitFrmNo;
    string emitLabel;
    if (cmd_id == 4 && classId == 1) {
      emitFrmNo = *(uint8_t *)(pBuf + 32);
      string start("E");
      start += std::to_string(addr);
      string end = emitFrmNo < 10 ? string("0") : string("");
      end += std::to_string(emitFrmNo);
      auto labels = hzi::config.devicesMap[addr].emitLabel;
      for (int i = 0; i < labels.size(); i++) {
        if (labels[i].substr(0, 2) == start && labels[i].substr(4) == end) {
          emitLabel = labels[i];
          break;
        }
      }
      invalidEmitFrm = hzi::eeChannelsConfigsMap[emitLabel].stateId > 0;
    }

    if (hzi::config.verbose && cmd_id != 9) {
    // if (hzi::config.verbose) {
      std::scoped_lock<std::mutex> lck(hzi::globalMtx);
      namespace ch = std::chrono;
      cout << "\n";
      auto time = ch::system_clock::now(); // Get the current time
      std::cout << timeStr(time) << " ";
      cout << "应答帧:字节数:" << std::dec << bytesGot;
      cout << std::hex << ",帧头:0x" << be32toh(head);
      cout << std::dec << ",后续字节数:" << be32toh(*(uint32_t *)(pBuf + 4));
      cout << ",设备地址:" << (unsigned)addr;
      cout << ",命令字:" << (unsigned)cmd_id;
      cout << ",命令标识:" << cmd_seq;
      cout << ",数据区字节数:" << dataLen;

      //启动监测应答（回传）帧
      if (cmd_id == 4) {
        cout << ",数据类型:" << (unsigned)classId;
        cout << ",采样时间:" << be64toh(*(int64_t *)(pBuf + 16));//采集时间（utc毫秒时间戳）
        auto chnns = be16toh(*(uint16_t *)(pBuf + 26)); // 包含通道数
        auto pnts = be32toh(*(uint32_t *)(pBuf + 28));  // 每通道包含点数
        if (chnns == 0 || pnts == 0) {
          cout << ",无效数据区,舍弃\n";
          return;
        }
        //数据类型：激电
        if (classId == 1 && invalidEmitFrm) {
          cout << ",基站" << (unsigned)addr << ",无效激电发射帧"
               << (unsigned)(emitFrmNo +
                             hzi::config.devicesMap[addr].minChns[2] - 1)
               << ",舍弃\n";
        }
      }
      //1588同步2
      if (cmd_id == 9) {
        cout << ",基站时间:" << std::fixed << std::dec
             << be64toh(*(int64_t *)(pBuf + 16))
             << ",偏移:" << std::setprecision(1)
             << (double)((long)be64toh(*(int64_t *)(pBuf + 24)) / 2) << "(us)";
        return;
      }
      cout << ",帧尾:0x" << std::hex << tail << "\n";
    }

    if (invalidEmitFrm) {
      return;
    }

    if (tail != 0x1616) {
      std::stringstream ss;
      ss << "收到错误帧，非法帧尾，丢弃此帧。" << std::dec
         << "帧字节数:" << bytesGot
         << ",后续字节数:" << be32toh(*(uint32_t *)(pBuf + 4));
      if (cmd_id == 4) {
        ss << ",数据类型:" << (unsigned)*(uint8_t *)(pBuf + 24)//class_id
           << ",数据区字节数:" << dataLen;
      }
      ss << ",帧尾:0x" << std::hex << tail;
      logErr(ss.str());
      return;
    }

    if (cmd_id == 9) {
      return;
    }

    // 如果需要原始帧
    // auto classId = *(uint8_t*)(pBuf + 24);
    // if (classId == 1 || classId == 0) {
    //   string tmpFile("/tmp/");
    //   tmpFile += std::to_string(be64toh(*(int64_t *)(pBuf + 16))) + "_";
    //   tmpFile += std::to_string(classId) + "_" + std::to_string(addr) +
    //   ".big"; data::writeDataToFile(tmpFile.c_str(), buf.get(), bytesGot);
    // }
    // 处理数据
    handleRecvCmd(cmd_id, cmd_seq, addr, std::move(buf))
        .map_error([&](auto err) {
          std::cerr << "处理应答帧数据出错：" << err << "\n";
          return;
        });
  } catch (sql_exception &e) {
    logErr(e.what());
  } catch (std::exception &e) {
    logErr(e.what());
  }
}

/*
* buf1：当前处理数据缓冲区
* pBuf1：记录buf1当前数据处理位置
* buf2：处理粘包数据缓冲区
* pBuf2：记录buf2当前数据处理位置
*
* 帧头不完整时，该次处理结束，数据留在buf1缓冲区里，记录待处理数据长度在mapbytesSum[port]中
* 数据长度不足succs时，处理同上
* 数据长度足够succs时，将buf1中数据所有权转移到receive_frame中处理，buf1清空，等待下一次while循环
* 处理完一帧后，如果buf1中还有数据，将剩余数据放到buf2中，记录待处理长度在mapbytesSum[port]中
*/
void handle_buf(int port, size_t dataBytes, std::unique_ptr<char[]> &buf1,
                char *&pBuf1, std::unique_ptr<char[]> &buf2, char *&pBuf2) {
  dataBytes += mapbytesSum[port];//上次没处理完的字节数加上
  int i = 0;
  pBuf1 = buf1.get();
  // pBuf2 = buf2.get();
  size_t succs;//帧头8B:0x69686968+succs（数据长度）
  while (i < dataBytes - 8) {
    if (*(uint32_t *)(pBuf1 + i) == 0x69686968) {
      succs = be32toh(*(uint32_t *)(pBuf1 + i + 4));
      if (succs > 0) {
        break;
      }
    }
    i++;
  }

  // i是buf1中帧头位置,  如果i后面不够帧头长度，返回. pBuf1指向buf1末尾
  if (i >= dataBytes - 8) {
    pBuf1 += dataBytes;
    mapbytesSum[port] = dataBytes;
    return;
  }

  // 帧头前字节丢弃
  dataBytes -= i;
  if (i > 0) {
    memmove(pBuf1, pBuf1 + i, dataBytes);
  }

  // succs+8为帧总字节数
  int64_t left = dataBytes - succs - 8;

  // 如果长度够1帧，处理之
  if (left >= 0) {
    // 剩下的放进buf2
    memmove(pBuf2, pBuf1 + succs + 8, left);
    pBuf2 += left;
    mapbytesSum[port] = left;

    std::thread handler(receive_frame, std::move(buf1), succs + 8);//一帧数据所有权转移给receive_frame形参
    if (handler.joinable()) {
      handler.detach();
    }

    // hzi::config.threadPool.push_task([&] {
    //     running++;
    //     receive_frame(std::move(buf1), succs + 8);
    //     running--;
    // });
    // if (hzi::config.verbose) {
    //     cout << "thread pool:tasks queued:" << std::dec
    //          << hzi::config.threadPool.get_tasks_queued()
    //          << ",tasks running:"
    //          << hzi::config.threadPool.get_tasks_running()
    //          << ",total tasks:" <<
    //          hzi::config.threadPool.get_tasks_total()
    //          << ",running count:" << running << "\n";
    // }

    // buf1放空
    buf1 = std::make_unique<char[]>(hzi::config.recvBufsize);//此时buf1==nullptr，buf1.reset(new char[hzi::config.recvBufsize]);
    if (!buf1) {
      logErr("接收缓冲区分配内存出"
             "错，退出");
      exit(1);
    }
    pBuf1 = buf1.get();
  } else {
    pBuf1 += dataBytes;
    mapbytesSum[port] = dataBytes;
  }
  return;
}
std::unordered_map<int, std::unique_ptr<char[]>> mapBufA;//两个缓冲区，用于接收数据。
std::unordered_map<int, std::unique_ptr<char[]>> mapBufB;

std::unordered_map<int, char *> map_pBufA;//map_pBufA 和 map_pBufB 分别指向当前使用的缓冲区的指针。
std::unordered_map<int, char *> map_pBufB;
void startReceiver() {
  // std::thread genDensities(genDensityFiles);
  // genDensities.detach();
  std::vector<int> serverPortList;//服务器监听端口列表（每个基站一个端口）
  for (auto &devicemap : hzi::config.devicesMap) {
    int server_port = devicemap.second.serverPort;
    int dev_addr = devicemap.second.id;
    // mapBufA.insert_or_assign(
    //     dev_addr, std::make_unique<char[]>(hzi::config.recvBufsize));
    // mapBufB.insert_or_assign(
    //     dev_addr, std::make_unique<char[]>(hzi::config.recvBufsize));
    if (!(std::find(serverPortList.begin(), serverPortList.end(),
                    server_port) != serverPortList.end())) {
      serverPortList.push_back(server_port);
    }
  }
  int constSize = serverPortList.size();
  hzi::config.deviceConnections = constSize;
  hzi::config.MaxDeviceConnections = constSize;
  // connections = constSize;

  std::thread receiverArry[constSize];

  for (int i = 0; i < constSize; i++) {
    receiverArry[i] = std::thread(startReceiver2, serverPortList.at(i));
    receiverArry[i].detach();
  }

  return;
}

/*
* 多线程接收基站数据：每个线程在不同port上accept接收基站连接
*/
void startReceiver2(int port) {
  cout << "Listen server Port:" << port << endl;
  try {
    auto serverExp = Server::make(port);
    if (!serverExp) {
      logErr("端口" + std::to_string(port) +
             "上创建tcp服务失败: " + serverExp.error());
      exit(1);
      // std::this_thread::sleep_for(std::chrono::seconds(5)); // Retry delay
      // continue; // Retry creating server
    }

    Server server = std::move(serverExp.value());//Server类没有写赋值移动函数，编译器会尝试使用默认的移动语义。默认的移动语义会逐成员移动对象的成员变量
    string msg("端口");
    msg += std::to_string(port) + "上位机服务已启动";
    logInfo(msg);
    while (1) { // layer 2
      string msg1("端口");
      msg1 += std::to_string(port) + "等待基站连接";
      logInfo(msg1);
      server.accept()
          .map([&](int new_sock) {
            int devID = 0;

            for (auto &devicemap : hzi::config.devicesMap) {
              int server_port = devicemap.second.serverPort;
              if (server_port == port) {
                devID = devicemap.second.id;//获取连上的基站的id
                hzi::config.devSockMap.insert_or_assign(devicemap.second.id,
                                                        new_sock);//(dev_id,clientfd)
                mapBufA.insert_or_assign(
                    port, std::make_unique<char[]>(hzi::config.recvBufsize));
                mapBufB.insert_or_assign(
                    port, std::make_unique<char[]>(hzi::config.recvBufsize));
                map_pBufA.insert_or_assign(port, mapBufA[port].get());
                map_pBufB.insert_or_assign(port, mapBufB[port].get());

                mapbytesSum.insert_or_assign(port, 0);
              }
            }
            logInfo(string(std::to_string(devID) + "号基站已连接:") +
                    std::to_string(port));
            // hzi::config.devSock = new_sock;

            if (!mapBufA[port] || (!mapBufB[port])) {
              logErr("接收缓冲区分配内存出错，退出");
              exit(1);
            }
            bool over = false;
            while (1) { // layer 3
              // 若bufA是空的, 则bufB使用中，接收数据进bufB
              //若指向缓冲区起始位置，则该缓冲区未使用
              if (map_pBufA[port] == mapBufA[port].get()) {
                sock::read(new_sock, map_pBufB[port], hzi::config.recvBufsize)
                    .map([&](auto bytes) {
                      if (bytes > 0) {
                        handle_buf(port, bytes, mapBufB[port], map_pBufB[port],
                                   mapBufA[port], map_pBufA[port]);
                      }
                    })
                    .map_error([&](auto err) {
                      logErr(string("1:socket read failed:") + err);
                      over = true;
                    });
              } else { // 否则，bufA使用中，接收数据进bufA
                sock::read(new_sock, map_pBufA[port], hzi::config.recvBufsize)
                    .map([&](auto bytes) {
                      if (bytes > 0) {
                        handle_buf(port, bytes, mapBufA[port], map_pBufA[port],
                                   mapBufB[port], map_pBufB[port]);
                      }
                    })
                    .map_error([&](auto err) {
                      logErr(string("2:socket read failed:") + err);
                      over = true;
                    });
              }
              if (over) {
                logInfo(string(std::to_string(devID) + "号基站已断开:") +
                        std::to_string(port));
                close_sock(new_sock);
                break;
              }
            }
          })
          .map_error(
              [&](auto err) { logErr(string("server.accept failed:") + err); });
    }

  } catch (const std::exception &e) {
    logErr("Unexpected exception in startReceiver2: " + string(e.what()));
    std::this_thread::sleep_for(std::chrono::seconds(5)); // Retry delay
  }
}
// Server::make(port)
//     .map([&](Server server) {
//       string msg("端口");
//       msg += std::to_string(port) + "上位机服务已启动";
//       logInfo(msg);
//       while (1) {
//         string msg1("端口");
//         msg1 += std::to_string(port) + "等待基站连接";
//         logInfo(msg1);
//         server.accept()
//             .map([&](int new_sock) {
//               int devID = 0;

//               for (auto &devicemap : hzi::config.devicesMap) {
//                 int server_port = devicemap.second.serverPort;
//                 if (server_port == port) {
//                   devID = devicemap.second.id;
//                   hzi::config.devSockMap.insert_or_assign(devicemap.second.id,
//                                                           new_sock);
//                   mapBufA.insert_or_assign(
//                       port,
//                       std::make_unique<char[]>(hzi::config.recvBufsize));
//                   mapBufB.insert_or_assign(
//                       port,
//                       std::make_unique<char[]>(hzi::config.recvBufsize));
//                   map_pBufA.insert_or_assign(port, mapBufA[port].get());
//                   map_pBufB.insert_or_assign(port, mapBufB[port].get());

//                   mapbytesSum.insert_or_assign(port, 0);
//                 }
//               }
//               logInfo(string(std::to_string(devID) + "号基站已连接:") +
//                       std::to_string(port));
//               // hzi::config.devSock = new_sock;

//               if (!mapBufA[port] || (!mapBufB[port])) {
//                 logErr("接收缓冲区分配内存出错，退出");
//                 exit(1);
//               }
//               bool over = false;
//               while (1) {
//                 // 若bufA是空的, 则bufB使用中，接收数据进bufB
//                 if (map_pBufA[port] == mapBufA[port].get()) {
//                   sock::read(new_sock, map_pBufB[port],
//                   hzi::config.recvBufsize)
//                       .map([&](auto bytes) {
//                         if (bytes > 0) {
//                           handle_buf(port, bytes, mapBufB[port],
//                                      map_pBufB[port], mapBufA[port],
//                                      map_pBufA[port]);
//                         }
//                       })
//                       .map_error([&](auto err) {
//                         logErr(string("1:socket read failed:") + err);
//                         over = true;
//                       });
//                 } else { // 否则，bufA使用中，接收数据进bufA
//                   sock::read(new_sock, map_pBufA[port],
//                   hzi::config.recvBufsize)
//                       .map([&](auto bytes) {
//                         if (bytes > 0) {
//                           handle_buf(port, bytes, mapBufA[port],
//                                      map_pBufA[port], mapBufB[port],
//                                      map_pBufB[port]);
//                         }
//                       })
//                       .map_error([&](auto err) {
//                         logErr(string("2:socket read failed:") + err);
//                         over = true;
//                       });
//                 }
//                 if (over) {
//                   logInfo(string(std::to_string(devID) + "号基站已断开!:") +
//                           std::to_string(port));
//                   close(new_sock);
//                   break;
//                 }
//               }
//             })
//             .map_error([&](auto err) {
//               logErr(string("server.accept failed:") + err);
//             });
//       }
//     })
//     .map_error([&](auto err) { logErr(string("make server failed: ") + err);
//     });
// }

```
```cpp
//recv_data.hpp
#ifndef RECVDATA_HPP
#define RECVDATA_HPP

#include "tl/expected.hpp"

#include <iostream>
#include <map>
#include <memory>
#include <string>

using std::cout;
using std::endl;
using std::string;
using std::to_string;

struct lastData0 {
    time_t laststamp;
    char* lastdata;
};
extern uint8_t connections;

tl::expected<int, string> recvData(uint32_t cmdSeq,
                                   uint8_t devAddr,
                                   std::unique_ptr<char[]> pData);
tl::expected<int, string> recvBaseStationCheck(int cmdSeq,
                                               std::unique_ptr<char[]> pData);

tl::expected<int, string> recvClockCalibr(int32_t cmdSeq,
                                          int devAddr,
                                          std::unique_ptr<char[]> pData);
tl::expected<int, string> recvConfig(uint32_t cmdSeq,
                                     uint8_t devAddr,
                                     std::unique_ptr<char[]> pData);
#endif
```
```cpp
//recv_data.cpp
#include "recv_data.hpp"
#include "Config.hpp"
#include "DataFrame.hpp"
#include "common.hpp"
#include "merge_frame.hpp"
#include "post_handler.hpp"
#include "time_sync.hpp"

#include "data_density.hpp"
#include <iostream>
#include <string>

#undef TRY
#include "zdbpp.h"

using std::cout;
using std::endl;
using std::string;
using std::to_string;

namespace hzi {
FrameQueue frameQueues;
}; // namespace hzi

tl::expected<int, string> recvBaseStationCheck(int cmdSeq,
                                               std::unique_ptr<char[]> pData) {
  try {
    char dev_id[33];
    dev_id[32] = '\0';
    char *ptr = pData.get() + 16;//设备识别ID串(出厂时设定，具备唯一性，32字节长度)
    memcpy(dev_id, ptr, 32);

    uint8_t dev_addr = *(uint8_t *)(ptr + 32);//设备地址标识码（出厂时设定，取0x01~0xfe）
    string dev_ver = to_string(*(uint8_t *)(ptr + 33)) + "." +
                     to_string(*(uint8_t *)(ptr + 34)) + "." +
                     to_string(*(uint8_t *)(ptr + 35)) + "." +
                     to_string(*(uint8_t *)(ptr + 36));//设备版本号
    string soft_ver = to_string(*(uint8_t *)(ptr + 37)) + "." +
                      to_string(*(uint8_t *)(ptr + 38)) + "." +
                      to_string(*(uint8_t *)(ptr + 39)) + "." +
                      to_string(*(uint8_t *)(ptr + 40));//采集程序版本号

    int schm_id = *(uint8_t *)(ptr + 41);//设备模式：0x00:地震电法;  0x01:电法;  0x02:地震
    int samp_chs = *(uint8_t *)(ptr + 42);//总采集通道数
    int emit_chs = *(uint8_t *)(ptr + 43);
    int ms_chs = *(uint8_t *)(ptr + 44);//微震采集通道数
    int e_samp_chs = *(uint8_t *)(ptr + 45);
    int e_emit_chs = *(uint8_t *)(ptr + 46);
    int m_samp_chs = *(uint8_t *)(ptr + 47);
    int tempr_chs = *(uint8_t *)(ptr + 48);
    int emit_board = *(uint8_t *)(ptr + 49);
    int tempr_board = *(uint8_t *)(ptr + 50);
    int gama_board = *(uint8_t *)(ptr + 51) + *(uint8_t *)(ptr + 52) * 2;
    // cout << "recvBaseStationCheck  " << cmdSeq << " dev_addr=" <<
    // dev_addr
    //      << endl;
    Connection conn = hzi::config.pConnPool->getConnection();

    // conn.execute(
    //     "TRUNCATE TABLE "
    //     "e_station_info");
    conn.execute("DELETE from "
                 "e_station_info  where dev_addr =?",
                 dev_addr);//先删除了指定基站的记录！
    conn.execute("INSERT INTO "
                 "e_station_info (cmd_seq, "
                 "dev_id, dev_addr, "
                 "schm_id, "
                 "dev_version, "
                 "soft_version, "
                 "total_samp_chns, "
                 "total_excit_chns, "
                 "ms_samp_chns, "
                 "elec_samp_chns, "
                 "excit_chns, mag_chns, "
                 "tempr_chns, "
                 "if_excit_attached, "
                 "if_tempr_attached,if_gama_attached)"
                 " values(?,?,?,?,?,?,?,?,?"
                 ",?,?,?,?,?,?,?)",
                 cmdSeq, dev_addr, dev_addr, schm_id, dev_ver, soft_ver,
                 samp_chs, // 1设备信息写库出错:
                 emit_chs, ms_chs, e_samp_chs, e_emit_chs, m_samp_chs,
                 tempr_chs, emit_board, tempr_board, gama_board);
    // conn.close();
  } catch (sql_exception &e) {
    cout << "1设备信息写库出错:" << e.what() << endl;
    tl::make_unexpected(string("设备信息写库出错：") + e.what());
  } catch (std::exception &e) {
    cout << "设备信息写库出错:" << e.what() << endl;
    tl::make_unexpected(string("设备信息写库出错：") + e.what());
  }

  return tl::expected<int, string>(0);
}
tl::expected<int, string> recvClockCalibr(int32_t cmdSeq, int devAddr,
                                          std::unique_ptr<char[]> pData) {
  try {
    int64_t tmStamp = be64toh(*(int64_t *)(pData.get() + 16));//设备时间，utc毫秒时间戳
    Connection conn = hzi::config.pConnPool->getConnection();
    conn.execute("INSERT INTO "
                 "e_dev_clock(cmd_seq, "
                 "dev_addr, tmstamp) "
                 "values (?, "
                 "?, ?) ",
                 cmdSeq, devAddr, (long long)tmStamp);
    // conn.close();
    return 0;
  } catch (sql_exception &e) {
    return tl::make_unexpected(string("recvClockCalibr:") + e.what());
  } catch (std::exception &e) {
    return tl::make_unexpected(string("recvClockCalibr:") + e.what());
  }
  return tl::expected<int, string>(0);
}

tl::expected<int, string> recvConfig(uint32_t cmdSeq, uint8_t devAddr,
                                     std::unique_ptr<char[]> pData) {
  try {
    int emit_board_conf = *(uint8_t *)(pData.get() + 16);//发射板是否置参成功：0：未成功（地震模式下可忽略，其他模式报错） 1：已成功 
    Connection conn = hzi::config.pConnPool->getConnection();
    conn.execute("INSERT INTO "
                 "e_dev_config_ack(cmd_seq,"
                 " dev_addr, "
                 "emit_board_conf) values "
                 "(?, ?, ?)",
                 (int32_t)cmdSeq, devAddr, emit_board_conf);
  } catch (sql_exception &e) {
    tl::make_unexpected(string("recvConfig:") + e.what());
  } catch (std::exception &e) {
    tl::make_unexpected(string("recvConfig:") + e.what());
  }
  return tl::expected<int, string>(0);
}
bool is_saveFile(int classId, uint64_t sampTime) {
  bool flag = true;
  uint64_t midnite = midnight(sampTime);
  uint64_t tm = sampTime - midnite; // 当日相对采样时刻(ms)

  if (classId == 6) {
    //全时
    for (const auto &workHour : hzi::ms_qsVec) {
      if (tm >= workHour.start_time && tm < workHour.end_time) {
        return false;
      }
    }
  }
  if (classId == 5) {
    //耦合数据
    for (const auto &workHour : hzi::ms_ohVec) {
      if (tm >= workHour.start_time && tm < workHour.end_time) {
        return false;
      }
    }
  }
  if (classId == 3) {
    //微震背景
    for (const auto &workHour : hzi::ms_bjVec) {
      if (tm >= workHour.start_time && tm < workHour.end_time) {
        return false;
      }
    }
  }
  if (classId == 1) {
    //激电
    for (const auto &workHour : hzi::ee_jdVec) {
      if (tm >= workHour.start_time && tm < workHour.end_time) {
        return false;
      }
    }
  }
  return flag;
}

tl::expected<int, string> recvData(uint32_t cmdSeq, uint8_t devAddr,
                                   std::unique_ptr<char[]> upData) {
  DataFrame::make(cmdSeq, std::move(upData))
      .map([&](DataFrame df1) {
        auto df = std::move(df1);
        if (hzi::config.verbose) {
          df.print("原始帧");
        }
        // if (df.classId() == 6 || df.classId() == 2) {
        // string file("/tmp/");
        // file += std::to_string(df.sampTime()) + "_" +
        //         std::to_string(df.classId()) + ".lit";
        // df.writeToFile(file);
        // }
        hzi::config.devicesMap[devAddr].sampling = true;
        hzi::config.devicesMap[devAddr].lastSampTime =
            df.sampTime(); // 用于查询基站监测状态

        hzi::serverStatus.lastSampTimes[df.classId()] = df.sampTime();
        //根据数据存储策略判定是否保存数据帧
        if (!is_saveFile(df.classId(), df.sampTime()))
          return 0;

        if (hzi::config.devicesMap.size() > 1) {
          if ((df.classId() == 0 || df.classId() == 1) &&
              hzi::config.eDevs < 2) {
            handleData(std::move(df));
          } else if ((df.classId() == 2 || df.classId() == 3 ||
                      df.classId() == 6) &&
                     hzi::config.msDevs < 2) {
            handleData(std::move(df));
          } else {
            if (df.classId() == 0) {
              std::this_thread::sleep_for(10s); // 等待激电信号
            }
            hzi::frameQueues.push(df.classId(), std::move(df));
            merger::mergeFrame(df.classId());
          }
        } else {
          handleData(std::move(df));
        }
      })
      .map_error([&](auto e) {
        string msg("recvData error:");
        msg += e;
        debugErr(msg);
      });
  return 0;
}
```
```cpp
//post_handler.hpp
#ifndef POSTHANDLER_HPP
#define POSTHANDLER_HPP

#include "tl/expected.hpp"

#include "DataFrame.hpp"

tl::expected<int, string> handleData(const DataFrame df);
tl::expected<int, string> reCheckMSEvt_bj(const DataFrame df);
#endif
```
```cpp
//post_handler.cpp
#include "post_handler.hpp"
#include "MSDataFrame.hpp"
#include "data_density.hpp"
#include "ms_locator.hpp"
#include "resis_handler.hpp"
#include "vec_resis_handler.hpp"
#include "web/commands.hpp"
#include "ee_mining.hpp"

#include <algorithm>
#include <chrono>
#include <execution>
#include <filesystem>
// #include <map>
#include "ms_mining.hpp"
#include <numeric>

namespace fs = std::filesystem;
using std::pair;
using std::to_string;
using std::vector;
using namespace std::chrono_literals;

namespace {
DataFrame lastMSFrm;
int msPntsNeeded = -1;
string trigChnLabel;
std::mutex msMtx;
using s_vui_t =
    pair<string, vector<uint16_t>>; // 通道label所有超过阈值的数据点编号

/// @brief 检查指定通道中是否有微震事件点
/// @param chLabel 当前提取微震事件的通道的label
/// @param pPnts 帧数据区指定通道的数据起始地址
/// @param pnts 指定通道的点数
/// @param lastTrigPnt 上一个微震触发点的索引
/// @return 找到微震事件点则返回点索引，否则返回传入的上次微震事件点
int checkChn4MSEvt(string chLabel, int32_t *pPnts, int pnts, int lastTrigPnt) {
  for (int i = 0; i < lastTrigPnt;) {
    int j = i;
    while (j < pnts && abs(pPnts[j]) * hzi::config.voltageCoef >=
                           hzi::msEvtCnf.msThrldsMap[chLabel].first) {//点幅值乘以hzi::config.voltageCoef大于微震触发阈值
      j++;
    }
    if (j - i + 1 >= hzi::msEvtCnf.pulsWid) {//连续超过微震触发阈值的点的数量大于微震触发脉宽
      return i;//返回触发点（第一个点）的索引
    }
    i = ++j;//否则从j之后个点继续判断
  }
  return lastTrigPnt;//没有找到触发点，则返回上次的出发点索引
}

// 单通道触发
tl::expected<std::pair<string, uint16_t>, string>
checkMSEvt(const DataFrame &df) {
  if (df.emitting()) {
    return tl::make_unexpected("this is a emitting frame");
  }
  auto cLabels = df.chnLabels();

  int32_t *p32 = (int32_t *)df.upData.get();
  int lastTrigPnt = df.points();
  //遍历该数据帧中通道，判断通道中是否有微震事件点，若有则返回一系列触发点中第一个的编号
  for (int i = 0; i < df.channels(); i++) {
    if (!hzi::msEvtCnf.msThrldsMap[cLabels[i]].second) {
      continue; //不用于微震触发则下一个通道
    }

    auto tp = checkChn4MSEvt(cLabels[i], p32 + i * df.points(), df.points(),
                             lastTrigPnt);
    if (tp < lastTrigPnt) {//找到了触发点
      trigChnLabel = cLabels[i];
      lastTrigPnt = tp;
    }
  }
  if (lastTrigPnt == df.points()) {
    return tl::make_unexpected("no ms event in this data frame");
  } else {
    return std::make_pair(trigChnLabel, lastTrigPnt);//最后一个触发的通道？
  }
}

bool validTrig(const vector<s_vui_t> &vecTriggedPnts, string chnLbl,
               int trigAt) {
  uint8_t trigChns = 0; // validRange內触发通道数
  auto pulWid = hzi::msEvtCnf.pulsWid;
  for (auto &ch : vecTriggedPnts) {
    if (ch.first == chnLbl)
      continue;
    int i = 0;
    while (ch.second[i] < trigAt)
      i++;
    while (i < ch.second.size() - pulWid + 1) {
      if (ch.second[i] - trigAt > hzi::msEvtCnf.validRange) {
        break;
      }

      if (ch.second[i + pulWid - 1] - ch.second[i] == pulWid - 1) {
        trigChns++;
        if (trigChns >= hzi::msEvtCnf.msTrigChns) {
          return true;
        }
      }
      i++;
    }
  }
  return false;
}

// chnLbl 是否为有效触发通道
int validTrig(const vector<s_vui_t> &vecTriggedPnts, string chnLbl) {
  // {
  //     std::unique_lock<std::mutex> lck(hzi::globalMtx);
  //     cout << "check validTrig:" << chnLbl << "\n";
  // }
  if (chnLbl == "") {
    return -1;
  }
  auto trigChn =
      std::find_if(vecTriggedPnts.begin(), vecTriggedPnts.end(),
                   [&chnLbl](auto &pair) { return pair.first == chnLbl; });
  auto range = hzi::msEvtCnf.validRange;
  auto pulWid = hzi::msEvtCnf.pulsWid;
  auto index = 0;
  while (index < trigChn->second.size() - pulWid + 1) {
    if (trigChn->second[index + pulWid - 1] - trigChn->second[index] ==
        pulWid - 1) {
      auto trigAt = trigChn->second[index];
      if (validTrig(vecTriggedPnts, chnLbl, trigAt)) {
        return trigAt;
      }
    }
    index++;
  }
  return -1;
}

// 多通道触发, 耗时太长，缓用
tl::expected<std::pair<string, uint16_t>, string>
checkMSEvt1(const DataFrame &df) {
  // cout << "check ms events\n";
  if (df.emitting()) {
    return tl::make_unexpected("this is a emitting frame");
  }
  auto cLabels = df.chnLabels();

  int32_t *p32 = (int32_t *)df.upData.get();

  // 找出所有超过阈值的数据点, 放进vecTriggedPnts
  vector<s_vui_t> vecTriggedPnts;
  for (int i = 0; i < df.channels(); i++) {
    if (i > cLabels.size() - 1) {
      df.print("in checkMSEvt1 问题帧");
      break;
    }
    if (!hzi::msEvtCnf.msThrldsMap[cLabels[i]].second) { // 跳过不触发通道
      continue;
    }

    auto label = cLabels[i];
    int32_t *data = p32 + i * df.points();
    for (uint16_t j = 0; j < df.points(); j++) {
      auto val = abs(data[j] * hzi::config.voltageCoef);
      if (val >= hzi::msEvtCnf.msThrldsMap[label].first) {
        auto itr = std::find_if(
            vecTriggedPnts.begin(), vecTriggedPnts.end(),
            [&label](s_vui_t &pair) { return pair.first == label; });
        if (itr == vecTriggedPnts.end()) {
          vecTriggedPnts.push_back(std::make_pair(label, vector<uint16_t>{j}));//label通道第一次存
        } else {
          itr->second.push_back(j);//触发点j放到itr->second中
        }
      }
    }
  }

  // cout << "trigged chns:" << vecTriggedPnts.size() << "\n";
  if (vecTriggedPnts.size() < hzi::msEvtCnf.msTrigChns) {
    return tl::make_unexpected("no ms event in this data frame");//计算得到的触发通道数小于配置的触发通道数，返回无微震事件
  }

  // 查找最先触发通道
  using sip = std::pair<string, int>;

  // 只有一个通道有触发（特别地，触发通道数为1时）
  if (vecTriggedPnts.size() == 1 && hzi::msEvtCnf.msTrigChns == 1) {
    auto &trigPnts = vecTriggedPnts[0].second;//取出该通道的触发点
    for (int i = 0; i <= trigPnts.size() - hzi::msEvtCnf.msTrigWin; i++) {
      if (trigPnts[i + hzi::msEvtCnf.msTrigWin - 1] ==
          trigPnts[i] + hzi::msEvtCnf.msTrigWin - 1) {
        return sip{vecTriggedPnts[0].first, i};
      }
    }
    return tl::make_unexpected("no ms event in this data frame");
  }

  // 并行计算, 查找最先触发通道
  sip firstTrig = std::transform_reduce(
      std::execution::par, vecTriggedPnts.begin(), vecTriggedPnts.end(),
      sip{"", 1e10},
      [](sip a, sip b) {
        if (a.first == "" || a.second < 0)
          return b;
        if (b.first == "" || b.second < 0)
          return a;
        return a.second < b.second ? a : b;
      },
      [&vecTriggedPnts](const s_vui_t chn) -> sip {
        return std::make_pair(chn.first, validTrig(vecTriggedPnts, chn.first));
      });

  // cout << "firstTrig:" << firstTrig.first << ":" << firstTrig.second <<
  // "\n";

  if (firstTrig.first != "" && firstTrig.second >= 0) {
    return firstTrig;
  } else {
    return tl::make_unexpected("no ms event in this data frame");
  }
}

tl::expected<DataFrame, string>
whenMSEvtFound(DataFrame &df, const std::pair<string, uint16_t> pair) {
  try {
    auto trigPnt = pair.second;
    int16_t dif = trigPnt - hzi::msEvtCnf.msAheadPnt;

    if (dif < 0) {
      // std::scoped_lock<std::mutex> lck(msMtx);
      if (lastMSFrm.upData != nullptr && lastMSFrm.endTime() == df.sampTime() &&
          lastMSFrm.channels() == df.channels()) { // 2帧都包含事件，用上一帧
        return std::move(lastMSFrm).shift(df, df.points() + dif);
      } else {
        return tl::expected<DataFrame, string>(std::move(df));
      }
    } else if (dif > 0) {
      // std::scoped_lock<std::mutex> lck(msMtx);
      msPntsNeeded = dif;
      lastMSFrm = std::move(df);
      return tl::make_unexpected("waiting for next frame");
    } else {
      return std::move(df);
    }
  } catch (std::exception &e) {
    return tl::make_unexpected(string("post_handler/whenMSEvtFound error:") +
                               e.what());
  }
}

tl::expected<int, string> handleMSEvent(DataFrame df) {
  // 必要时从背景再生成一个事件
  if (hzi::config.msDevs > 1) {
    auto conn = hzi::config.pConnPool->getConnection();
    string sql("select dev_id from e_data_frm_info where class_id=3 and "
               "samp_time>=from_unixtime(");
    sql += std::to_string(df.sampTime() / 1000.0 - 5.0);
    sql += ") limit 1";
    auto rslt = conn.executeQuery(sql.c_str());
    if (rslt.next()) {
      uint8_t devMask = rslt.getInt("dev_id");
      if (devMask != df.devMask()) {
        auto exp = MSDataFrame::digEventFromBg(df.sampTime());
        if (exp) {
          auto msdf = std::move(exp.value());
          if (!hzi::config.disableMslocating && hzi::config.ms_locating) {
            ms_locating1(msdf);
          }
        }
      }
    }
  }

  if (!hzi::config.disableMslocating && hzi::config.ms_locating) {
    return ms_locating1(df);
  } else {
    return 0;
  }
}

tl::expected<int, string> setTrigChn(DataFrame &df, string trigLbl) {
  uint8_t trigDevId = atoi(trigLbl.substr(1, 1).c_str());//形如：S1GR01
  uint8_t trigChnNo = atoi(trigLbl.substr(4, 2).c_str());
  auto conn = hzi::config.pConnPool->getConnection();
  return cmd::queryDb(conn,
                      "select min(chn_no) from e_chns_config where type_id=0 "
                      "and dev_id=?",
                      trigDevId)
      .and_then([&](zdb::ResultSet rslt) -> tl::expected<int, string> {
        auto minChn = rslt.getInt("min(chn_no)");
        trigChnNo += (minChn - 1);//加上最小的微震通道号？
        df.setHeadValue<uint8_t>(17, trigDevId);//基站号
        df.setHeadValue<uint8_t>(16, trigChnNo);//触发通道的通道号
        df.setClassId(2);//微震事件
        return 0;
      });
}

tl::expected<DataFrame, string> digMsEvent() {
  if (hzi::frameQueues.size(7) < 3) {
    return tl::make_unexpected("full ms data not ready.");
  }

  std::scoped_lock<std::mutex> lck(msMtx);
  DataFrame firstFrm = std::move(hzi::frameQueues.pop(7));
  DataFrame const &secFrm = hzi::frameQueues.top(7);//const DataFrame&

  auto chkExp =
      hzi::config.multiChnTrig ? checkMSEvt1(secFrm) : checkMSEvt(secFrm);
  if (!chkExp) {
    return tl::expected<DataFrame, string>(
        tl::make_unexpected("no event found"));
  }
  auto pair = chkExp.value();
  trigChnLabel = pair.first;

  //超前点处理，得到微震事件帧
  if (pair.second < hzi::msEvtCnf.msAheadPnt) {
    auto dif = secFrm.points() - (hzi::msEvtCnf.msAheadPnt - pair.second);
    return std::move(firstFrm.shift(secFrm, dif));//firstFrm前移dif个点，尾部dif个点从secFrm前部复制补齐
  } else {
    auto dif = pair.second - hzi::msEvtCnf.msAheadPnt;
    auto frsFrm = std::move(hzi::frameQueues.pop(7));
    DataFrame const &frm2 = hzi::frameQueues.top(7);
    auto evtFrm = std::move(frsFrm.shift(frm2, dif));
    hzi::frameQueues.push(7, std::move(frsFrm));//为什么又放回去了？
    return std::move(evtFrm);
  }
}

}; // namespace
tl::expected<int, string> reCheckMSEvt_bj(DataFrame df) {
  // 尝试提取事件
  std::scoped_lock<std::mutex> lck(msMtx);
  // DataFrame df1 = std::move(df);
  auto chkExp = hzi::config.multiChnTrig ? checkMSEvt1(std::move(df))
                                         : checkMSEvt(std::move(df));
  if (!chkExp) {
    return tl::expected<int, string>(tl::make_unexpected("no event found"));
  }
  return df.save().and_then(
      [&](auto r) { return handleMSEvent(std::move(df)); });
}
tl::expected<int, string> handleData(DataFrame df) {
  if (hzi::config.verbose && df.isMerged()) {
    df.print("合并帧");
  }
  return df
      .save()
      // return df.preprocess()
      // .and_then([&](auto r) { return df.save(); })
      .and_then([&](auto r) -> tl::expected<int, string> {
        switch (df.classId()) {
        case 0:
          // tfang
          // 自电会实时回调，此时检查激发是否发射完成，如果完成则处理矢量电法
          if (!hzi::config.disableAppResis) {
            auto tp = std::chrono::system_clock::now();
            auto minutes = std::chrono::duration_cast<std::chrono::minutes>(
                               tp - hzi::lastEeTp)
                               .count();
            if (!hzi::isVecDataHandled && minutes > 15) {
              hzi::isVecDataHandled = true;
              auto startTp = tp - std::chrono::minutes(80);
              auto endTp = tp - std::chrono::minutes(10);
              std::thread(handleAllRawData, startTp, endTp).detach();
            }
          }
        case 3://微震背景或全时
        case 6: 
        {
          if ((df.classId() == 3) && (hzi::config.ms_mining_type != 0 &&df.devMask() == hzi::sysDevMask)) 
          {
            df.clone()//深拷贝
                .map([&](DataFrame df1) { createEngDensity(df1); })
                .map_error([&](auto err) {
                  std::stringstream ss;//ss<<err;？
                  logErr(ss.str());
                });
          }
          if ((hzi::config.ms_mining_type == 2) &&
              (!hzi::config.ms_tunnel_listen) &&
              df.classId() == hzi::mining_classId) {
            auto timestamp = df.sampTime();
            handleTimeStamp(timestamp);
          }
          // if (hzi::config.ms_mining_type == 1) {
          //     auto timestamp = df.sampTime();
          //     handleTimeStamp(timestamp);
          // }
          if (hzi::config.ms_mining_type == 2 && hzi::config.ms_tunnel_listen) {//随掘掘锚机通信
            // 实时处理处理随掘信号
            auto timestamp = df.sampTime();
            handleTimeStamp_tunnel(timestamp);
          }
          // if (hzi::config.ms_mining_type == 2 &&
          //     hzi::config.warningType == 2) {
          //     auto timestamp = df.sampTime();
          //     handleTimeStamp(timestamp);
          // }
          createDensity(df);

          //是微震全时数据帧且开启微震定位且激电不在采集，向下执行
          if (df.classId() != 6 || !hzi::config.ms_locating || df.emitting())
            return 0;

          // 放到队列里等待提取事件
          hzi::frameQueues.push(7, std::move(df));//合并后的全时微震帧队列，用于提取微震事件

          // 尝试提取事件
          return digMsEvent()
              .and_then([&](auto evtFrm) {
                {
                  hzi::serverStatus.lastSampTimes[2] = evtFrm.sampTime();//微震事件上次采样时间
                  std::scoped_lock<std::mutex> lck(msMtx);
                  setTrigChn(evtFrm, trigChnLabel);
                }
                if (hzi::config.verbose) {
                  evtFrm.print("抽取事件");
                }
                return evtFrm.save().and_then(
                    [&](auto r) { return handleMSEvent(std::move(evtFrm)); });
              })
              .or_else([&](auto r) { return tl::expected<int, string>(0); });
        }
        case 2://微震事件
          if (!df.isMerged()) {
            df.setMerged();
          }
          return handleMSEvent(std::move(df));
        case 5:
          break;
        case 1:
           if(!hzi::autoHandleEEdata){
              hzi::autoHandleEEdata = true;
              hzi::autoHandleStartTime = std::chrono::steady_clock::now(); // 记录开始时间
              // 创建一个分离的线程来延迟执行，不会阻塞主流程
              std::thread([fromsampTime = ee_handler::getTimeStamp()]() {
                  // 延迟20分钟
                  std::this_thread::sleep_for(std::chrono::minutes(20));
                  debugLog("开始执行自动处理激电数据");
                  // 20分钟后执行数据处理
                  if(fromsampTime!= 0){
                    //ee_handler::createTriangleFile(fromsampTime);
                    if (hzi::config.ms_ee_rslt_to_svg)
                      ee_mining::autoHandleData(fromsampTime);
                    if( hzi::config.tunnel_ee_rslt_auto)
                      ee_handler::autoHandleData(fromsampTime);
                  }
                  hzi::autoHandleEEdata = false;
              }).detach();  // 分离线程，让它在后台独立运行
          }else{
            // 检查是否超时（比如超过30分钟强制重置）
            auto now = std::chrono::steady_clock::now();
            auto elapsed = std::chrono::duration_cast<std::chrono::minutes>(
                now - hzi::autoHandleStartTime).count();
            if (elapsed > 30) {
                debugLog("检测到自动处理超时，强制重置标志");
                hzi::autoHandleEEdata = false;
            }
          }
          
          if (!hzi::config.disableAppResis) {
            // tfang 新的发射进行时，矢量电法不能处理，但需要记录最新的发射时间
            hzi::isVecDataHandled = false;
            hzi::lastEeTp =
                std::chrono::system_clock::now() + std::chrono::seconds(5);
            return calculateResistivity(std::move(df));
          }
          break;
        case 4:
          break;
        default:
          break;
        }

        return 0;
      })
      .or_else([&](auto e) {
        return tl::expected<int, string>(
            tl::make_unexpected(string("post_handler/handleData error:") + e));
      });
}
```
```cpp
//data_density.hpp
#ifndef DATADENSITY_HPP
#define DATADENSITY_HPP

#include <memory>
#include <mutex>
#include <string>

#include "DataFrame.hpp"

void createDensity(const DataFrame& df);
void createEngDensity(const DataFrame& df);
time_t midnight(uint64_t timestamp);
void createTunnelFile(const char* data,size_t dLen);
#endif
```
```cpp
//data_density.cpp
#include "data_density.hpp"
#include "Config.hpp"
#include "common.hpp"
#include "mio.hpp"

#include <fstream>
#include <iomanip>
#include <map>

namespace hzi {
std::map<string, uint8_t> chnState;  // 以label表示的通道状态（所有基站的所有通道）
};
namespace {
std::map<std::pair<uint8_t, uint8_t>, mio::mmap_sink> densityMMaps;//内存映射文件写入操作类
std::mutex densityMtx;
std::error_code denMMErr;//错误码

// 所有基站的所有通道数
int totalChannels(uint classId) {
    int sum = 0;
    for (auto& dev : hzi::config.devicesMap) {
        sum += dev.second.dataChns[classId];
    }
    return sum;
}

int handle_denMMErr(const std::error_code& error) {
    const auto& errmsg = error.message();
    std::printf("error mapping file: %s, exiting...\n", errmsg.c_str());
    return error.value();
}

}  // namespace
time_t midnight(uint64_t timestamp) {
    time_t tmt = timestamp / 1000;
    tm* pTM = localtime(&tmt);
    pTM->tm_hour = 0;
    pTM->tm_min = 0;
    pTM->tm_sec = 0;
    auto midnight_timet = mktime(pTM) * 1000;
    return midnight_timet;
}

/// @brief 创建密度文件，并映射到densityMMaps
/// @param classId 
/// @param durationNo 
/// @param filePath 
/// @param channels 
/// @param pixelWidth 
void setupDensityFile(uint8_t classId,
                      uint16_t durationNo,
                      fs::path const& filePath,
                      uint8_t channels,
                      uint16_t pixelWidth) {
    std::unique_lock<std::mutex> lck(densityMtx);
    auto key = std::make_pair(classId, durationNo);

    if (fs::exists(filePath)) {
        if (!densityMMaps.contains(key) || !densityMMaps[key].is_mapped()) {//key不存在或未将文件成功映射到内存
            densityMMaps[key] = mio::make_mmap_sink(
                filePath.string(), 0, mio::map_entire_file, denMMErr);//工厂方法创建mmap_sink对象，将filePath从文件偏移量为0处映射整个文件到内存
            if (denMMErr) {
                handle_denMMErr(denMMErr);
            }
        }
    } else {
        auto parent = filePath.parent_path();
        if (!fs::exists(parent)) {
            fs::create_directories(parent);
        }
        std::ofstream ofs(filePath, std::ios::binary | std::ios::out);
        // auto size = pixelWidth * channels * 4;

        // 扩展：最值 int32_t，数据点数 uint32_t，和int64_t
        auto size = pixelWidth * channels * 16;
        std::vector<char> values(size, 0);
        if (ofs.is_open()) {
            ofs.write((const char*)&values[0], size);
            ofs.close();
        }

        if (densityMMaps.contains(key) && densityMMaps[key].is_mapped()) {
            densityMMaps[key].sync(denMMErr);//已有内容同步到磁盘
            if (denMMErr) {
                handle_denMMErr(denMMErr);
            }
            densityMMaps[key].unmap();//解除映射
        }

        densityMMaps[key] = mio::make_mmap_sink(filePath.string(), 0,
                                                mio::map_entire_file, denMMErr);//重新映射
        if (denMMErr) {
            handle_denMMErr(denMMErr);
        }
    }
}
// 铁建随掘，截割电流，截割高程，进刀量保存！
void createTunnelFile(const char* data, size_t dLen) {
    auto sampTime = nowMS();
    uint64_t midnite = midnight(sampTime);
    uint64_t offSampTime = sampTime - midnite;  // 当日相对采样时刻(ms)
    uint32_t samp_time = static_cast<uint32_t>(offSampTime);
    auto len = dLen + 4;
    auto pdata = std::make_unique<char[]>(len);
    char* pData = pdata.get();
    *(uint32_t*)(pData) = samp_time;
    memcpy(pData + 4, data, dLen);  // 数据区

    // cout<<" samp_time = "<<std::dec<<samp_time<<" , offSampTime =
    // "<<std::dec<<offSampTime<<endl;
    auto classid = 30;
    auto filename = string("digest_tunnel.dat");
    fs::path tunnel_filepath(hzi::config.dataRoot);

    tunnel_filepath /=
        relLocFromTime(sampTime) / std::to_string(classid) / filename;

    auto dir = tunnel_filepath.parent_path();
    if (!fs::exists(dir)) {
        fs::create_directories(dir);
    }
    std::ofstream ofs(tunnel_filepath,
                      std::ofstream::binary | std::ofstream::app);
    //  ofs << samp_time;
    //  ofs.write((char*)samp_time,4);
    ofs.write(pData, len);
    ofs.close();

    return;
}
// 向平均能量文件写数据
void createEngDensity(const DataFrame& df) {
    char* pHead = df.upHead.get();
    auto classId = df.classId();

    // 密度图只考虑微震背景
    //  if (classId != 0 && classId != 3 && classId != 6) {
    if (classId != 3) {
        return;
    }
    auto pnts = df.points();

    // auto channels = df.channels();
    auto channels = totalChannels(classId);//所有基站的用于某类型数据的通道总数
    auto intvl = df.sampIntvl();
    int32_t* p32 = (int32_t*)df.upData.get();

    uint64_t sampTime = df.sampTime();

    uint64_t midnite = midnight(sampTime);
    uint64_t offSampTime = sampTime - midnite;  // 当日相对采样时刻(ms)
    // string msgStr ="sampTime =  " + std::to_string(sampTime) + " ,
    // offSampTime = " + std::to_string(offSampTime); msgStr +=", channels =
    // "+std::to_string(channels); logInfo(msgStr);
    auto absPath = hzi::config.dataRoot / relLocFromTime(sampTime) /
                   std::to_string(classId);

    auto chLabels = df.chnLabels();

    int maxDensity = 8;
    auto times = safePow(2, maxDensity);
    // cout<<"times = "<<times<<" , maxDensity = "<<maxDensity<<endl;
    uint32_t pixelWidth = 24 * times;
    auto filename = string("digest_") + std::to_string(times) + ".dat";
    setupDensityFile(classId, times, fs::path(absPath / filename), channels,
                     pixelWidth);

    //均值去除，将数据转换为零均值的形式（计算所有数据点的平均值，然后将每个数据点的值减去这个平均值）
    for (int ch = 0; ch < channels; ch++) {
        if (hzi::chnState[chLabels[ch]] != 0) {//坏道
            continue;
        }
        int64_t sum = 0;
        for (int pt = 0; pt < pnts; pt++) {
            sum += p32[ch * pnts + pt];
        }
        double avg = static_cast<double>(sum) / pnts;  // 计算浮点数平均值

        // 注意：这里的 avg 可能是小数，而 p32 存储的是整数，所以这里直接使用
        // double 类型的 avg
        for (int pt = 0; pt < pnts; pt++) {
            double diff = static_cast<double>(p32[ch * pnts + pt]) - avg;
            p32[ch * pnts + pt] = static_cast<int32_t>(diff);  // 转换为整数类型
        }
    }

    // int32_t curVal;
    for (int i = 0; i < pnts; i++) {
        double time = ((double)offSampTime + i * intvl) / 1000.0;

        auto div = safePow(2, maxDensity);
        uint16_t du = std::floor(time * div / 3600);
        auto key = std::make_pair(classId, div);
        uint32_t pixelWidth = 24 * div;
        auto size1 = channels * pixelWidth * 4;
        auto size2 = channels * pixelWidth * 8;
        auto size3 = channels * pixelWidth * 16;
        auto filepath =
            absPath / (string("digest_") + std::to_string(div) + ".dat");

        int chn = -1;
        for (int k = 0; k < hzi::config.devicesMap.size(); k++) {  // 按站处理
            if (((int)safePow(2, k) & df.devMask()) > 0) {
                for (int l = 0;
                     l < hzi::config.devicesMap[k + 1].dataChns[classId]; l++) {
                    chn++;
                    if (chn > chLabels.size() - 1 ||
                        hzi::chnState[chLabels[chn]] != 0) {  // 坏道不参与统计
                        continue;
                    }
                    auto kk = chn * pnts + i;
                    auto loc = (chn * pixelWidth + du) * 4;  // 存放最值
                    auto loc1 =
                        channels * pixelWidth * 4 + loc;  // 存放数据点数
                    auto loc2 =
                        channels * pixelWidth * 4 * 2 +
                        (chn * pixelWidth + du) * 8;  // 存放绝对值累计和
                    {
                        std::scoped_lock<std::mutex> lck(densityMtx);
                        if (loc < size1 - 4 &&
                            std::abs(p32[kk]) >
                                std::abs(*(int32_t*)&densityMMaps[key][loc])) {
                            *(int32_t*)&densityMMaps[key][loc] =
                                p32[kk];  // 最大（小）值
                        }
                        if (loc1 < size2 - 4) {
                            *(uint32_t*)&densityMMaps[key][loc1] =
                                *(uint32_t*)&densityMMaps[key][loc1] +
                                1;  // 数据点数
                        }
                        if (loc2 < size3 - 8) {
                            *(int64_t*)&densityMMaps[key][loc2] =
                                *(uint64_t*)&densityMMaps[key][loc2] +
                                std::abs(p32[kk]);  // 数据累加
                        }
                    }
                }
            }
        }
    }
    return;
}

// 向密度文件写数据
void createDensity(const DataFrame& df) {
    char* pHead = df.upHead.get();
    auto classId = df.classId();

    // 密度图只考虑自电、微震背景和微震全时
    //  if (classId != 0 && classId != 3 && classId != 6) {
    if (classId != 0 && classId != 3) {
        return;
    }
    auto pnts = df.points();
    // auto channels = df.channels();
    auto channels = totalChannels(classId);
    auto intvl = df.sampIntvl();
    int32_t* p32 = (int32_t*)df.upData.get();
    uint64_t sampTime = df.sampTime();

    uint64_t midnite = midnight(sampTime);
    uint64_t offSampTime = sampTime - midnite;  // 当日相对采样时刻(ms)

    auto absPath = hzi::config.dataRoot / relLocFromTime(sampTime) /
                   std::to_string(classId);

    auto chLabels = df.chnLabels();

    for (int i = 0; i <= hzi::config.maxDensity; i++) {
        uint8_t times = safePow(2, i);
        uint32_t pixelWidth = 24 * times;
        auto filename = string("digest_") + std::to_string(times) + ".dat";
        setupDensityFile(classId, times, fs::path(absPath / filename), channels,
                         pixelWidth);
    }

    // int32_t curVal;
    for (int i = 0; i < pnts; i++) {
        double time = ((double)offSampTime + i * intvl) / 1000.0;
        for (int j = 0; j <= hzi::config.maxDensity; j++) {
            uint8_t div = safePow(2, j);//1h分成的时间间隔数？
            uint16_t du = std::floor(time * div / 3600);//time在24h时间被分成间隔后的索引(time/3600)*div
            auto key = std::make_pair(classId, div);
            uint32_t pixelWidth = 24 * div;//一个通道24h分成的时间间隔数
            auto size1 = channels * pixelWidth * 4;
            auto size2 = channels * pixelWidth * 8;
            auto size3 = channels * pixelWidth * 16;
            auto filepath =
                absPath / (string("digest_") + std::to_string(div) + ".dat");

            int chn = -1, chnsB4Devs = 0;
            for (int k = 0; k < hzi::config.devicesMap.size(); k++) {  // 按站处理
                chnsB4Devs += k > 0 ? hzi::config.devicesMap[k].dataChns[classId] : 0;//第k-1基站的通道个数
                if (((int)safePow(2, k) & df.devMask()) > 0) {
                    for (int l = 0;l < hzi::config.devicesMap[k + 1].dataChns[classId];l++) {
                        chn++;
                        if (chn > chLabels.size() - 1 ||
                            hzi::chnState[chLabels[chn]] != 0) {  // 坏道不参与统计
                            continue;
                        }
                        auto kk = chn * pnts + i;//当前点索引，用于从df中取数据
                        auto ll = chnsB4Devs + l;//当前通道索引
                        auto loc = (ll * pixelWidth + du) * 4;  // 存放最值
                        // auto loc = (chn * pixelWidth + du) * 4;  // 存放最值
                        auto loc1 = channels * pixelWidth * 4 + loc;  // 存放数据点数
                        // auto loc2 = channels * pixelWidth * 4 * 2 +
                        //             (chn * pixelWidth + du) * 8;  //
                        //             存放累计和
                        auto loc2 = channels * pixelWidth * 4 * 2 +
                                    (ll * pixelWidth + du) * 8;  // 存放累计和
                        {
                            std::scoped_lock<std::mutex> lck(densityMtx);
                            if (loc < size1 - 4 &&
                                std::abs(p32[kk]) >
                                    std::abs(
                                        *(int32_t*)&densityMMaps[key][loc])) {
                                *(int32_t*)&densityMMaps[key][loc] =
                                    p32[kk];  // 最大（小）值
                            }
                            if (loc1 < size2 - 4) {
                                *(uint32_t*)&densityMMaps[key][loc1] =
                                    *(uint32_t*)&densityMMaps[key][loc1] +
                                    1;  // 数据点数
                            }
                            if (loc2 < size3 - 8) {
                                *(int64_t*)&densityMMaps[key][loc2] =
                                    *(uint64_t*)&densityMMaps[key][loc2] +
                                    p32[kk];  // 数据累加
                            }
                        }
                    }
                }
            }
            // for (int k = 0; k < channels; k++) {
            //     if (hzi::chnState[chLabels[k]] != 0) {  //坏道不参与统计
            //         continue;
            //     }
            //     auto kk = k * pnts + i;
            //     auto loc = (k * pixelWidth + du) * 4;         //存放最值
            //     auto loc1 = channels * pixelWidth * 4 + loc;  //存放数据点数
            //     auto loc2 = channels * pixelWidth * 4 * 2 +
            //                 (k * pixelWidth + du) * 8;  //存放累计和
            //     {
            //         std::scoped_lock<std::mutex> lck(densityMtx);
            //         if (loc < size1 - 4 &&
            //             std::abs(p32[kk]) >
            //                 std::abs(*(int32_t*)&densityMMaps[key][loc])) {
            //             *(int32_t*)&densityMMaps[key][loc] =
            //                 p32[kk];  //最大（小）值
            //         }
            //         if (loc1 < size2 - 4) {
            //             *(uint32_t*)&densityMMaps[key][loc1] =
            //                 *(uint32_t*)&densityMMaps[key][loc1] +
            //                 1;  //数据点数
            //         }
            //         if (loc2 < size3 - 8) {
            //             *(int64_t*)&densityMMaps[key][loc2] =
            //                 *(uint64_t*)&densityMMaps[key][loc2] +
            //                 p32[kk];  //数据累加
            //         }
            //     }
            // }
        }
    }
    return;
}
```
```cpp
//ms_mining.hpp
#ifndef MSMINING_HPP
#define MSMINING_HPP

#include "tl/expected.hpp"

#include "DataFrame.hpp"
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"
#include "algorithms/msl/KmeansCluster.hpp"
#include "algorithms/msl/PCOSignalProcess.hpp"
//#include "post_handler.hpp"
#include "ms_writeImage.hpp"
#include "data_density.hpp"
struct ParmEngDenity{
    float minValue;  //单位mv
    float maxValue;
    float rate;
    float locX = 0.0; // 回采位置
    int wn;   // 时窗 -- 分钟
    int chnno;
    float low;
    int engWn; //时窗内的平均能量
    float wnEngValue;   
   // std::vector<int>chnList;
};
//统一的处理方法数据结构
// struct ProcessingMethod {
//     std::string type;               // 方法类型
//     rapidjson::Document* pData;     // 

//     ProcessingMethod(const std::string& t, rapidjson::Document* pD) : type(t), pData(pD) {}

//    // 析构函数，注意释放内存
//     ~ProcessingMethod() {
//         if (pData) {
//             delete pData;
//             pData = nullptr;
//         }
//     }
// };
struct ProcessingMethod {
    std::string type;                        // 方法类型
    std::unique_ptr<rapidjson::Document> pData; // 使用 std::unique_ptr 管理指针，指向 JSON 数据的指针

    // 构造函数接受指针所有权的转移
    ProcessingMethod(const std::string& t, rapidjson::Document* pD) : type(t), pData(pD) {}

    // 析构函数无需手动释放，std::unique_ptr 会自动处理
};
/// @brief 滤波参数
	struct PCOFilterParm
	{
		int isCut = 0;    //是否滤波 0无滤波，1时域滤波 2频域滤波
		int convLen = 100;  // 卷积长度（后端参数）（时域滤波使用）
		float  loCutF = 10; //低截频 （开放参数）
	//    float  loFltF ;  //低滤频  （通过带宽计算）
	//    float  hiFltF ;  //高滤频  （通过带宽计算）
	   float  hiCutF = 300;  //高截频（开放参数）
	   float tranBW = 10 ;   //带宽
	   int isStop = 0;    //滤波类型  false 带通滤波  true 带阻滤波
	   int wndFlag = 0;   //窗函数标记
	   
	   int isNotchCut = 0;  //是否陷波
	   int notchF = 50;   //陷波值 默认50hz
	   int isNotch_n = 1;  // 是否陷波整数倍 
	   int Notch_jobs = 0; //陷波剔除50hz的奇偶倍数，0-整数倍，1-奇数倍，2-偶数倍
	   int NotchWn = 5; // 陷波频率宽度
	   int NotchType = 0;  // 陷波类型；0-剔除赋值0，1-线性插值
	};
	/// @brief 反褶积
	struct PCOSpikeDeconvolution
	{
		bool isSpikeDeconvolution = false;  // 是否执行反褶积
		int spikeDeCoeLen = 2000 ;  //反褶积 时因子系数长度
		int dcovLetPoint = 100 ; //子波长度(时间单位ms)
		float deconvCoef = 1; // 白化系数
	};
	/// @brief 道内均衡
	struct PCODeAGC
	{
		int deAGCtype = 0; //道内均衡计算类型（0-无，1-AGC平衡，2-指数增益）
		int wnLen = 100;  //窗口宽度(时间单位ms) 
		float expGainAlpha = 5.0f;	//指数增益衰减系数
	};
	/// @brief 反射波提取
	struct PCOCalRandon
	{
		//反射波提取
		bool isCalRandon = false;//是否进行反射波提取
		float fScale = 0.5f;  //正变换后提取的最大能量百分比
		float fPMin = 0.5f;  //最小正变换P
		float fPMax = 4.0f;   //最大正变换P
		float fPSpace = 0.05f ;  //P间隔
		int bNegtiveV = 0; //bNegtiveV：如果保留负速度为true, 保留正速度为 false 
		float mining_fx = 0.0;//震源坐标
		float mining_fy = 0.0 ;
		float mining_fz = 0.0 ;
	};
	/// @brief 偏移参数
	struct PCOMigration
	{
		//偏移 PCOMigrationImage
	    int ampType = 1; //幅度类型  （ 0 振幅叠加，1 能量叠加（绝对值））
		int wndType = 1;  //窗口类型：（单点，半波长）
		int normalizedType = 0; //归一化类型：（不归一，沿巷道走向归一化）	

	};
	
	

tl::expected<DataFrame, string> mergeMs(uint64_t fromsampTime,uint64_t endsampTime,int dev_id);
string handleSignalProcess(std::vector<DataFrame*> dfVec,bool flag,int dev_id = 0);
//string handleSignalProcess(const DataFrame df);
void handleCSVFile(string path);
void testCreateFile(int startIndex,int endIndex);
void threadHanleData(uint64_t fromsampTime, uint64_t endsampTime, int len,int dev_id);
void handleTimeStamp(uint64_t tm);
void handleTimeStamp_tunnel(uint64_t tm);
void threadHanleData_tunnel(uint64_t fromsampTime, uint64_t endsampTime, int len);

tl::expected<DataFrame, string> mergeMs_tunnel(uint64_t fromsampTime,uint64_t endsampTime);
string handleSignalProcess_test(float **pData,int point,int chns,float deltT,int prepoint);
void getWarningInfo(); //异常预警
std::vector<int> parseString(const std::string& input);
void test_scan();
void mergeEngDenity(uint64_t fromsampTime,uint64_t endsampTime);
void readEngDenity(uint64_t fromsampTime,uint64_t endsampTime,int channels,int classId,std::vector<ParmEngDenity> engParmList,bool flag);

bool getWnEng(uint64_t fromsampTime,uint64_t endsampTime,int channels,int classId,int chnno,float &sumvalue,uint64_t &points);
string getEngDenityParm(uint64_t fromsampTime,uint64_t endsampTime,int channels,int classId,bool flag);
bool matchValue(std::map<int,std::vector<float>> datamap,std::vector<ParmEngDenity> engParmList);
string handleExtSignalData(uint64_t tmStmp,int typeId);
string handleExtSignalData_pianyi(uint64_t fromsampTime,uint64_t endsampTime);
string processMethods(uint64_t tmStmp,int typeId,const std::vector<ProcessingMethod>& methods);

string test_mining(float **pData,int point,int valCount,float deltT,int prepoint);
void getCSPTrace(uint64_t tmStamp,float **pData,std::vector<PureCommonOperation::PCOCalChn> pcoCalChnParms,
        PureCommonOperation::CSPTraceParm &cspParm,PureCommonOperation::PCOLocParm pcoLocParm,
        PureCommonOperation::PCOExtractChn pChn_ext,int surLineNum);
string GetChnInfo(uint64_t tmStamp,int devId,int systemeType,int ImageType);
void getChnLoc_history(vector<float>& value, uint64_t tmStmp,string chnLabel);
void setPCOCalChn(vector<PureCommonOperation::PCOCalChn>& pcoCalChnParms,
                  int devId,
                  uint64_t tmStmp,bool flag);
void setSignalChnInfo(PureCommonOperation::PCOExtractChn &pcoExtractChnParms,
                     std::vector<PureCommonOperation::PCOCalChn> pcoCalChnParms,
                     PureCommonOperation::PCOSignalParm pcoParm,int chns);

tl::expected<string,string> selfCorrSpectrum(uint64_t fromsampTime, uint64_t endsampTime, uint64_t timeSegment, int dev_id=0, bool isRealTime=false);
tl::expected<bool,string> mergeByTimeSegment(std::vector<std::unique_ptr<DataFrame>>& mergeResult,uint64_t fromSampTime,uint64_t endSampTime,int timeSegmentMinute,int dev_id);
tl::expected<string, string> saveInsert(float** pData, uint64_t tmStmp, int channelNum, int outLenInsert, float frequencyResolution, const std::string& fileName);
tl::expected<string, string> saveFile11(float** pData, uint64_t tmStmp,float frequencyResolution, int channelNum, int dexNum, int outLen, int devId, PureCommonOperation::PCOSignalParm pcoParm, PureCommonOperation::PCOLocParm pcoLocParm);
#endif
```
```cpp
//ms_mining.cpp
#include "ms_mining.hpp"

#include "ms_locator.hpp"

#include <filesystem>
#include "Config.hpp"

#include "common.hpp"
#include "ProcessingData.hpp"
namespace fs = std::filesystem;
using std::to_string;

bool contains(double x0, double y0, GeologyStruct geology)
{
    bool ret = false;
    if (x0 < geology.x_min || x0 > geology.x_max || y0 < geology.y_min ||
        y0 > geology.y_max)
        return ret;
    int i, j, crossings = 0, c = 0;
    for (i = 0, j = geology.locVec.size() - 1; i < geology.locVec.size();
         j = i++)
    {
        double slope = (geology.locVec[i][1] - geology.locVec[j][1]) /
                       (geology.locVec[i][0] - geology.locVec[j][0]);
        bool cond1 =
            (geology.locVec[j][0] <= x0) && (x0 < geology.locVec[i][0]);
        bool cond2 =
            (geology.locVec[i][0] <= x0) && (x0 < geology.locVec[j][0]);
        bool above =
            (y0 < slope * (x0 - geology.locVec[j][0]) + geology.locVec[j][1]);

        if ((cond1 || cond2) && above)
            crossings++;

        if (((geology.locVec[i][1] > y0) != (geology.locVec[j][1] > y0)) &&
            (x0 < (geology.locVec[j][0] - geology.locVec[i][0]) *
                          (y0 - geology.locVec[i][1]) /
                          (geology.locVec[j][1] - geology.locVec[i][1]) +
                      geology.locVec[i][0]))
        {
            c++;
        }
    }
    ret = crossings % 2;

    return ret;
}
// 根据回采位置确定x坐标
float getLocX(float x)
{
    return x;
}

/*
* 存表e_tunnel_lineInfo。结合表e_tunnel_threshold，共同得出异常提取结果，存表e_tunnel_errorinfo。
* 查表e_tunnel_errorinfo绘制到【巷道探测示意图】。
*/
void saveLine(uint64_t sampTime,
              std::vector<PureCommonOperation::ELINE> lineVec,
              PureCommonOperation::PCOLocParm pcoLocParm,
              int is_real)
{
    auto conn = hzi::config.pConnPool->getConnection();
    float gLen = (pcoLocParm.interface_type == 0) ? pcoLocParm.m_dYGrdLen
                                                  : pcoLocParm.m_dZGrdLen;
    float y_Min = (pcoLocParm.interface_type == 0) ? pcoLocParm.m_dYMin
                                                   : pcoLocParm.m_dZMin;

    cout << "当前回采位置： " << pcoLocParm.m_locx << " Y/Z 精度：" << gLen
         << " y_Min = " << y_Min << " ;异常提取结果：" << lineVec.size()
         << endl;

    string sqlstr3 =
        "DELETE FROM e_tunnel_lineInfo where samp_time = " +
        std::to_string((double)sampTime);
    conn.execute(sqlstr3.c_str());
    if (lineVec.size() == 0)
        return;

    PreparedStatement prp = conn.prepareStatement(
        "INSERT INTO  e_tunnel_lineInfo "
        "(samp_time,id,mining_locx,mining_dir,begin_x,begin_y,"
        "end_x,end_y,fXPos,fAngle,mid_x,mid_y,beginTrace_x,beginTrace_y,"
        "endTrace_x,endTrace_y,"
        "is_real,is_used ) "
        "values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) ");
    conn.beginTransaction();

    for (uint8_t i = 0; i < lineVec.size(); i++)
    {
        // auto begin_x = pcoLocParm.m_locx + lineVec[i].fBeginTime;
        auto begin_x = pcoLocParm.m_dXMin + lineVec[i].fBeginTime;
        auto begin_y = lineVec[i].nBeginTrace * gLen + y_Min;
        auto end_x = pcoLocParm.m_dXMin + lineVec[i].fEndTime;
        auto end_y = lineVec[i].nEndTrace * gLen + y_Min;
        auto mid_x = (begin_x + end_x) / 2;
        auto mid_y = (begin_y + end_y) / 2;

        cout << " save  第 " << i + 1 << " 个：起点：("
             << lineVec[i].fBeginTime << ","
             << lineVec[i].nBeginTrace * gLen << "); 实际坐标：(" << begin_x
             << " , " << begin_y << ") ; "
             << " 终点:(" << lineVec[i].fEndTime << ","
             << lineVec[i].nEndTrace * gLen << "); 实际坐标：（" << end_x
             << " , " << end_y << ") ; " << endl;

        // if (mid_y < 0)
        //     continue;  // 剔除对称点

        prp.bind(1, (double)sampTime);
        prp.bind(2, i + 1);
        prp.bind(3, pcoLocParm.m_locx);
        prp.bind(4, pcoLocParm.m_dir);
        prp.bind(5, begin_x);
        prp.bind(6, begin_y);
        prp.bind(7, end_x);
        prp.bind(8, end_y);
        prp.bind(9, lineVec[i].fXPos);
        prp.bind(10, lineVec[i].fAngle);

        prp.bind(11, mid_x);
        prp.bind(12, mid_y);
        prp.bind(13, lineVec[i].fBeginTime);
        prp.bind(14, lineVec[i].nBeginTrace * gLen);
        prp.bind(15, lineVec[i].fEndTime);
        prp.bind(16, lineVec[i].nEndTrace * gLen);
        prp.bind(17, is_real);
        prp.bind(18, 0);
        prp.execute();
    }
    conn.commit();
}
//////////////////////
// flag 速度模型 0-匀速模型，1-层状模型
void getSpeedArry(int iGrdNum,
                  float *&pSpeedBtr,
                  PureCommonOperation::PCOLocParm pcoLocParm,
                  int useVType,
                  float speedP,
                  float speedS,
                  float coalZ,
                  float layformZ, bool flag)
{
    // cout<<" hzi::config.ms_mining_type = "<<hzi::config.ms_mining_type<<endl;

    // 获取速度值
    auto dXGrdLen = pcoLocParm.m_dXGrdLen;
    auto dYGrdLen = pcoLocParm.m_dYGrdLen;
    auto dZGrdLen = pcoLocParm.m_dZGrdLen;
    int i, j, k;
    double dCurX = 0, dCurY = 0, dCurZ = 0;
    // int geonum = 0;
    int YGrdNum = pcoLocParm.m_iYGrdNum;
    int ZGrdNum = pcoLocParm.m_iZGrdNum;
    // 添加构造，岩性
    if (hzi::config.ms_interface_type == 0)
    {
        YGrdNum = pcoLocParm.m_iYGrdNum;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        YGrdNum = pcoLocParm.m_iZGrdNum;
    }
    if (hzi::config.ms_interface_type == 2)
    {
        YGrdNum = pcoLocParm.m_iYGrdNum;
    }
    // hzi::config.ms_mining_type == 2 &&
    if (flag)
    {
        auto conn = hzi::config.pConnPool->getConnection();
        auto wf_height = 1.0;
        auto rslt02 = conn.executeQuery("SELECT wf_height FROM `e_info` ");
        if (rslt02.next())
        {
            wf_height = rslt02.getDouble("wf_height");
        }
        float speed_F = speedP;
        float speed_C = speedP;
        float speed_R = speedP;
        auto rslt03 = conn.executeQuery(
            "SELECT e_tunnel_geology_info.label, "
            "e_geology_info.vp,e_geology_info.vs,e_geology_info.lithology "
            " FROM  e_tunnel_geology_info  LEFT JOIN  `e_geology_info` on  "
            "e_tunnel_geology_info.lithologyId = e_geology_info.id WHERE "
            "e_tunnel_geology_info.positionId = 1");
        while (rslt03.next())
        {
            string labelStr = rslt03.getString("label");
            if (labelStr == "C")
            {
                if (useVType == 0)
                    speed_C = rslt03.getDouble("vp");
                if (useVType == 1)
                    speed_C = rslt03.getDouble("vs");
            }
            else if (labelStr == "R")
            {
                if (useVType == 0)
                    speed_R = rslt03.getDouble("vp");
                if (useVType == 1)
                    speed_R = rslt03.getDouble("vs");
            }
            else if (labelStr == "F")
            {
                if (useVType == 0)
                    speed_F = rslt03.getDouble("vp");
                if (useVType == 1)
                    speed_F = rslt03.getDouble("vs");
            }
        }
        //     cout<<"pcoLocParm.interface_type =
        //     "<<pcoLocParm.interface_type<<endl;
        float gLen_1 = (pcoLocParm.interface_type == 0) ? pcoLocParm.m_dYGrdLen
                                                        : pcoLocParm.m_dZGrdLen;
        float y_Min = (pcoLocParm.interface_type == 0) ? pcoLocParm.m_dYMin
                                                       : pcoLocParm.m_dZMin;
        auto R_z = coalZ + wf_height; // 顶板

        int num_F = int((coalZ - layformZ) / gLen_1);
        int num_C = int(wf_height / gLen_1);
        int num_R = YGrdNum - num_F - num_C;
        if (hzi::config.verbose)
        {
            cout << " num_F = " << num_F << " ,num_C = " << num_C
                 << " , num_R = " << num_R << " , coalZ = " << coalZ
                 << " , layformZ = " << layformZ
                 << " , wf_height = " << wf_height << " , gLen_1 = " << gLen_1
                 << endl;
        }

        for (int i = 0; i < iGrdNum; i++)
        {
            if (i < num_F * pcoLocParm.m_iXGrdNum)
            {
                pSpeedBtr[i] = speed_F; // 底板
            }
            else if (i >= num_F * pcoLocParm.m_iXGrdNum &&
                     i < (num_C + num_F) * pcoLocParm.m_iXGrdNum)
            {
                pSpeedBtr[i] = speed_C; // 煤层
            }
            else
            {
                pSpeedBtr[i] = speed_R; // 顶板
            }
        }
    }
    else
    {
        //  cout<<" 匀速模型 "<<endl;
        for (int i = 0; i < iGrdNum; i++)
        {
            if (useVType == 0)
                pSpeedBtr[i] = speedP;
            if (useVType == 1)
                pSpeedBtr[i] = speedS;
        }
    }

    if (hzi::config.ms_interface_type == 0)
    {
        for (j = 0; j < pcoLocParm.m_iYGrdNum; ++j)
        {
            dCurY = pcoLocParm.m_dYMin + j * dYGrdLen;
            for (k = 0; k < pcoLocParm.m_iXGrdNum; ++k)
            {
                dCurX = pcoLocParm.m_dXMin + k * dXGrdLen;
                int iCurGrdPos = j * pcoLocParm.m_iXGrdNum + k;
                for (auto &geologymap : hzi::miningGeologyStructMap)
                {
                    if (contains(dCurX, dCurY, geologymap.second))
                    {
                        if (useVType == 0)
                        {
                            pSpeedBtr[iCurGrdPos] = geologymap.second.speed_p;
                        }
                        else
                        {
                            pSpeedBtr[iCurGrdPos] = geologymap.second.speed_s;
                        }

                        continue;
                    }
                }
            }
        }
    }
    else if (hzi::config.ms_interface_type == 1)
    {
        for (j = 0; j < pcoLocParm.m_iZGrdNum; ++j)
        {
            dCurZ = pcoLocParm.m_dZMin + j * dZGrdLen;
            ;
            for (k = 0; k < pcoLocParm.m_iXGrdNum; ++k)
            {
                dCurX = pcoLocParm.m_dXMin + k * dXGrdLen;
                int iCurGrdPos = j * pcoLocParm.m_iXGrdNum + k;
                for (auto &geologymap : hzi::miningGeologyStructMap)
                {
                    if (contains(dCurX, dCurZ, geologymap.second))
                    {
                        // pSpeedBtr[iCurGrdPos] = geologymap.second.speed_p;
                        if (useVType == 0)
                        {
                            pSpeedBtr[iCurGrdPos] = geologymap.second.speed_p;
                        }
                        else
                        {
                            pSpeedBtr[iCurGrdPos] = geologymap.second.speed_s;
                        }

                        continue;
                    }
                }
            }
        }
    }
    else if (hzi::config.ms_interface_type == 2)
    {
        for (i = 0; i < pcoLocParm.m_iZGrdNum; ++i)
        {
            dCurZ = pcoLocParm.m_dZMin + i * dZGrdLen;
            for (j = 0; j < pcoLocParm.m_iYGrdNum; ++j)
            {
                dCurY = pcoLocParm.m_dYMin + j * dYGrdLen;
                for (k = 0; k < pcoLocParm.m_iXGrdNum; ++k)
                {
                    dCurX = pcoLocParm.m_dXMin + k * dXGrdLen;
                    int iCurGrdPos =
                        i * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iXGrdNum +
                        j * pcoLocParm.m_iXGrdNum + k;
                    for (auto &geologymap : hzi::miningGeologyStructMap)
                    {
                        if (contains(dCurX, dCurY, geologymap.second))
                        {
                            pSpeedBtr[iCurGrdPos] = geologymap.second.speed_p;

                            continue;
                        }
                    }
                }
            }
        }
    }
    // auto tmStmp = nowMS();
    // std::ofstream outSignalFile;
    //     string csvFileName = "test/outData/outdate_";
    //     csvFileName+=std::to_string(tmStmp)+".csv";

    //     //outFile.open("test/outdate.csv", std::ios::out); // 打开模式可省略
    //     outSignalFile.open(csvFileName.c_str(), std::ios::out); //
    //     outSignalFile <<pcoLocParm.m_iXGrdNum<<','<<
    //     YGrdNum<< std::endl;

    //     for(int ch = 0;ch<YGrdNum;ch++)
    //     {
    //         for(int  pnt =0;pnt<pcoLocParm.m_iXGrdNum;pnt++ )
    //         {
    //             int itrdex = ch*pcoLocParm.m_iXGrdNum + pnt;
    //             outSignalFile << pSpeedBtr[itrdex]<< ',';
    //         }
    //         outSignalFile<< std::endl;

    //     }
    //     outSignalFile.close();
}


/*
* 保存偏移图的10类型数据文件
* fg：是否是实时计算，历史计算异常不提取结果。从偏移数据，提取异常调用函数saveLine()
* typeId：用于分量类型 0-X 1-Y 2-Z
* outType：输出类型，0-偏移图 1-反射界面输出
*/
bool saveResult(uint64_t tmStmp,
                int devId,
                int iGrdNum,
                PureCommonOperation::PCOLocParm pcoLocParm,
                float *&pOut,
                int typeId,
                bool fg, bool outType)
{
    bool flag = false;

    auto conn = hzi::config.pConnPool->getConnection();

    if (hzi::config.ms_mining_type == 2)
    { 
        // hzi::config.ms_mining_type == 2
        // 异常提取

        std::unique_ptr<float[]> pOut_2(new float[iGrdNum]);
        memset(pOut_2.get(), 0, sizeof(float) * iGrdNum);

        std::vector<PureCommonOperation::ELINE> lineVec;
        int flNum = 1;
        PureCommonOperation::EXTRACTPARA m_extractPara;
        m_extractPara.Reset();

        auto rslt_ext = conn.executeQuery(
            "SELECT * FROM e_tunnel_extractPara WHERE is_init = 0");
        if (!rslt_ext)
        {
            std::cerr << "Query returned no results." << std::endl;
            //  return;
        }
        if (rslt_ext.next())
        {
            m_extractPara.fAmpleScale = rslt_ext.getDouble("fAmpleScale");
            m_extractPara.fOverlapScale = rslt_ext.getDouble("fOverlapScale");
            m_extractPara.iMaxPlanes = rslt_ext.getInt("iMaxPlanes");
            m_extractPara.bExtAmple = rslt_ext.getInt("bExtAmple");
            m_extractPara.bExtNum = rslt_ext.getInt("bExtNum");
            m_extractPara.iAmpExtType = rslt_ext.getInt("iAmpExtType");
            m_extractPara.iNumExtType = rslt_ext.getInt("iNumExtType");
            m_extractPara.inputMaxEng = rslt_ext.getDouble("inputMaxEng");
        }

        //pOut中存偏移图数据，经过反射波提取，数据存于pOut_2
        PureCommonOperation::ReflactPlane(pOut, pOut_2.get(), flNum, &pcoLocParm,
                                          m_extractPara, &lineVec);

        //若成图：反射界面图，则把pOut_2拷贝到pOut。
        //若成图：偏移图，不拷贝，直接用pOut中数据进行后续写文件操作。
        if (outType)
        {
            memcpy(pOut, pOut_2.get(), sizeof(float) * iGrdNum);
        }

        float gLen = (pcoLocParm.m_dYGrdLen > pcoLocParm.m_dZGrdLen)
                         ? pcoLocParm.m_dYGrdLen
                         : pcoLocParm.m_dZGrdLen;

        if (hzi::config.verbose)
        {
            cout << "当前回采位置： " << pcoLocParm.m_locx
                 << " Y/Z 精度：" << gLen << ";异常提取结果：" << endl;
            for (int i = 0; i < lineVec.size(); i++)
            {
                // 先按照X Y 面计算

                cout << "   第 " << i + 1 << "个：起点坐标：(" << lineVec[i].fBeginTime << ","
                     << lineVec[i].nBeginTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fBeginTime << " ; " << lineVec[i].fXPos << " ; "
                     << "终点坐标:(" << lineVec[i].fEndTime << ","
                     << lineVec[i].nEndTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fEndTime << "; " << lineVec[i].fEndTime << endl;
            }
        }

        //异常提取
        if (fg)
        {
            saveLine(tmStmp, lineVec, pcoLocParm, fg);
        }
    }

    int XGrdNum =
        int(pcoLocParm.mark_len / pcoLocParm.m_dXGrdLen);
    int YGrdNum = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_iZGrdNum : pcoLocParm.m_iYGrdNum;

    auto iGrdNum_out =
        XGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;


    //pOut数据截取，存于pOut_0
    std::unique_ptr<float[]> pOut_0(new float[iGrdNum_out]);
    memset(pOut_0.get(), 0, sizeof(float) * iGrdNum_out);
    cout << "pcoLocParm.m_dir = " << pcoLocParm.m_dir << ",XGrdNum = " << XGrdNum << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
         << ",YGrdNum = " << YGrdNum << endl;
    // 截取偏移图数据
    for (int j = 0; j < YGrdNum; ++j)
    {
        for (int k = 0; k < pcoLocParm.m_iXGrdNum; ++k)
        {
            if (pcoLocParm.m_dir == 0)
            {
                // 取后面的数据
                if (k >= pcoLocParm.m_iXGrdNum - XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k - pcoLocParm.m_iXGrdNum + XGrdNum;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
            else
            {
                if (k < XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
        }
    }
    float minpOut = *std::min_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    float maxpOut = *std::max_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    // 有异常的位置拉起来能量
    cout << " XGrdNum = " << XGrdNum << " m_iYGrdNum = " << pcoLocParm.m_iYGrdNum << " pcoLocParm.m_iZGrdNum = " << pcoLocParm.m_iZGrdNum << endl;

    float dX = pcoLocParm.m_dXGrdLen;
    float dY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZGrdLen : pcoLocParm.m_dYGrdLen;
    float minY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZMin : pcoLocParm.m_dYMin;
    //  cout<<"dX =  "<<dX<<",dy= "<<dY<<",minY = "<<minY<<endl;

    int32_t *p32 = (int32_t *)pOut_0.get();
    unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
    char *pHead = pHeadData.get();
    *(double *)(pHead) = (double)tmStmp;
    auto classId = *(uint8_t *)(pHead + 8) = 10;//classid置10，偏移图
    *(uint8_t *)(pHead + 9) = devId;
    *(uint16_t *)(pHead + 10) = XGrdNum;
    // *(uint16_t*)(pHead + 10) = pcoLocParm.m_iXGrdNum;
    *(uint16_t *)(pHead + 12) = pcoLocParm.m_iYGrdNum;
    *(uint16_t *)(pHead + 14) = pcoLocParm.m_iZGrdNum;
    *(int32_t *)(pHead + 16) = *((int32_t *)&minpOut);
    *(int32_t *)(pHead + 20) = *((int32_t *)&maxpOut);
    *(int32_t *)(pHead + 24) = *((int32_t *)&dX);

    // auto conn3 = hzi::config.pConnPool->getConnection();
    //插入库表，保存偏移图数据文件路径
    conn.execute(
        "INSERT INTO "
        "e_mining_pcodata_frm_info "
        "(dev_id,samp_time,class_id,XGrdNum,YGrdNum,ZGrdNum,frm_loc,validity)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE XGrdNum= values(XGrdNum),YGrdNum= "
        "values(YGrdNum),validity=values(validity) ",
        (uint8_t)devId,        // dev_id
        tmStmp / 1000.0,       // samp_time
        classId,               // class_id
        XGrdNum,               // curt_ch  pcoLocParm.m_iXGrdNum XGrdNum
        pcoLocParm.m_iYGrdNum, // channels
        pcoLocParm.m_iZGrdNum, // ch_pnts
        (relLocFromTime(tmStmp) / std::to_string(classId) / std::to_string(tmStmp)).c_str(), // frm_loc
        0   //validity=0无效
    );  

    auto classId2 = (typeId == 0) ? 10 : (100 + typeId);//单分量文件名类型写10，多分量写100+typeId

    //10类型文件文件名
    fs::path fileName(hzi::config.dataRoot);
    fileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                std::to_string(tmStmp);

    //写10类型文件（pOut_0中数据）
    try
    {
        auto dir = fileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs(fileName, std::ofstream::binary);
        ofs.write(pHead, 32);
        ofs.write((char *)p32, iGrdNum_out * 4);
        //  ofs.write((char*)p32, iGrdNum * 4);
        ofs.close();
        flag = true;
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += fileName.string();
        msg += ":";
        msg += e.what();
        debugErr(msg);
        cout << msg << endl;
        return flag;
    };

    //配置文件中读取字段，是否保存偏移图svg文件到目录下
    if (hzi::config.ms_rslt_to_image)
    {
        //   cout<<" writeSvg "<<minpOut<<" , "<<maxpOut<<endl;
        string path = fileName.string() + ".svg";

        if (std::filesystem::exists(path))
        {
            fs::remove(path);
        }
        writeSvg(path, pOut_0.get(), XGrdNum, YGrdNum, dX, dY, pcoLocParm.m_dXMin, minY, 13);
        //  cout<<" end writeSvg "<<path <<endl;
    }
    return flag;
}


void testCreateFile(int startIndex, int endIndex)
{
    int Num = 10;
    auto sampTime = nowMS();
    string csvFileName = "test/outData/outdate_";
    csvFileName += std::to_string(sampTime) + ".bin";
    fs::path fileName(csvFileName);
    auto dir = fileName.parent_path();
    if (!fs::exists(dir))
    {
        fs::create_directories(dir);
    }
    std::ofstream ofs(fileName, std::ofstream::binary);
    int len = 19;
    auto pdata = std::make_unique<char[]>(len);
    char *pData = pdata.get();
    int mining_locX = startIndex;
    int followBytes = 12;
    int jd = 1000;
    int gc = 3000;
    int dl = 3800;

    uint32_t head = 0x86968696;
    *(uint32_t *)(pData) = be32toh(head);
    *(uint8_t *)(pData + 4) = 0x03;
    *(uint16_t *)(pData + 5) = be16toh(followBytes);
    *(uint8_t *)(pData + 7) = 0x00;
    *(uint8_t *)(pData + 8) = 0x05;
    *(uint16_t *)(pData + 9) = be16toh(mining_locX);
    *(uint16_t *)(pData + 11) = be16toh(jd);
    *(uint16_t *)(pData + 13) = be16toh(gc);
    *(uint16_t *)(pData + 15) = be16toh(dl);
    uint16_t tail = 0x1818;
    *(uint16_t *)(pData + 17) = be16toh(tail);
    for (int j = 0; j < 20; j++)
    {
        ofs.write(pData, 19);
    }

    for (int i = startIndex; i < endIndex; i++)
    {
        gc -= 100;
        *(uint8_t *)(pData + 7) = 0x01;
        *(uint16_t *)(pData + 9) = be16toh(i);
        *(uint16_t *)(pData + 11) = be16toh(jd);
        *(uint16_t *)(pData + 13) = be16toh(gc);
        *(uint16_t *)(pData + 15) = be16toh(dl);

        for (int j = 0; j < Num; j++)
        {
            ofs.write(pData, 19);
        }
        if (i % 10 == 0)
        {
            // 一刀结束
            *(uint8_t *)(pData + 7) = 0x00;
            gc = 3000;
            for (int j = 0; j < Num * 2; j++)
            {
                ofs.write(pData, 19);
            }
        }
    }
    ofs.close();

    return;
}
/**
 * 先从e_chns_config_history选取历史数据，还可以选取历史通道状态状态，暂时先不用
 * 为空就从e_chns_config_tunnel选择
 */
void getChnLoc_history(vector<float> &value, uint64_t tmStmp, string chnLabel)
{

    auto conn = hzi::config.pConnPool->getConnection();
    double dateTime = double(tmStmp / 1000);

    string sqlstr_history = "SELECT * FROM  `e_chns_config_history` WHERE updatetime < FROM_UNIXTIME(?) and chn_label = '" + chnLabel + "'ORDER BY updatetime DESC limit 1 ";
    auto rslt0 = conn.executeQuery(sqlstr_history.c_str(), dateTime);
    if (rslt0.next())
    {
        auto x = rslt0.getDouble("loc_x");
        auto y = rslt0.getDouble("loc_y");
        auto z = rslt0.getDouble("loc_z");
        value.push_back(x);
        value.push_back(y);
        value.push_back(z);
    }
    else
    {
        // string sqlstr = "SELECT * FROM  `e_chns_config_tunnel` WHERE driving_date < FROM_UNIXTIME(?) and chn_label = '" + chnLabel + "'ORDER BY driving_date DESC limit 1 ";

        // auto rslt = conn.executeQuery(sqlstr.c_str(), dateTime);
        // if (rslt.next())
        // {
        //     auto x = rslt.getDouble("loc_x");
        //     auto y = rslt.getDouble("loc_y");
        //     auto z = rslt.getDouble("loc_z");
        //     value.push_back(x);
        //     value.push_back(y);
        //     value.push_back(z);
        // }
    }

    // cout<<"dateTime = "<<std::to_string(dateTime)<<" chnLabel = "<<chnLabel<<endl;
}
void setPCOCalChn(vector<PureCommonOperation::PCOCalChn> &pcoCalChnParms,
                  int devId,
                  uint64_t tmStmp, bool flag)
{
    // cout<<"setPCOCalChn:  tmStmp = "<<std::to_string(tmStmp)<<endl;
    auto devtmp = devId;
    std::vector<bool> isGetDataList;
    for (int i = 0; i < 8; i++) // 最多8个基站
    {
        isGetDataList.push_back(false);
    }
    for (int i = 8; i > 0; i--)
    {
        int m = safePow(2, i - 1);
        int index = devtmp / m;
        if (index > 0)
        {
            isGetDataList[i - 1] = true;
            devtmp = devtmp % m;
        }
    }
    for (int i = 0; i < isGetDataList.size(); i++)
    {
        bool isGetData = isGetDataList[i];
        if (isGetData)
        {
            for (auto &msItr : hzi::msChannelsConfigsMap)
            {
                string msLabal = msItr.first;
                if (msLabal.substr(0, 2) == "S" + std::to_string(i + 1))
                {
                    PureCommonOperation::PCOCalChn chn;
                    // if(flag){
                    //     chn.x = msItr.second.locX;
                    //     chn.y = msItr.second.locY;
                    //     chn.z = msItr.second.locZ;
                    // }else
                    if (true)
                    {
                        vector<float> val;
                        getChnLoc_history(val, tmStmp, msLabal);
                        if (val.size() == 3)
                        {
                            chn.x = val[0];
                            chn.y = val[1];
                            chn.z = val[2];
                        }
                        else
                        {
                            chn.x = msItr.second.locX;
                            chn.y = msItr.second.locY;
                            chn.z = msItr.second.locZ;
                        }
                    }

                    chn.enb = hzi::msEvtCnf.msThrldsMap[msLabal].second;
                    chn.chnlabel = msLabal;
                    pcoCalChnParms.push_back(chn);

                    // cout<<"x:"<<chn.x<<" ; y: "<<chn.y<<" ; z: "<<chn.z<<" ;chn.enb = "<<chn.enb
                    //  <<" ; chnlabel: "<<chn.chnlabel<<endl;
                }
            }
        }
    }

    // 设置属性
    auto conn = hzi::config.pConnPool->getConnection();
    if (hzi::config.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            auto chn_no = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            auto is_out = rslt_comp.getInt("is_out");

            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                }
            }
        }
    }

    // 设置测线属性
    if (1)
    {
        auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
        while (rslt_surveyLine.next())
        {
            auto id = rslt_surveyLine.getInt("id");
            auto chnsList = rslt_surveyLine.getString("chnsList");
            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].id = id; // 测线id
                                                     //   cout<<" 通道号："<<num<<" 测线："<<id<<endl;
                }
            }
        }
    }
}
// 速度扫描参数
struct PCOSpeedParm
{
    uint64_t samp_time; // 采集时间戳
    float mining_locx;  // 回采位置
    int mining_dir;     // 回采方向
    float vp = 0;
    float vs = 0;
    float x;     // 异常坐标
    float y;     // 异常坐标
    float z = 0; // 异常坐标
    float fAngle;
};
struct ERRORInfoParm
{
    float locX;     // 里程
    int mining_dir; // 回采方向
    int type = 0;   // 反射波类型 纵波 0、横波 1、导波
    float vp = 2;
    float vs = 1;
    float x;     // 异常坐标
    float y;     // 异常坐标
    float z = 0; // 异常坐标
    float fAngle;
    float rate = 2.0; // p/s波速比
    float bsb;        // 泊松比
    float lm;         // 拉梅常数
    float p;          // 密度
    float jqml;       // 剪切模量
    float tjysml;     // 体积压缩模量
    float ysml;       // 杨氏模量
};
float GetMaxSpeed(float *pData, int len, float speed, float dv, float tv)
{
    float max = speed - dv;
    if (len < 1)
        return max;
    float vp_max = pData[0];
    for (int i = 0; i < len; i++)
    {
        if (pData[i] > vp_max)
        {
            vp_max = pData[i];
            max = speed - dv + i * tv;
        }
    }
    return max;
}
float GetDensity(float vp)
{
    return 0.31 * (pow(vp, 1.0 / 4));
}
// 拉梅常数 p是密度
float GetLM(float p, float vp, float vs)
{
    return p * (vp * vp - 2 * vs * vs);
}
// 剪切模量
float GetJQML(float p, float vs)
{
    return p * vs * vs;
}
// 体积压缩模量
float GetTJYSML(float p, float vp, float vs)
{
    return p * (vp * vp - (4.0 / 3) * vs * vs);
}
// 泊松比
float GetBSB(float vp, float vs)
{
    return 0.5 * (vp * vp - 2 * vs * vs) / (vp * vp - vs * vs);
}
// 杨氏模量
float GetYSML(float p, float vp, float vs)
{
    return p * vs * vs * (3 * vp * vp - 4 * vs * vs) / (vp * vp - vs * vs);
}
void saveErrInfoTable(std::vector<ERRORInfoParm> parmvec)
{
    auto ms = nowMS();
    auto conn = hzi::config.pConnPool->getConnection();
    try
    {
        PreparedStatement prp = conn.prepareStatement(
            "INSERT INTO "
            " e_tunnel_errorInfo "
            "(mining_locx,mining_dir,signal_type,mid_x,mid_y,mid_z,"
            "fAngle,vp,vs,rate,deni,bsb,lmcs,jqml,tjml,ysml,samp_time) "
            " values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
        conn.beginTransaction();
        for (int i = 0; i < parmvec.size(); i++)
        {
            prp.bind(1, parmvec[i].locX);
            prp.bind(2, parmvec[i].mining_dir);
            prp.bind(3, parmvec[i].type);
            prp.bind(4, round(parmvec[i].x * 100) / 100);
            prp.bind(5, round(parmvec[i].y * 100) / 100);
            prp.bind(6, round(parmvec[i].z * 100) / 100);
            prp.bind(7, round(parmvec[i].fAngle * 100) / 100);
            prp.bind(8, parmvec[i].vp);
            prp.bind(9, parmvec[i].vs);
            prp.bind(10, parmvec[i].rate);
            prp.bind(11, parmvec[i].p);
            prp.bind(12, parmvec[i].bsb);
            prp.bind(13, parmvec[i].lm);
            prp.bind(14, parmvec[i].jqml);
            prp.bind(15, parmvec[i].tjysml);
            prp.bind(16, parmvec[i].ysml);
            prp.bind(17, (double)ms);
            prp.execute();
        }
        conn.commit();
        hzi::serverStatus.lastSampTimes[11] = ms;
    }
    catch (sql_exception &e)
    {
        cout << " e_tunnel_errorInfo 写库出错:" << e.what() << endl;
    }
    catch (std::exception &e)
    {
        cout << " e_tunnel_errorInfo 写库出错:" << e.what() << endl;
    }
}
void handleScanSpeed(std::vector<PCOSpeedParm> &speedParmVec,
                     std::vector<ERRORInfoParm> &errInfoParmVec)
{
    auto conn = hzi::config.pConnPool->getConnection();
    cout << "handleScanSpeed  " << speedParmVec.size() << endl;
    for (int speed_dex = 0; speed_dex < speedParmVec.size(); speed_dex++)
    {
        auto samp_time = speedParmVec[speed_dex].samp_time;
        auto mining_locx = speedParmVec[speed_dex].mining_locx;
        auto mining_dir = speedParmVec[speed_dex].mining_dir;
        long long ts = 0;
        cout << " samp_time = " << std::to_string(samp_time) << endl;
        // auto rslt1 = conn.executeQuery(
        //     "SELECT  ROUND(UNIX_TIMESTAMP(driving_date),3) as ts FROM "
        //     "`e_chns_config_tunnel` WHERE driving_date < FROM_UNIXTIME(?) "
        //     "  ORDER BY driving_date DESC limit 1 ",
        //     (double)samp_time / 1000.0);
        auto rslt1 = conn.executeQuery(
            "SELECT ROUND(UNIX_TIMESTAMP(driving_date),3) as ts FROM "
            "`e_chns_config_history` WHERE driving_date < FROM_UNIXTIME(?) "
            "  ORDER BY driving_date DESC limit 1 ",
            (double)samp_time / 1000.0);
        if (rslt1.next())
        {
            ts = (long long)(rslt1.getDouble("ts"));
        }
        if (ts == 0)
        {
            continue;
        }

        int devNum = hzi::config.devicesMap.size(); // 基站数量
        std::vector<bool> isGetDataList;
        isGetDataList.clear();
        for (int i = 0; i < devNum; i++) // 最多8个基站
        {
            isGetDataList.push_back(true);
        }
        std::map<string, ChanelsConfig> ms_ChannelsConfigsMap; // 多基站微震
        ms_ChannelsConfigsMap.clear();
        ms_ChannelsConfigsMap = hzi::msChannelsConfigsMap;

        auto rslt2 = conn.executeQuery(
            "SELECT * from e_chns_config_history where driving_date = "
            "FROM_UNIXTIME(?) AND `type_id`=0",
            (double)ts);
        while (rslt2.next())
        {
            auto chn_label = rslt2.getString("chn_label");
            auto loc_x = rslt2.getDouble("loc_x");
            auto loc_y = rslt2.getDouble("loc_y");
            auto loc_z = rslt2.getDouble("loc_z");
            ms_ChannelsConfigsMap[chn_label].locX = loc_x;
            ms_ChannelsConfigsMap[chn_label].locY = loc_y;
            ms_ChannelsConfigsMap[chn_label].locZ = loc_z;
        }
        vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
        for (int i = 0; i < isGetDataList.size(); i++)
        {
            bool isGetData = isGetDataList[i];
            if (isGetData)
            {
                for (auto &msItr : ms_ChannelsConfigsMap)
                {
                    string msLabal = msItr.first;
                    if (msLabal.substr(0, 2) == "S" + std::to_string(i + 1))
                    {
                        PureCommonOperation::PCOCalChn chn;
                        chn.x = msItr.second.locX;
                        chn.y = msItr.second.locY;
                        chn.z = msItr.second.locZ;
                        chn.enb = hzi::msEvtCnf.msThrldsMap[msLabal].second;
                        chn.chnlabel = msLabal;

                        pcoCalChnParms.push_back(chn);
                        cout << "handleScanSpeed x:" << chn.x
                             << " ; y: " << chn.y << " ; z: " << chn.z
                             << " ; chn.enb = " << chn.enb << endl;
                    }
                }
            }
        }
        fs::path filePath(hzi::config.dataRoot);
        auto classId = 9;

        filePath /= relLocFromTime(samp_time) / std::to_string(classId) /
                    std::to_string(samp_time);
        if (!fs::exists(filePath))
        {
            continue;
        }
        std::ifstream ifs(filePath);
        unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
        char *pHead = pHeadData.get();
        auto fileSize = fs::file_size(filePath);

        // DataFrame fileDF(chns0, pnts0);
        ifs.read(pHead, 32);
        auto deltT = *(float *)(pHead + 9);
        auto vecSize = *(uint16_t *)(pHead + 17);
        auto valNum = *reinterpret_cast<int *>(pHead + 13); // chns
        auto outLen = *reinterpret_cast<int *>(pHead + 19);
        auto pretime = *(uint32_t *)(pHead + 23);

        int channels = valNum;
        int points = outLen;

        int chns = valNum / vecSize;
        cout << std::dec << "handleScanSpeed  valNum = " << valNum
             << " , vecSize = " << vecSize << " , outLen = " << outLen
             << " , chns = " << chns << endl;
        float **pData = new float *[valNum];
        float tmpf;
        for (int ch = 0; ch < channels; ++ch)
        {
            pData[ch] = new float[points];
            for (int k = 0; k < points; ++k)
            {
                ifs.read(reinterpret_cast<char *>(&tmpf), sizeof(float));
                pData[ch][k] = tmpf;
            }
        }
        ifs.close();

        // 获取速度
        int ampType = 0;
        float speed_p = speedParmVec[speed_dex].vp;
        float speed_s = speedParmVec[speed_dex].vs;
        float dv = 0.45;    // v-dv ---v+dv
        float tv = dv / 10; // 间隔
        int constSize = 20;
        float *ampArry_P = new float[constSize];
        memset(ampArry_P, 0, sizeof(float) * constSize);
        float *ampArry_S = new float[constSize];
        memset(ampArry_S, 0, sizeof(float) * constSize);

        auto rslt3 = conn.executeQuery(
            "SELECT ampType,speed_p, speed_s FROM `e_mining_PCOSignalParm`");

        if (rslt3.next())
        {
            ampType = rslt3.getInt("ampType");
            speed_p = rslt3.getDouble("speed_p");
            speed_s = rslt3.getDouble("speed_s");
        }
        cout << " speed_p = " << speed_p << "  speed_s = " << speed_s << endl;

        for (int i = 0; i < constSize; i++)
        {
            auto speed_P = speed_p - dv + i * tv;
            auto speed_S = speed_s - dv + i * tv;
            for (int itr = 0; itr < channels; ++itr)
            {
                int itrdex = itr % chns;
                if (!pcoCalChnParms[itrdex].enb)
                    continue;
                float dis = 0;

                if (hzi::config.ms_interface_type == 0)
                {
                    dis = PureCommonOperation::Distance(
                        pcoCalChnParms[itrdex].x, pcoCalChnParms[itrdex].y, 0,
                        speedParmVec[speed_dex].x, speedParmVec[speed_dex].y,
                        0);
                }
                else if (hzi::config.ms_interface_type == 1)
                {
                    dis = PureCommonOperation::Distance(
                        pcoCalChnParms[itrdex].x, pcoCalChnParms[itrdex].z, 0,
                        speedParmVec[speed_dex].x, speedParmVec[speed_dex].y,
                        0);
                }
                else if (hzi::config.ms_interface_type == 2)
                {
                    dis = PureCommonOperation::Distance(
                        pcoCalChnParms[itrdex].x, pcoCalChnParms[itrdex].y,
                        pcoCalChnParms[itrdex].z, speedParmVec[speed_dex].x,
                        speedParmVec[speed_dex].y, speedParmVec[speed_dex].z);
                }
                auto CurTime_P = dis / speed_P;
                int pDataPos_P = int(CurTime_P / deltT);
                auto CurTime_S = dis / speed_S;
                int pDataPos_S = int(CurTime_S / deltT);
                if (ampType ==
                    0) // 幅度类型  （ 0 振幅叠加，1 能量叠加（绝对值））
                {
                    if (pDataPos_P < points)
                        ampArry_P[i] += pData[itr][pDataPos_P];
                    if (pDataPos_S < points)
                        ampArry_S[i] += pData[itr][pDataPos_S];
                }
                else // if(ampType == 1)
                {
                    if (pDataPos_P < points)
                        ampArry_P[i] += fabs(pData[itr][pDataPos_P]);
                    if (pDataPos_S < points)
                        ampArry_S[i] += fabs(pData[itr][pDataPos_S]);
                }
            }
        }

        float vp_max = GetMaxSpeed(ampArry_P, constSize, speed_p, dv, tv);
        float vs_max = GetMaxSpeed(ampArry_S, constSize, speed_s, dv, tv);
        cout << " vp_max = " << vp_max << " vs_max = " << vs_max << endl;
        float p_density = GetDensity(vp_max); // 密度
        float lmcs = GetLM(p_density, vp_max, vs_max);
        float jqml = GetJQML(p_density, vs_max);
        float tjysml = GetTJYSML(p_density, vp_max, vs_max);
        float bsb = GetBSB(vp_max, vs_max);
        float ysml = GetYSML(p_density, vp_max, vs_max);

        ERRORInfoParm errInfo;
        errInfo.x = speedParmVec[speed_dex].x;
        errInfo.y = speedParmVec[speed_dex].y;
        errInfo.z = speedParmVec[speed_dex].z;
        errInfo.fAngle = speedParmVec[speed_dex].fAngle;
        errInfo.locX = speedParmVec[speed_dex].mining_locx;
        errInfo.mining_dir = speedParmVec[speed_dex].mining_dir;
        errInfo.vp = vp_max;
        errInfo.vs = vs_max;
        errInfo.type = 0;
        errInfo.rate = vp_max / vs_max;
        errInfo.bsb = bsb;
        errInfo.lm = lmcs;
        errInfo.jqml = jqml;
        errInfo.p = p_density;
        errInfo.tjysml = tjysml;
        errInfo.ysml = ysml;

        errInfoParmVec.push_back(errInfo);
    }
}
void test_scan()
{
    cout << " test_scan !" << endl;
    auto conn = hzi::config.pConnPool->getConnection();
    std::vector<PCOSpeedParm> parm;
    std::vector<ERRORInfoParm> errInfoParm;
    PCOSpeedParm speedParm;
    auto rslt = conn.executeQuery(
        "SELECT * from e_tunnel_lineInfo ORDER BY samp_time DESC limit 1");

    if (rslt.next())
    {
        speedParm.samp_time = static_cast<uint64_t>(rslt.getLLong("samp_time"));
        speedParm.mining_locx = rslt.getDouble("mining_locx");
        speedParm.mining_dir = rslt.getInt("mining_dir");
        speedParm.vp = 1;
        speedParm.vs = 0.5;
        speedParm.x = rslt.getDouble("mid_x");
        speedParm.y = rslt.getDouble("mid_y");
        speedParm.fAngle = rslt.getDouble("fAngle");
    }
    parm.push_back(speedParm);
    handleScanSpeed(parm, errInfoParm);
    saveErrInfoTable(errInfoParm);
}

bool setPCOLocParm(uint64_t sampTime, PureCommonOperation::PCOLocParm &pcoLocParm)
{
    uint64_t midnite = midnight(sampTime);
    // uint64_t tm = sampTime - midnite; // 当日相对采样时刻(ms)

    bool flag = false;
    auto conn = hzi::config.pConnPool->getConnection();
    double dayStep = 0.0;
    uint64_t timestamp = 0;

    // 获取距samptime时间最近的一次对回采位置的修改，估算sampTime时回采位置
    auto rsltLocInfoBeforeSampTimeLatest = conn.executeQuery(
        "SELECT `mining_loc`, `day_step`, UNIX_TIMESTAMP(`tmstamp`) AS tm FROM e_tunnel_locInfo"
        " WHERE UNIX_TIMESTAMP(tmstamp) <= ? ORDER BY tmstamp DESC LIMIT 1",
        (double)sampTime / 1000.0);
    if (rsltLocInfoBeforeSampTimeLatest.next())
    {
        pcoLocParm.m_locx = rsltLocInfoBeforeSampTimeLatest.getDouble("mining_loc");
        dayStep = rsltLocInfoBeforeSampTimeLatest.getDouble("day_step");
        timestamp = rsltLocInfoBeforeSampTimeLatest.getDouble("tm");
        flag = true;
    }
    else
    {
        // cout<<("【setPCOLocParm】表e_tunnel_locInfo未找到采样时刻前的记录")<<endl;
        auto rsltLocInfoAfterSampTimeLatest = conn.executeQuery(
            "SELECT `mining_loc`, `day_step`, UNIX_TIMESTAMP(`tmstamp`) AS tm FROM e_tunnel_locInfo"
            " WHERE UNIX_TIMESTAMP(tmstamp) > ? ORDER BY tmstamp ASC LIMIT 1",
            (double)sampTime / 1000.0);
        if (rsltLocInfoAfterSampTimeLatest.next())
        {
            pcoLocParm.m_locx = rsltLocInfoAfterSampTimeLatest.getDouble("mining_loc");
            dayStep = rsltLocInfoAfterSampTimeLatest.getDouble("day_step");
            timestamp = rsltLocInfoAfterSampTimeLatest.getDouble("tm");
            flag = true;
        }
        else
        {
            cout<<"【setPCOLocParm】表e_tunnel_locInfo为空..从表e_mining_PCOLocParm中查询.."<<endl;
            auto rsltPCOLocParm = conn.executeQuery(
                "SELECT mining_locx,mining_dir,mark_XLen,"
                "dXGrdLen,dYGrdLen,dZGrdLen,UNIX_TIMESTAMP(mining_date)AS tm ,day_step"
                " FROM `e_mining_PCOLocParm` ORDER BY mining_date DESC "
                "LIMIT 1");
            if (rsltPCOLocParm.next())
            {
                pcoLocParm.mark_len = rsltPCOLocParm.getDouble("mark_XLen");
                pcoLocParm.m_dXGrdLen = rsltPCOLocParm.getDouble("dXGrdLen");
                pcoLocParm.m_dYGrdLen = rsltPCOLocParm.getDouble("dYGrdLen");
                pcoLocParm.m_dZGrdLen = rsltPCOLocParm.getDouble("dZGrdLen");

                pcoLocParm.m_dir = rsltPCOLocParm.getInt("mining_dir");

                pcoLocParm.m_locx = rsltPCOLocParm.getDouble("mining_locx");
                dayStep = rsltPCOLocParm.getDouble("day_step");
                timestamp = rsltPCOLocParm.getDouble("tm");
                flag = true;
            }
            else
            {
                cout<<"【setPCOLocParm】表e_tunnel_locInfo和表e_mining_PCOLocParm均为空..";
                return false;
            }
        }    
    }

    // auto rslt1 = conn.executeQuery("SELECT `mining_dir` FROM e_tunnel1_overview");
    // if(rslt1.next())
    // {
    //     pcoLocParm.m_dir = rslt1.getInt("mining_dir");
    // }

    // // 根据时间戳在当日时刻，在细分进尺量（原本记录的回踩位置的时间戳是当日0点）
    // auto dv = dayStep / 4;
    // float t_py = 0;
    // if (tm < 6 * 60 * 60 * 1000)
    //     t_py += dv * 0;
    // if (tm >= 6 * 60 * 60 * 1000 && tm < 12 * 60 * 60 * 1000)
    //     t_py += dv * 1;
    // if (tm >= 12 * 60 * 60 * 1000 && tm < 18 * 60 * 60 * 1000)
    //     t_py += dv * 2;
    // if (tm >= 18 * 60 * 60 * 1000)
    //     t_py += dv * 3;

    // int days = floor((sampTime / 1000.0 - timestamp) / 24 / 3600);
    double days = (sampTime / 1000.0 - timestamp) / 24 / 3600; // 天数可小数，可正负
    if (hzi::config.verbose)
    {
        cout << "days= " << days << " pcoLocParm.m_locx = " << pcoLocParm.m_locx << endl;
    }
    // pcoLocParm.m_locx = (pcoLocParm.m_dir == 0) ? (pcoLocParm.m_locx + days * dayStep + t_py) : (pcoLocParm.m_locx - days * dayStep - t_py);
    pcoLocParm.m_locx = (pcoLocParm.m_dir == 0) ? (pcoLocParm.m_locx + days * dayStep) : (pcoLocParm.m_locx - days * dayStep);
    cout << "【setPCOLocParm】" << "timestamp=" << timestamp << " days=" << days << " dayStep=" << dayStep << " pcoLocParm.m_locx =" << pcoLocParm.m_locx << " heading_mil=" << hzi::heading_mil << endl;
    //findNthZeroCrossing报段错误
    return flag;
}
/// ImageType:0-散射，1-透射，2-爆炸成像'
/// systemeType 系统类型：0-双巷式，1-机载式，2-组合式' comp 分量信息
int getSignalChnCount(int systemeType, int ImageType, int line1, int line2, int line3, int comp)
{
    int retNum = 0;
    if (systemeType == 0)
    {
        if (ImageType == 0)
        {
            return (line1 * line2 + line2 * line1) / comp;
        }
        else if (ImageType == 1)
        {
            return (line1 * line1 + line2 * line2) / comp;
        }
        else if (ImageType == 2)
        {
            return (line1 + line2);
        }
    }
    else if (systemeType == 1)
    {
        if (ImageType == 0)
        {
            return (line1 * line1);
        }
        else
        {
            return (line1 * line1 + line2 * line2);
        }
    }
    else if (systemeType == 2)
    {
        if (ImageType == 0)
        {
            return (line3 * line3);
        }
        else
        {
            return (line3 * (line1 + line2));
        }
    }
}
string GetChnInfo(uint64_t tmStamp, int devId, int systemeType, int ImageType)
{
    string reStr = "{";
    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    setPCOCalChn(pcoCalChnParms, devId, tmStamp, 0);
    PureCommonOperation::PCOSignalParm pcoParm;
    pcoParm.chnno = 1;
    pcoParm.systemeType = systemeType;
    pcoParm.ImageType = ImageType;
    pcoParm.ms_mining_type = hzi::config.ms_mining_type;

    int chns = pcoCalChnParms.size();

    PureCommonOperation::PCOExtractChn pcoExtractChnParms;
    setSignalChnInfo(pcoExtractChnParms, pcoCalChnParms, pcoParm, chns);
    reStr += "\"count\":";
    reStr += std::to_string(pcoExtractChnParms.count);
    reStr += ",";
    reStr += "\"data\":[";
    for (int i = 0; i < pcoExtractChnParms.count; i++)
    {
        string tmStr = "{\"chnno\":";
        tmStr += std::to_string(pcoExtractChnParms.chnNoVec[i]);
        tmStr = tmStr + ",\"ps\":";
        string coeStr = (ImageType == 2) ? "1" : std::to_string(pcoExtractChnParms.coeChnNoVec[i]);
        tmStr += coeStr;
        if (i == pcoExtractChnParms.count - 1)
        {
            tmStr += "}";
        }
        else
        {
            tmStr += "},";
        }

        reStr += tmStr;
    }
    reStr += "]}";
    return reStr;
}

void setSignalChnInfo(PureCommonOperation::PCOExtractChn &pcoExtractChnParms,
                      std::vector<PureCommonOperation::PCOCalChn> pcoCalChnParms,
                      PureCommonOperation::PCOSignalParm pcoParm, int chns)
{
    if (pcoParm.ms_mining_type == 1)
    {
        // 随采
        for (int ch = 0; ch < chns; ch++)
        {
            auto comp = pcoCalChnParms[ch].flag;
            auto surId = pcoCalChnParms[ch].id;
            if (pcoParm.systemeType == 0)
            {
                // 双巷式
                for (int ch1 = 0; ch1 < chns; ch1++)
                {
                    if (pcoParm.ImageType == 0)
                    {
                        // 散射
                        if (pcoCalChnParms[ch1].id == surId && pcoCalChnParms[ch1].flag == comp)
                        {
                            pcoExtractChnParms.coeChnNoVec.push_back(ch + 1);
                            pcoExtractChnParms.chnNoVec.push_back(ch1 + 1);
                            pcoExtractChnParms.count++;
                            // PureCommonOperation::PCOExtractChn tmp_ExtractChn;
                            // tmp_ExtractChn.coeChnNo = ch + 1;
                            // tmp_ExtractChn.chnNo = ch1 + 1;
                            // pcoExtractChnParms.push_back(tmp_ExtractChn);
                        }
                    }
                    else if (pcoParm.ImageType == 1)
                    {
                        // 透射
                        if (pcoCalChnParms[ch1].id != surId && pcoCalChnParms[ch1].flag == comp)
                        {
                            // PureCommonOperation::PCOExtractChn tmp_ExtractChn;
                            // tmp_ExtractChn.coeChnNo = ch + 1;
                            // tmp_ExtractChn.chnNo = ch1 + 1;
                            // pcoExtractChnParms.push_back(tmp_ExtractChn);
                            pcoExtractChnParms.coeChnNoVec.push_back(ch + 1);
                            pcoExtractChnParms.chnNoVec.push_back(ch1 + 1);
                            pcoExtractChnParms.count++;
                        }
                    }
                    else if (pcoParm.ImageType == 2)
                    {
                        // 爆炸成像
                        if (ch1 == ch)
                        {
                            // PureCommonOperation::PCOExtractChn tmp_ExtractChn;
                            // tmp_ExtractChn.coeChnNo = ch + 1;
                            // tmp_ExtractChn.chnNo = ch1 + 1;
                            // pcoExtractChnParms.push_back(tmp_ExtractChn);
                            pcoExtractChnParms.coeChnNoVec.push_back(ch + 1);
                            pcoExtractChnParms.chnNoVec.push_back(ch1 + 1);
                            pcoExtractChnParms.count++;
                        }
                    }
                }
            }
            if (pcoParm.systemeType == 1)
            {
                // 机载式 后期在确定
                for (int ch1 = 0; ch1 < chns; ch1++)
                {
                    if (pcoParm.ImageType == 2)
                    {
                        // 爆炸成像
                        if (ch1 == ch)
                        {
                            // PureCommonOperation::PCOExtractChn tmp_ExtractChn;
                            // tmp_ExtractChn.coeChnNo = ch + 1;
                            // tmp_ExtractChn.chnNo = ch1 + 1;
                            // pcoExtractChnParms.push_back(tmp_ExtractChn);
                            pcoExtractChnParms.coeChnNoVec.push_back(ch + 1);
                            pcoExtractChnParms.chnNoVec.push_back(ch1 + 1);
                            pcoExtractChnParms.count++;
                        }
                    }
                    else
                    {
                        if (pcoCalChnParms[ch1].flag == comp)
                        {
                            pcoExtractChnParms.coeChnNoVec.push_back(ch + 1);
                            pcoExtractChnParms.chnNoVec.push_back(ch1 + 1);
                            pcoExtractChnParms.count++;
                            // PureCommonOperation::PCOExtractChn tmp_ExtractChn;
                            // tmp_ExtractChn.coeChnNo = ch + 1;
                            // tmp_ExtractChn.chnNo = ch1 + 1;
                            // pcoExtractChnParms.push_back(tmp_ExtractChn);
                        }
                    }
                }
            }
            if (pcoParm.systemeType == 2)
            {
                // 混合式 后期在确定
            }
        }
    }
    else
    {
        // 随掘
        for (int ch = 0; ch < chns; ch++)
        {
            pcoExtractChnParms.count++;
            pcoExtractChnParms.chnNoVec.push_back(ch + 1); 
            pcoExtractChnParms.coeChnNoVec.push_back(pcoParm.chnno);

            // if(pcoParm.extractMethod == 0)  //自相关
            // {
            //     pcoExtractChnParms.chnNoVec.push_back(ch + 1);      //相关计算通道号
            //     pcoExtractChnParms.coeChnNoVec.push_back(ch + 1);  //填充通道号对应因子道号
            // }
            // else if(pcoParm.extractMethod == 1)  //互相关
            // {
            //     pcoExtractChnParms.chnNoVec.push_back(ch + 1); 
            //     pcoExtractChnParms.coeChnNoVec.push_back(pcoParm.chnno); 
            // }
            
            // PureCommonOperation::PCOExtractChn tmp_ExtractChn;
            // tmp_ExtractChn.coeChnNo = pcoParm.chnno;
            // tmp_ExtractChn.chnNo = ch + 1;
            // pcoExtractChnParms.push_back(tmp_ExtractChn);
        }
    }

    // 设置各个分量对应的道号
    if (hzi::config.ms_components > 1)
    {
        for (int ch = 0; ch < chns; ch++)
        {
            const PureCommonOperation::PCOCalChn &chn1 = pcoCalChnParms[ch];
            if (chn1.flag != 1)
                continue;
            std::vector<int> matchlist;
            matchlist.push_back(ch + 1);

            for (int i = 1; i < hzi::config.ms_components; i++)
            {
                for (int ch2 = 0; ch2 < chns; ch2++)
                {
                    const PureCommonOperation::PCOCalChn &chn2 = pcoCalChnParms[ch2];
                    if (chn2.flag != i + 1)
                        continue;
                    if (chn2.x == chn1.x && chn2.y == chn1.x && chn2.z == chn1.z)
                    {
                        matchlist.push_back(ch2 + 1);
                        break;
                    }
                }
            }
            pcoExtractChnParms.chnListXYZ.push_back(matchlist);
        }
    }
}
string test_mining(float **pData, int point, int valCount, float deltT, int prepoint)
{
    auto tmStmp = nowMS();
    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    //  setPCOCalChn(pcoCalChnParms,1,tmStmp,1);
    int chns = 21;
    cout << "chns = " << chns << ", valCount = " << valCount << endl;
    for (int ch = 0; ch < chns; ch++)
    {
        PureCommonOperation::PCOCalChn chn;
        chn.x = ch * 10 + 5;
        chn.y = 0;
        chn.z = 0;
        chn.enb = 1;
        chn.id = 1;
        chn.flag = 1;
        pcoCalChnParms.push_back(chn);
    }

    PureCommonOperation::CSPTraceParm cspParm;
    cspParm.nComponentCount = hzi::config.ms_components;
    cspParm.iCalTraces = valCount;
    cspParm.nSamplePoints = point;
    cspParm.fSampleInterval = deltT;
    cspParm.nAdvanPoints = 0;
    cspParm.fPV = 3.5; // 3500m/s
    cspParm.fSV = 2.2; // 2200m/s

    PureCommonOperation::PCOLocParm pcoLocParm;
    pcoLocParm.mark_len = 200;
    pcoLocParm.m_dXMin = 0;
    pcoLocParm.m_dXMax = 200;

    PureCommonOperation::PCOExtractChn pChn_ext;
    pChn_ext.count = valCount;
    int ps = valCount / chns;
    for (int i = 0; i < ps; i++)
    {
        for (int j = 0; j < chns; j++)
        {
            pChn_ext.chnNoVec.push_back(j + 1);
            pChn_ext.coeChnNoVec.push_back(i + 1);
        }
    }
    // for(int i = 0;i<valCount;i++){
    //     cout<<" 因子道："<<pChn_ext.coeChnNoVec[i]<<",道号："<<pChn_ext.chnNoVec[i]<<endl;

    // }

    getCSPTrace(tmStmp, pData, pcoCalChnParms, cspParm, pcoLocParm,
                pChn_ext, 1);
    return std::to_string(tmStmp);
}
void getCSPTrace(uint64_t tmStamp, float **pData, std::vector<PureCommonOperation::PCOCalChn> pcoCalChnParms,
                 PureCommonOperation::CSPTraceParm &cspParm, PureCommonOperation::PCOLocParm pcoLocParm,
                 PureCommonOperation::PCOExtractChn pChn_ext, int surLineNum)
{
    cout << " getCSPTrace " << endl;
    // 先删除已有的CSP文件
    string path = Config::dataRoot + "/" + relLocFromTime(tmStamp).c_str() + "/CSPFolder/" + std::to_string(tmStamp);
    if (std::filesystem::is_directory(path))
    {
        fs::remove_all(path);
    }

    auto conn = hzi::config.pConnPool->getConnection();
    // float nSamplePoints,float fSampleInterval,int nAdvanPoints,
    //  PureCommonOperation::CSPTraceParm cspParm;

    string sqlstr = "SELECT * FROM `e_CalCSPTrace`";
    auto rslt = conn.executeQuery(sqlstr.c_str());
    float m_fDepth, m_fDepthIntlV = 0;
    if (rslt.next())
    {
        cspParm.fMinEOM = rslt.getDouble("fMinEOM");
        cspParm.fMaxEOM = rslt.getDouble("fMaxEOM");
        cspParm.fIntEOM = rslt.getDouble("fIntEOM");

        cspParm.nShotCount = rslt.getInt("nShotCount");
        cspParm.chCvtwvType = rslt.getInt("chCvtwvType");
        cspParm.chCalFace = rslt.getInt("chCalFace");
        cspParm.chAmpCalWay = rslt.getInt("chAmpCalWay");
        cspParm.m_bCSPUsePolar = rslt.getInt("m_bCSPUsePolar");
        cspParm.chCalWavfldType = rslt.getInt("chCalWavfldType");

        cspParm.m_fCCorrBegV = rslt.getDouble("m_fCCorrBegV");
        cspParm.m_fCCorrEndV = rslt.getDouble("m_fCCorrEndV");
        cspParm.m_fCCorrIntlV = rslt.getDouble("m_fCCorrIntlV");
        cspParm.m_bUseCSPCorr = rslt.getInt("m_bUseCSPCorr");
        cspParm.m_fCCorrWnd = rslt.getInt("m_fCCorrWnd");
        cspParm.m_fCCoefExp = rslt.getInt("m_fCCoefExp");
        cspParm.fSqureRootV = rslt.getDouble("fSqureRootV");
        cspParm.pmjs_type = rslt.getInt("pmjs_type");

        m_fDepth = rslt.getDouble("m_fDepth");
        m_fDepthIntlV = rslt.getDouble("m_fDepthIntlV");
    }
    else
    {
        cout << "e_CalCSPTrace数据不能为空 " << endl;
        return;
    }
    int points = int(m_fDepth / m_fDepthIntlV);

    // 设置测线散射点坐标
    int iEOMNum = int((cspParm.fMaxEOM - cspParm.fMinEOM) / cspParm.fIntEOM + 1e-4f) + 1;
    cout << " fMinEOM = " << cspParm.fMinEOM << " nShotCount = " << cspParm.nShotCount
         << ", iEOMNum = " << iEOMNum << ", iEOMNum*cspParm.nShotCount = " << iEOMNum * cspParm.nShotCount
         << ",cspParm.chCalWavfldType = " << cspParm.chCalWavfldType << endl;

    // 从这里开始 根据测线号分开
    for (int outSurLineId = 1; outSurLineId <= surLineNum; outSurLineId++)
    {
        float **pOut = new float *[iEOMNum * cspParm.nShotCount];

        for (int dex = 0; dex < iEOMNum * cspParm.nShotCount; dex++)
        {
            // pOut[dex] = new float[cspParm.nSamplePoints];
            pOut[dex] = new float[static_cast<int>(cspParm.nSamplePoints)];

            memset(pOut[dex], 0, sizeof(float) * cspParm.nSamplePoints);
        }

        float **pOut_all = new float *[cspParm.nShotCount];
        for (int dex = 0; dex < cspParm.nShotCount; dex++)
        {
            // pOut_all[dex] = new float[cspParm.nSamplePoints];
            pOut_all[dex] = new float[static_cast<int>(cspParm.nSamplePoints)];
            memset(pOut_all[dex], 0, sizeof(float) * cspParm.nSamplePoints);
        }
        float **pOut_depth = new float *[pcoLocParm.m_iXGrdNum];
        for (int dex = 0; dex < cspParm.nShotCount; dex++)
        {
            pOut_depth[dex] = new float[points];
            memset(pOut_depth[dex], 0, sizeof(float) * points);
        }
        // float** pOut_depth = new float*[cspParm.nShotCount];
        // for (int dex = 0; dex < cspParm.nShotCount; dex++) {
        //     pOut_depth[dex] = new float[points];
        //         memset(pOut_depth[dex], 0,sizeof(float) * points);
        // }
        // 统计测线范围，以进行CSP计算
        float fXLen, fYLen, fZLen;
        float fLineMinX, fLineMaxX, fLineMinY, fLineMaxY, fLineMaxZ, fLineMinZ;
        fLineMinX = fLineMinY = fLineMinZ = 1e10f;
        fLineMaxX = fLineMaxY = fLineMaxZ = -1e10f;
        // 根据测线号确定Y Z的范围
        for (const auto &pChn : pcoCalChnParms)
        {
            if (pChn.id != outSurLineId)
                continue;
            if (fLineMinX > pChn.x)
            {
                fLineMinX = pChn.x;
            }

            if (fLineMaxX < pChn.x)
            {
                fLineMaxX = pChn.x;
            }

            if (fLineMinY > pChn.y)
            {
                fLineMinY = pChn.y;
            }

            if (fLineMaxY < pChn.y)
            {
                fLineMaxY = pChn.y;
            }

            if (fLineMinZ > pChn.z)
            {
                fLineMinZ = pChn.z;
            }

            if (fLineMaxZ < pChn.z)
            {
                fLineMaxZ = pChn.z;
            }
        }

        // float fXLen = pcoLocParm.m_dXMax - pcoLocParm.m_dXMin;
        fXLen = fLineMaxX - fLineMinX;
        fYLen = fLineMaxY - fLineMinY;
        fZLen = fLineMaxZ - fLineMinZ;
        float dtX, dtY, dtZ;
        int dtLen = (cspParm.nShotCount > 1) ? cspParm.nShotCount : 2;

        dtX = pcoLocParm.mark_len / (dtLen - 1);
        dtY = fYLen / (dtLen - 1);
        dtZ = fZLen / (dtLen - 1);
        cout << " fXLen = " << fXLen
             << " fYLen = " << fYLen
             << " fZLen = " << fZLen
             << " dtX = " << dtX
             << " dtZ = " << dtY
             << " dtZ = " << fXLen
             << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
             << " pcoLocParm.m_dXGrdLen = " << pcoLocParm.m_dXGrdLen
             << " pcoLocParm.m_locx = " << pcoLocParm.m_locx
             << " pcoLocParm.mark_len = " << pcoLocParm.mark_len
             << " pcoLocParm.m_dXMin = " << pcoLocParm.m_dXMin
             << " pcoLocParm.m_dXMax = " << pcoLocParm.m_dXMax
             << " nAdvanPoints = " << cspParm.nAdvanPoints
             << " fSampleInterval = " << cspParm.fSampleInterval
             << " nSamplePoints = " << cspParm.nSamplePoints << endl;

        vector<vector<float>> fCSPPos;
        for (int i = 0; i < cspParm.nShotCount; i++)
        {
            std::vector<float> Pos;
            float x = pcoLocParm.m_dXMin + i * dtX;
            float y = fLineMinY + i * dtY;
            float z = fLineMinZ + i * dtZ;
            Pos.push_back(x);
            Pos.push_back(y);
            Pos.push_back(z);
            fCSPPos.push_back(Pos);
        }

        cout << "start CSPTraceGather iEOMNum = " << iEOMNum << " fCSPPos size = " << fCSPPos.size() << endl;

        PureCommonOperation::CSPTraceGather(pData, pOut, pOut_all, &pcoCalChnParms[0],
                                            cspParm, iEOMNum, fCSPPos,
                                            hzi::config.ms_components, pChn_ext, outSurLineId);
        // 时深转换
        //  for(int dex = 0; dex < cspParm.nShotCount; dex++){
        //      for(int pnt = 0;pnt < cspParm.nSamplePoints;pnt++){
        //          if(pnt<cspParm.nAdvanPoints)continue;
        //          auto depth_tmp = cspParm.fPV*(pnt-cspParm.nAdvanPoints)*cspParm.fSampleInterval/2; //双程
        //          int index = int(depth_tmp/m_fDepthIntlV);
        //          if(index<points)pOut_depth[dex][index] += pOut_all[dex][pnt];

        //     }

        // }
        float PI = 3.1415926;
        for (int dex = 0; dex < cspParm.nShotCount; dex++)
        {
            for (int pnt = 0; pnt < points; pnt++)
            {
                float h0 = (pnt + 1) * m_fDepthIntlV;
                auto t0 = 2 * h0 / cspParm.fSqureRootV; //  t0 代表双程时间？CSP中也是双程
                                                        // for(int icsp = 0;icsp< cspParm.nShotCount;icsp++)
                for (int icsp = dex - 2; icsp <= dex + 2 && icsp >= 0 && icsp < cspParm.nShotCount; icsp++)
                {
                    int d = fabs(icsp - dex) + 1;
                    auto h1 = d * cspParm.fIntEOM;
                    // auto h1 = fabs((icsp - dex)* cspParm.fIntEOM);

                    auto r = sqrtf(h0 * h0 + h1 * h1);
                    float cosQ = (r == 0) ? 1 : h0 / r;

                    //   if(cosQ <= 0.5)continue;
                    auto t = sqrtf(t0 * t0 + 4 * h1 * h1 / (cspParm.fSqureRootV * cspParm.fSqureRootV));

                    auto indexT = int(t / cspParm.fSampleInterval);
                    // 加上时窗，前后10个采样点
                    if (indexT > cspParm.nSamplePoints - cspParm.nAdvanPoints)
                        continue;
                    float tmp = 0.0;
                    for (int k = indexT - 10; k < indexT + 10 &&
                                              k >= cspParm.nAdvanPoints + 10 &&
                                              k < cspParm.nSamplePoints - cspParm.nAdvanPoints - 10;
                         k++)
                    {
                        tmp += (h1 / (2 * PI)) * (cosQ / (sqrtf(cspParm.fSqureRootV * r))) * pOut_all[icsp][k + cspParm.nAdvanPoints];
                    }
                    pOut_depth[dex][pnt] += tmp;
                    // pOut_depth[dex][pnt] +=(h1/(2*PI)) *(cosQ/(sqrtf(cspParm.fSqureRootV*r)))*pOut_all[icsp][indexT+cspParm.nAdvanPoints];
                }
            }
        } // dex 时间深度转换

        string folder = "CSPFolder";
        string name1 = "CSP_file";  // CSP道集文件
        string name2 = "CSP_time";  // CSP时间剖面
        string name3 = "CSP_depth"; // CSP深度剖面
        string folder2 = "CSP";
        if (true)
        {
            // 保存CSP道集文件
            fs::path cspDaojiPath(hzi::config.dataRoot);
            cspDaojiPath /= relLocFromTime(tmStamp) / folder /
                            std::to_string(tmStamp) / std::to_string(outSurLineId) / name1;

            unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
            char *pHead = pHeadData.get();
            *(double *)(pHead) = (double)tmStamp;

            *(uint32_t *)(pHead + 8) = iEOMNum * cspParm.nShotCount; // 可用通道总数
            *(uint32_t *)(pHead + 12) = cspParm.nSamplePoints;       // 数据长度
            *(float *)(pHead + 16) = cspParm.fSampleInterval;        // 采样间隔
            *(uint32_t *)(pHead + 20) = cspParm.nAdvanPoints;        // 超前点数

            *(uint32_t *)(pHead + 24) = cspParm.nShotCount; // 散射点数量
            try
            {
                auto dir = cspDaojiPath.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(cspDaojiPath, std::ofstream::binary);
                ofs_Signal.write(pHead, 32);
                for (int ch = 0; ch < iEOMNum * cspParm.nShotCount; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOut[ch];

                    ofs_Signal.write((char *)p32Signal, cspParm.nSamplePoints * 4);
                }

                ofs_Signal.close();
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += cspDaojiPath.string();
                msg += ":";
                msg += e.what();
                if (hzi::config.verbose)
                    cout << "msg = " << msg << endl;
                debugErr(msg);
                // return "error";
            };

            // 拆开CSP道集 方便前端展示
            for (int i = 0; i < cspParm.nShotCount; i++)
            {
                fs::path cspDaojiPath_1(hzi::config.dataRoot);
                cspDaojiPath_1 /= relLocFromTime(tmStamp) / folder /
                                  std::to_string(tmStamp) / std::to_string(outSurLineId) / folder2 / std::to_string(i + 1);

                unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
                char *pHead2 = pHeadData2.get();
                //  *(double*)(pHead2) = (double)tmStmp;
                *(uint32_t *)(pHead2) = cspParm.nShotCount; // 散射点数量
                *(uint32_t *)(pHead2 + 4) = i + 1;          // 散射点数量

                *(uint32_t *)(pHead2 + 8) = iEOMNum;                // 可用通道总数
                *(uint32_t *)(pHead2 + 12) = cspParm.nSamplePoints; // 数据长度
                *(float *)(pHead2 + 16) = cspParm.fSampleInterval;  // 采样间隔
                *(uint32_t *)(pHead2 + 20) = cspParm.nAdvanPoints;  // 超前点数

                try
                {
                    auto dir = cspDaojiPath_1.parent_path();
                    if (!fs::exists(dir))
                    {
                        fs::create_directories(dir);
                    }
                    std::ofstream ofs_Signal(cspDaojiPath_1, std::ofstream::binary);
                    ofs_Signal.write(pHead2, 32);
                    for (int ch = 0; ch < iEOMNum; ++ch)
                    {
                        int32_t *p32Signal = (int32_t *)pOut[ch + iEOMNum * i];

                        ofs_Signal.write((char *)p32Signal, cspParm.nSamplePoints * 4);
                    }

                    ofs_Signal.close();
                }
                catch (std::exception &e)
                {
                    string msg("error while writing to file:");
                    msg += cspDaojiPath_1.string();
                    msg += ":";
                    msg += e.what();
                    if (hzi::config.verbose)
                        cout << "msg = " << msg << endl;
                    debugErr(msg);
                    // return "error";
                };

            } // 拆开CSP道集 方便前端展示

        } // CSP道集

        // 写文件
        //     cout<<"endl CSPTraceGather "<<endl;
        //     std::ofstream outFile;
        //     string saveFilePath = "test/CSP_file_"+std::to_string(tmStamp)+"_"+std::to_string(outSurLineId)+".csv";
        //     outFile.open(saveFilePath.c_str(), std::ios::out); // 打开模式可省略
        //     outFile <<iEOMNum*cspParm.nShotCount<<','<< cspParm.nSamplePoints<<','<<cspParm.fSampleInterval<< ','<<cspParm.nAdvanPoints *cspParm.fSampleInterval << std::endl;
        //     for(int pnt = 0;pnt<cspParm.nSamplePoints;pnt++ )
        //     {
        //         for(int ch = 0;ch<iEOMNum*cspParm.nShotCount;++ch)
        //         {
        //             outFile << pOut[ch][pnt]<< ',';
        //         }
        //         outFile<< std::endl;

        //     }
        //     outFile.close();
        //  cout<<" save outdate .csv "<<endl;
        if (true)
        {
            // 保存CSP时间剖面
            fs::path cspDaojiTimePath(hzi::config.dataRoot);
            cspDaojiTimePath /= relLocFromTime(tmStamp) / folder /
                                std::to_string(tmStamp) / std::to_string(outSurLineId) / name2;

            unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
            char *pHead = pHeadData.get();
            *(double *)(pHead) = (double)tmStamp;

            *(uint32_t *)(pHead + 8) = cspParm.nShotCount;     // 可用通道总数
            *(uint32_t *)(pHead + 12) = cspParm.nSamplePoints; // 数据长度
            *(float *)(pHead + 16) = cspParm.fSampleInterval;  // 采样间隔
            *(uint32_t *)(pHead + 20) = cspParm.nAdvanPoints;  // 超前点数

            try
            {
                auto dir = cspDaojiTimePath.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(cspDaojiTimePath, std::ofstream::binary);
                ofs_Signal.write(pHead, 32);
                for (int ch = 0; ch < cspParm.nShotCount; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOut_all[ch];

                    ofs_Signal.write((char *)p32Signal, cspParm.nSamplePoints * 4);
                }

                ofs_Signal.close();
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += cspDaojiTimePath.string();
                msg += ":";
                msg += e.what();
                if (hzi::config.verbose)
                    cout << "msg = " << msg << endl;
                debugErr(msg);
                // return "error";
            };
        }
        // 保存CSP时间剖面
        //  std::ofstream outFile2;
        //  string savePath = "test/CSP_time_"+std::to_string(tmStamp)+"_"+std::to_string(outSurLineId)+".csv";
        //  outFile2.open(savePath.c_str(), std::ios::out); // 打开模式可省略
        //  //outFile2.open("test/outdate_all.csv", std::ios::out); // 打开模式可省略
        //  outFile2 <<cspParm.nShotCount<<','<< cspParm.nSamplePoints<<','<<cspParm.fSampleInterval<< ','<<cspParm.nAdvanPoints *cspParm.fSampleInterval << std::endl;
        //  for(int pnt = 0;pnt<cspParm.nSamplePoints;pnt++ )
        //  {
        //      for(int ch = 0;ch<cspParm.nShotCount;++ch)
        //      {
        //          outFile2 << pOut_all[ch][pnt]<< ',';
        //      }
        //      outFile2<< std::endl;

        // }
        // outFile2.close();
        // cout<<" save outdate_all.csv "<<endl;

        if (true)
        {

            // 使用标准库算法查找最大值和最小值
            float maxVal = std::numeric_limits<float>::lowest();
            float minVal = std::numeric_limits<float>::max();

            for (int ch = 0; ch < cspParm.nShotCount; ++ch)
            {
                auto rowMax = *std::max_element(pOut_depth[ch], pOut_depth[ch] + points);
                auto rowMin = *std::min_element(pOut_depth[ch], pOut_depth[ch] + points);

                if (rowMax > maxVal)
                    maxVal = rowMax;
                if (rowMin < minVal)
                    minVal = rowMin;
            }

            // 保存CSP深度剖面
            fs::path cspDaojiDepthPath(hzi::config.dataRoot);
            cspDaojiDepthPath /= relLocFromTime(tmStamp) / folder /
                                 std::to_string(tmStamp) / std::to_string(outSurLineId) / name3;

            unique_ptr<char[]> pHeadData = std::make_unique<char[]>(64);
            char *pHead = pHeadData.get();
            *(double *)(pHead) = (double)tmStamp;

            *(uint32_t *)(pHead + 8) = cspParm.nShotCount; // 可用通道总数
            *(uint32_t *)(pHead + 12) = points;            // 数据长度
            *(float *)(pHead + 16) = dtX;                  // X方向精度
            *(float *)(pHead + 20) = m_fDepthIntlV;        // Y方向精度
            *(float *)(pHead + 24) = minVal;
            *(float *)(pHead + 28) = maxVal;
            // *(int32_t*)(pHead + 24) = *((int32_t*)&minVal);
            // *(int32_t*)(pHead + 28) = *((int32_t*)&maxVal);
            *(float *)(pHead + 32) = pcoLocParm.m_locx;   // 回采位置
            *(uint8_t *)(pHead + 36) = pcoLocParm.m_dir;  // 回采方向
            *(float *)(pHead + 37) = pcoLocParm.mark_len; // 超前探测距离

            try
            {
                auto dir = cspDaojiDepthPath.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(cspDaojiDepthPath, std::ofstream::binary);
                ofs_Signal.write(pHead, 64);
                for (int ch = 0; ch < cspParm.nShotCount; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOut_depth[ch];

                    ofs_Signal.write((char *)p32Signal, points * 4);
                }

                ofs_Signal.close();
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += cspDaojiDepthPath.string();
                msg += ":";
                msg += e.what();
                if (hzi::config.verbose)
                    cout << "msg = " << msg << endl;
                debugErr(msg);
                // return "error";
            };
        } // 保存CSP深度剖面

        // std::ofstream outFile3;
        // string savedepthPath = "test/CSP_depth_"+std::to_string(tmStamp)+"_"+std::to_string(outSurLineId)+".csv";
        // outFile3.open(savedepthPath.c_str(), std::ios::out); // 打开模式可省略
        // outFile3 <<cspParm.nShotCount<<','<< points<<','<<m_fDepthIntlV<< ','<< 0 << std::endl;
        // for(int pnt = 0;pnt<points;pnt++ )
        // {
        //     for(int ch = 0;ch<cspParm.nShotCount;++ch)
        //     {
        //         outFile3 << pOut_depth[ch][pnt]<< ',';
        //     }
        //     outFile3<< std::endl;

        // }
        // outFile3.close();
        // cout<<" save outdate_depth.csv "<<endl;

    } // outSurLineId
}
/**
 flag 1 实时计算 0 -查询历史表
*/
bool getPCO_parm(PureCommonOperation::PCOSignalParm &pcoParm, PureCommonOperation::PCOLocParm &pcoLocParm, float deltT, bool flag,
                 bool &outType, int &outSurLineId, int &isUseCSP, int &useVType, bool &is_evenSpeed, float &speed_p, float &speed_s)
{
    bool ret = false;

    auto conn = hzi::config.pConnPool->getConnection();
    string sqlstr1;
    if (flag)
    {
        // 实时计算
        sqlstr1 = "SELECT * FROM `e_mining_PCOSignalParm`";
    }
    else
    {
        // 历史计算
        sqlstr1 = "SELECT * FROM `e_mining_PCOSignalParm_history`";
    }

    auto rslt = conn.executeQuery(sqlstr1.c_str());
    if (rslt.next())
    {
        outType = rslt.getInt("outType");
        isUseCSP = rslt.getInt("isUseCSP");

        outSurLineId = rslt.getInt("outSurLineId");
        pcoParm.dcType = rslt.getInt("dcType");
        pcoParm.chnno = rslt.getInt("chn_no");
        pcoParm.coeLen = int(rslt.getInt("coeLen") * 60 * 1000 / deltT);//因子时长(min)/采样间隔
        pcoParm.outLen = rslt.getInt("outLen"); // 输出点数
        // pcoParm.outLen = int(rslt.getInt("outLen") / deltT);
        pcoParm.coefBegPt = rslt.getInt("coefBegPt"); // 超前点数
        // pcoParm.coefBegPt = int(rslt.getInt("coefBegPt") * 60 * 1000 / deltT);
        pcoParm.biased = rslt.getInt("biased");
        pcoParm.extractMethod = rslt.getInt("extractMethod");

        pcoParm.convLen = int(rslt.getInt("convLen") * 60 * 1000 / deltT);
        pcoParm.loCutF = rslt.getDouble("loCutF");
        pcoParm.hiCutF = rslt.getDouble("hiCutF");
        pcoParm.tranBW = rslt.getDouble("tranBW");
        pcoParm.isStop = rslt.getInt("isStop");
        pcoParm.wndFlag = rslt.getInt("wndFlag");
        pcoParm.isCut = rslt.getInt("isCut");

        pcoParm.isNotchCut = rslt.getInt("isNotchCut");
        pcoParm.notchInFD = rslt.getInt("notchInFD");
        pcoParm.Notch_jobs = rslt.getInt("Notch_jobs");
        pcoParm.NotchWn = rslt.getInt("NotchWn");
        pcoParm.NotchType = rslt.getInt("NotchType");
        string notchFStr = rslt.getString("notchF");
        //原来库表里这个字段是50n，该行去掉n，现在改为该字段直接存数值。至于50可以做奇偶倍，125不做奇偶倍只做一倍，由用户自己决定。
        // string tmpstr = notchFStr.substr(0, notchFStr.length() - 1);
        // pcoParm.notchF = atoi(tmpstr.c_str());
        pcoParm.notchF = atoi(notchFStr.c_str());
        pcoParm.isNotch_n = true;
        pcoParm.ampType = rslt.getInt("ampType");
        pcoParm.wndType = rslt.getInt("wndType");
        pcoParm.normalizedType = rslt.getInt("normalizedType");

        speed_p = rslt.getDouble("speed_p");
        speed_s = rslt.getDouble("speed_s");
        is_evenSpeed = rslt.getInt("is_evenSpeed");
        useVType = rslt.getInt("useVType");
        pcoLocParm.extensionAngle = rslt.getDouble("extensionAngle");
        pcoLocParm.is_exclude_directWaves = rslt.getInt("isExcludeDirectWaves");
        pcoLocParm.hasFouce = rslt.getInt("hasFouce");

        //道内均衡
        pcoParm.deAGCtype = rslt.getInt("deAGCtype");
        pcoParm.wnLen = int(rslt.getInt("wnLen") / deltT);
        pcoParm.expGainAlpha=rslt.getDouble("gainCoe");
        cout<<"pcoParm.expGainAlpha="<<pcoParm.expGainAlpha<<endl;
        cout<<"pcoParm.expGainAlpha="<<pcoParm.expGainAlpha<<endl;
        
        //反褶积
        pcoParm.isSpikeDeconvolution = rslt.getInt("isSpikeDeconvolution");
        pcoParm.dcovLetPoint = int(rslt.getInt("dcovLetPoint") / deltT);
        pcoParm.deconvCoef = rslt.getDouble("deconvCoef");
        int cofLen2 = 2000;
        pcoParm.spikeDeCoeLen = int(cofLen2 / deltT);
        pcoLocParm.directWavesTimes = 10;

        pcoParm.isUseSlideWn = rslt.getInt("isUseSlideWn");
        pcoParm.slideWn = int(rslt.getInt("slideWn") * 1000 / deltT);//库表滑动实窗单位s，这里是点数

        pcoParm.isCalRandon = rslt.getInt("isCalRandon");
        pcoParm.fScale = rslt.getDouble("fScale");
        float v_min = rslt.getDouble("fPMin");
        pcoParm.fPMax = 1 / v_min;
        pcoParm.fPMin = 0 - pcoParm.fPMax;
        // pcoParm.fPMin = rslt.getDouble("fPMin");
        // pcoParm.fPMax = rslt.getDouble("fPMax");
        pcoParm.fPSpace = rslt.getDouble("fPSpace");
        pcoParm.bNegtiveV = rslt.getInt("bNegtiveV");
        pcoParm.CorrType = rslt.getInt("CorrType");

        pcoParm.ImageType = rslt.getInt("ImageType");
        pcoParm.systemeType = rslt.getInt("systemeType");
        pcoParm.interChnAmpEqual_type = rslt.getInt("interChnAmpEqualType");
        ret = true;

        pcoParm.isShaping = rslt.getInt("isShaping");
        pcoParm.shapingRato = rslt.getDouble("shapingRato");
    }
    pcoParm.ms_mining_type = hzi::config.ms_mining_type;
    return ret;
}
 
/*
* 多炮数据处理
* 实时计算（flag=true）：
* 历史重算（flag=false）：只进行干涉源提取，不进行其他计算
*/
string handleSignalProcess(std::vector<DataFrame *> dfVec, bool flag, int dev_id)
{
    auto deltT = dfVec[0]->sampIntvl();//采样间隔
    auto tmStmp = dfVec[0]->sampTime();//采样时间（跟踪一下拼帧后的帧的采样时间是什么含义）
    auto devId = dfVec[0]->devMask();
    float speed_p, speed_s = 0;
    bool is_evenSpeed = 0;
    auto pntss = dfVec[0]->points();
    int useVType = 0; // 默认使用P波偏移，偏移类型（0-P波 ，1-S波 2-PS波)

    PureCommonOperation::PCOLocParm pcoLocParm;
    PureCommonOperation::PCOSignalParm pcoParm;
    bool outType = 0;
    int outSurLineId = 0; // 随采输出测线id 使用测线数量
    int isUseCSP = 0;
    bool ret = getPCO_parm(pcoParm, pcoLocParm, deltT, flag, outType, outSurLineId, isUseCSP, useVType, is_evenSpeed, speed_p, speed_s);

    auto conn = hzi::config.pConnPool->getConnection();

    double dateTime = (double)tmStmp / 1000.0;
    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(tmStmp, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    if (!hzi::config.ms_tunnel_listen)
    {
        hzi::tunnel_mining_loc = pcoLocParm.m_locx;
    }

    if (hzi::config.verbose)
        cout << " 回采位置：" << pcoLocParm.m_locx << endl;

    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }
    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }

    pcoParm.ms_components = hzi::config.ms_components;
    pcoLocParm.out_type = 1;

    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);

    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    // 先找出所有通道，进行分量和测线配置，然后删除不需要的通道  devId
    setPCOCalChn(pcoCalChnParms, hzi::sysDevMask, tmStmp, flag);

    for (int i = 0; i < 3; i++)
    {
        pcoParm.dataChnNO[i] = pcoParm.chnno;
    }

    if (pcoParm.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            auto chn_no = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            auto is_out = rslt_comp.getInt("is_out");
            if (is_out)
                pcoLocParm.out_type = id;
            if (flag)
            {
                // 实时计算
                pcoParm.dataChnNO[id - 1] = chn_no;
            }
            else
            {
                // 历史计算
                pcoParm.dataChnNO[id - 1] = chn_no_history;
            }
            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                    //  cout<<" 通道号："<<num<<" 分量："<<id<<" enb = "<<pcoCalChnParms[num-1].enb <<endl;
                }
            }
        }
    }

    //    auto surveyLineCount = 1;//测线数量 1-机载式，2-双巷式，3-混合式
    // systemeType = 0 系统类型：0-双巷式，1-机载式，2-组合式'
    int lineArry[3] = {0};
    //  int mining_singalCount = 0;
    if (hzi::config.ms_mining_type == 1)
    {
        auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
        while (rslt_surveyLine.next())
        {
            auto id = rslt_surveyLine.getInt("id");
            //    surveyLineCount = (id > surveyLineCount) ? id : surveyLineCount;
            auto chnsList = rslt_surveyLine.getString("chnsList");

            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            lineArry[id - 1] = chns_List.size();
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].id = id; // 测线id
                    //   cout<<" 通道号："<<num<<" 测线："<<id<<endl;
                }
            }
        }
        //  mining_singalCount = getSignalChnCount(pcoParm.systemeType ,pcoParm.ImageType,lineArry[0],lineArry[1],lineArry[2],hzi::config.ms_components);

        for (int i = 0; i < 3; i++)
        {
            if (dev_id != 0)
            {
                if (lineArry[i] != 0 && dev_id == i + 1)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
            else
            {
                if (lineArry[i] != 0)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
        }
    }

    //随掘
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        //  pcoLocParm.is_exclude_directWaves = true;
        if (pcoParm.ms_components > 1)
        {
            auto chnno_tmp = pcoParm.dataChnNO[0];
            pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
        }
        else
        {
            pcoLocParm.fx = pcoCalChnParms[pcoParm.chnno - 1].x;
            pcoLocParm.fy = pcoCalChnParms[pcoParm.chnno - 1].y;
            pcoLocParm.fz = pcoCalChnParms[pcoParm.chnno - 1].z;
        }
    }

    if (dev_id != 0)
    {
        // 指定测线数据处理 取对应基站的坐标 默认基站号与测线号对应
        pcoCalChnParms.erase(
            std::remove_if(
                pcoCalChnParms.begin(),
                pcoCalChnParms.end(),
                [dev_id](const PureCommonOperation::PCOCalChn &elem)
                {
                    return elem.id != dev_id;
                }),
            pcoCalChnParms.end());
    }
    // 在此区分随掘和随采的信号提取通道数量 随采根据测线来决定

    int vecSize = dfVec.size();
    auto chns = dfVec[0]->channels();

    PureCommonOperation::PCOExtractChn pcoExtractChnParms;
    setSignalChnInfo(pcoExtractChnParms, pcoCalChnParms, pcoParm, chns);
    // cout<<" count = "<<pcoExtractChnParms.count
    //     <<" , chnno = "<<pcoExtractChnParms.chnNoVec.size()
    //     <<" , coechnno = "<<pcoExtractChnParms.coeChnNoVec.size()<<",chns = "<<chns<<endl;

    auto valChnns = pcoExtractChnParms.count;//对随掘来说pcoExtractChnParms.count=chns
    // auto valChnns =(hzi::config.ms_mining_type == 1) ? mining_singalCount : chns;

    auto valNum = valChnns * vecSize;//通道数*炮数
    // cout<<" valNum = "<<valNum<<endl;

    // float **pOutSignal = new float *[valChnns * vecSize];
    // for (int dex = 0; dex < vecSize; dex++)
    // {
    //     for (int ch = 0; ch < valChnns; ++ch)
    //     {
    //         pOutSignal[ch + dex * valChnns] = new float[pcoParm.outLen];
    //         memset(pOutSignal[ch + dex * valChnns], 0,
    //                sizeof(float) * pcoParm.outLen);
    //     }
    // }
    // cout<<"valChnns = "<<valChnns<<",pcoParm.outLen = "<<pcoParm.outLen<<endl;
    auto iGrdNum =
        pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    pcoParm.mining_fx = pcoLocParm.fx;
    pcoParm.mining_fy = pcoLocParm.fy;
    pcoParm.mining_fz = pcoLocParm.fz;
    pcoParm.chns_Count = valChnns;
    pcoParm.chns = chns;
    // // 历史重算 只进行干涉源提取
    // if (!flag)
    // {
    //     pcoParm.isCut = 0;
    //     pcoParm.isCalRandon = false;
    //     pcoParm.isSpikeDeconvolution = false;
    //     pcoParm.deAGCtype = 0;
    //     isUseCSP = 0;
    //     pcoParm.interChnAmpEqual_type = 0;
    // }
    // 采煤机定位 随采采煤机定位
    int sumCount_jh = 170;
    float dis = 1.75;
    if (hzi::config.ms_mining_type == 1 && hzi::start_jh != 0 && hzi::end_jh != 0)
    {
        //  float dis_y = (pcoLocParm.m_dYMax - pcoLocParm.m_dYMin)/100;
        float y = pcoLocParm.m_dYMin + hzi::start_jh * dis;
        float dis_y = (hzi::end_jh - hzi::start_jh) * dis / vecSize;

        pcoLocParm.fx = pcoLocParm.m_locx;
        pcoLocParm.fy = y;
        pcoLocParm.fz = pcoLocParm.fz;
        pcoLocParm.dis_y = dis_y;
    }
    // cout<<"size = "<<dfVec.size()<<" , 通道："<<dfVec[0]->channels()<<", 时间戳"<<std::to_string(dfVec[0]->sampTime())
    //     <<"震源位置："<<pcoLocParm.fx<<" ,"<<pcoLocParm.fy<<", 间隔："<<pcoLocParm.dis_y<<endl;;


    
    /*
    * 对每炮数据进行处理：加窗，预处理，滑动时窗，相关，一维滤波，反褶积，道内均衡，道间均衡，反射波提取
    */
    float **pOutSignal = new float *[valChnns * vecSize];//delete？
    cout<<"pOutSignal创建时地址为:"<<pOutSignal<<endl;
    for (int dex = 0; dex < vecSize; dex++)
    {
        for (int ch = 0; ch < valChnns; ++ch)
        {
            pOutSignal[ch + dex * valChnns] = new float[pcoParm.outLen];//delete
            memset(pOutSignal[ch + dex * valChnns], 0,
                   sizeof(float) * pcoParm.outLen);
        }
    }
    
    if (!flag)// 历史重算 只进行干涉源提取
    {
        pcoParm.isCut = 0;//无滤波
        pcoParm.isCalRandon = false;//无反射波提取
        pcoParm.isSpikeDeconvolution = false;//无反褶积
        pcoParm.deAGCtype = 0;//无道内均衡
        isUseCSP = 0;// 无CSP道集提取
        pcoParm.interChnAmpEqual_type = 0;//无道间均衡
    }
    PureCommonOperation::handleDataFrameVec_signal(
        std::move(dfVec), pcoParm, &pcoCalChnParms[0], pOutSignal, pcoExtractChnParms);
    logInfo(" handleDataFrameVec_signal  endl ");
    //上面：结果存于pOutSignal：实时--提取+再提取，历史--提取

    bool isSavePianyi = true;
    // CSP道集提取 已经生成了偏移图，不用进行偏移了
    if (isUseCSP != 0)
    {
        // 随采 散射 CSP道集提取
        isSavePianyi = false;
        if (hzi::config.ms_mining_type == 1 && pcoParm.ImageType == 0)
        {
            PureCommonOperation::CSPTraceParm cspParm;
            cspParm.nComponentCount = hzi::config.ms_components;
            cspParm.iCalTraces = pcoExtractChnParms.count;
            cspParm.nSamplePoints = pcoParm.outLen - pcoParm.coefBegPt;
            cspParm.fSampleInterval = deltT;
            cspParm.nAdvanPoints = 0;
            cspParm.fPV = speed_p;
            cspParm.fSV = speed_s;
            int surLineNum = (pcoParm.systemeType == 0) ? 2 : ((pcoParm.systemeType == 1) ? 1 : 3);

            float **pSignal = new float *[valChnns * vecSize];
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < valChnns; ++ch)
                {
                    // pSignal[ch + dex * valChnns] = new float[cspParm.nSamplePoints];
                    pSignal[ch + dex * valChnns] = new float[static_cast<int>(cspParm.nSamplePoints)];
                    for (int i = 0; i < cspParm.nSamplePoints; i++)
                    {
                        pSignal[ch + dex * valChnns][i] = pOutSignal[ch + dex * valChnns][i + pcoParm.coefBegPt];
                    }
                }
            }

            getCSPTrace(tmStmp, pSignal, pcoCalChnParms, cspParm, pcoLocParm,
                        pcoExtractChnParms, surLineNum);
        }
    }
    else
    {
        // 三分量需要叠加时使用
        //  float* pOut = new float[iGrdNum];
        //  memset(pOut, 0, sizeof(float) * iGrdNum);
        // 多分量分别设置
        for (int com = 0; com < pcoParm.ms_components; com++)
        {

            auto pretime = pcoParm.coefBegPt;

            pcoLocParm.is_evenspeed = is_evenSpeed;

            float *pOut_tmp = new float[iGrdNum];
            memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

            if (useVType < 2)//P波偏移或S波偏移
            {
                // float* pOut_tmp = new float[iGrdNum];
                // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

                float *pSpeedBtr = new float[iGrdNum];
                memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                for (int i = 0; i < iGrdNum; i++)
                {
                    if (useVType == 0)
                    {
                        pSpeedBtr[i] = speed_p;
                    }
                    else
                    {
                        pSpeedBtr[i] = speed_s;
                    }
                }
                getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                             coal_z, layer_from, is_evenSpeed);

                auto pretime2 = pretime * deltT;
                if (hzi::config.ms_mining_type == 1)//随采
                {
                    if (pcoParm.ImageType == 2)
                    {
                        PureCommonOperation::CalMigration_mining(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                            com + 1, pcoExtractChnParms, outSurLineId);
                    }
                    else
                    {
                        isSavePianyi = false;
                    }
                }
                else//随掘
                {
                    PureCommonOperation::CalMigration(
                        pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                        com + 1);
                }

                if (hzi::config.verbose)
                {
                    cout << " CalMigration endl " << endl;
                }
            }
            else if (useVType == 2)//PS波偏移
            {
                for (int type = 0; type < useVType; type++)
                {
                    // float* pOut_tmp = new float[iGrdNum];
                    // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);
                    float *pSpeedBtr = new float[iGrdNum];
                    memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                    for (int i = 0; i < iGrdNum; i++)
                    {
                        if (type == 0)
                        {
                            pSpeedBtr[i] = speed_p;
                        }
                        else
                        {
                            pSpeedBtr[i] = speed_s;
                        }
                    }

                    getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                                 coal_z, layer_from, is_evenSpeed);
                    auto pretime2 = pretime * deltT;
                    if (hzi::config.ms_mining_type == 1)
                    {
                        if (pcoParm.ImageType == 2)
                        {
                            PureCommonOperation::CalMigration_mining(
                                pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                                pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                                pcoParm.ampType, com + 1, pcoExtractChnParms, outSurLineId);
                        }
                        else
                        {
                            isSavePianyi = false;
                        }
                    }
                    else
                    {
                        //随掘
                        PureCommonOperation::CalMigration(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                            pcoParm.ampType, com + 1);
                    }
                }
            }
            //上面：pOutSignal中结果经过计算，结果存于pOut_tmp

            //保存偏移图
            bool is_save = true;//true表示进行异常提取，false表示不进行异常提取
            if (isSavePianyi)
                bool ret = saveResult(tmStmp, devId, iGrdNum, pcoLocParm, pOut_tmp, com, is_save, outType);
        }
    }

    // cout<<"---------------互相关数据-----------------"<<endl;
    // for(int dex = 0; dex < vecSize; dex++)
    // {
    //     for (int chIndex = 0; chIndex < 16; chIndex++)
    //     {
    //         cout << "chIndex=" << chIndex << endl;
    //         for (int pt = 0; pt < 20; pt++)
    //         {
    //             cout << "pt=" << pt << ",pOutSignal=" << pOutSignal[chIndex + dex * 16][pt] << endl;
    //         }
    //     }
    // }
    // cout<<"---------------互相关数据-----------------"<<endl;


    // 写文件
    if (hzi::config.ms_miningSignal)//配置文件中字段
    {
         // auto pretime = 0;
         // auto pretime = 0;
        unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
        char *pHead2 = pHeadData2.get();
        
         // 19 代表随采，9是随掘
        int classId2 = 0;
        // auto classId2 = (hzi::config.ms_mining_type == 1) ? 19 : 9;

        
        // if (pcoParm.extractMethod == 1) // 互相关：9类型
        if(true)
        {
            // 构造9文件头
            classId2 = 9;
            *(double *)(pHead2) = (double)tmStmp;
            *(uint8_t *)(pHead2 + 8) = classId2;
            *(float *)(pHead2 + 9) = deltT;
            *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
            *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
            *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
            *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
            *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
            if (hzi::config.ms_mining_type == 1)
            {
                *(uint8_t *)(pHead2 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
                *(uint8_t *)(pHead2 + 29) = pcoParm.ImageType;   //'随采成像方式:0-散射，1-透射，2-爆炸成像'
            }

            auto conn21 = hzi::config.pConnPool->getConnection();
            conn21.execute(
                "INSERT INTO "
                "e_mining_signaldata_frm_info "
                "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
                "loc,fx,fy,fz,dis)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
                "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
                (uint8_t)devId,  // dev_id
                tmStmp / 1000.0, // samp_time
                classId2,        // class_id
                deltT,           // curt_ch
                valNum,          // channels
                vecSize,
                pcoParm.outLen, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId2) /
                 std::to_string(tmStmp))
                    .c_str(), // frm_loc
                pcoLocParm.fx,
                pcoLocParm.fy,
                pcoLocParm.fz,
                pcoLocParm.dis_y);

            fs::path outClassId11FileName(hzi::config.dataRoot);
            outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                                 std::to_string(tmStmp);
            try
            {
                auto dir = outClassId11FileName.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(outClassId11FileName, std::ofstream::binary);
                ofs_Signal.write(pHead2, 32);
                for (int dex = 0; dex < vecSize; dex++)
                {
                    for (int ch = 0; ch < valChnns; ++ch)
                    {
                        // if (!pcoCalChnParms[ch].enb)
                        //     continue;

                        int32_t* p32OutSignal = (int32_t*)(pOutSignal[ch+dex*valChnns]);
                        ofs_Signal.write((char*)p32OutSignal, pcoParm.outLen * 4);
                    }
                }
                ofs_Signal.close();
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += outClassId11FileName.string();
                msg += ":";
                msg += e.what();
                if (hzi::config.verbose)
                    cout << "msg = " << msg << endl;
                debugErr(msg);
                return "error";
            };
        }
    }
    return std::to_string(tmStmp);//返回采样时间
}
string handleSignalProcess_test(float **pData,
                                int point,
                                int chns,
                                float deltT,
                                int prepoint)
{
    // 开始处理信号

    auto tmStmp = nowMS();
    float speed_p, speed_s = 0;
    auto devId = 1;
    auto useVType = 0; // 默认使用P波偏移
    PureCommonOperation::PCOSignalParm pcoParm;
    PureCommonOperation::PCOLocParm pcoLocParm;
    bool outType = 0;
    int outSurLineId = 0;
    int isUseCSP = 0;
    bool is_evenSpeed = 0;
    bool ret = getPCO_parm(pcoParm, pcoLocParm, deltT, false,
                           outType, outSurLineId, isUseCSP, useVType, is_evenSpeed, speed_p, speed_s);
    auto conn = hzi::config.pConnPool->getConnection();

    cout << "isCut: " << pcoParm.isCut << " ,isNotchCut: " << pcoParm.isNotchCut
         << " ,  pcoParm.notchF：" << pcoParm.notchF
         << " ,pcoParm.isNotch_n :" << pcoParm.isNotch_n
         << ",useVType = " << useVType << " , 反褶积： "
         << pcoParm.isSpikeDeconvolution << " 子波长度:" << pcoParm.dcovLetPoint
         << " , 白化系数：" << pcoParm.deconvCoef << " ,道内均衡 ："
         << pcoParm.deAGCtype << ", 窗口宽度 " << pcoParm.wnLen << endl;

    double dateTime = (double)tmStmp / 1000.0;

    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(tmStmp, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    if (hzi::config.verbose)
        cout << "  pcoLocParm.m_locx = " << pcoLocParm.m_locx << endl;
    // if (hzi::config.ms_mining_type == 2) {
    //     // 随掘有通讯时，实时获取随采位置
    //     pcoLocParm.m_locx = hzi::tunnel_mining_loc;
    // }
    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }

    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        // pcoLocParm.is_exclude_directWaves = true;
        pcoLocParm.fx = pcoLocParm.m_locx;
        pcoLocParm.fy = 0;
        pcoLocParm.fz = 0;
    }
    pcoParm.ms_components = hzi::config.ms_components;
    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);
    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    if (hzi::config.verbose)
    {
        cout << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
             << ";pcoLocParm.m_iZGrdNum = " << pcoLocParm.m_iZGrdNum
             << ";pcoLocParm.m_iYGrdNum = " << pcoLocParm.m_iYGrdNum
             << ";mark_len = " << pcoLocParm.mark_len
             << ";pcoLocParm.m_dZGrdLen= " << pcoLocParm.m_dZGrdLen
             << ";pcoLocParm.m_dZMin= " << pcoLocParm.m_dZMin
             << ";pcoLocParm.m_dXMax= " << pcoLocParm.m_dXMax
             << ";pcoLocParm.m_dXMin= " << pcoLocParm.m_dXMin
             << ";pcoLocParm.m_dYMax= " << pcoLocParm.m_dYMax
             << ";pcoLocParm.m_dXGrdLen = " << pcoLocParm.m_dXGrdLen
             << ";pcoLocParm.fx = " << pcoLocParm.fx << endl;
    }
    int vecSize = 1;
    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    //  setPCOCalChn(pcoCalChnParms, 1,  tmStmp,false);
    for (int ch = 0; ch < chns; ch++)
    {
        PureCommonOperation::PCOCalChn chn;
        chn.x = ch * 10 + 5;
        chn.y = 0;
        chn.z = 0;
        chn.enb = 1;
        chn.id = 1;
        chn.flag = 1;
        pcoCalChnParms.push_back(chn);
    }

    pcoParm.mining_fx = pcoLocParm.fx;
    pcoParm.mining_fy = pcoLocParm.fy;
    pcoParm.mining_fz = pcoLocParm.fz;

    pcoParm.outLen = point;
    pcoParm.coefBegPt = prepoint;

    bool istestCalMig = false; // 测试偏移 or 测试提取信号
    if (istestCalMig)
    {
        pcoParm.outLen = point;
        pcoParm.coefBegPt = prepoint;
    }

    auto valNum = 0;

    float **pOutSignal = new float *[chns];
    for (int ch = 0; ch < chns; ++ch)
    {
        pOutSignal[ch] = new float[pcoParm.outLen];
        memset(pOutSignal[ch], 0, sizeof(float) * pcoParm.outLen);
        // if (!pcoCalChnParms[ch].enb)
        //         continue;
        valNum++;
    }
    // auto wf_height = 1.0;
    // auto rslt02 = conn.executeQuery("SELECT wf_height FROM `e_info` ");
    // if (rslt02.next()) {
    //     wf_height = rslt02.getDouble("wf_height");
    // }

    auto iGrdNum =
        pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    float *pOut = new float[iGrdNum];
    memset(pOut, 0, sizeof(float) * iGrdNum);

    auto pretime = pcoParm.coefBegPt;
    //  cout<<" --- 112  --"<<" iGrdNum = "<<iGrdNum<<endl;
    float *pSpeedBtr = new float[iGrdNum];
    memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);

    string msg = (istestCalMig) ? "测试偏移" : "测试提取信号";
    cout << " useVType = " << useVType << " " << msg << ". 超前点数：" << pcoParm.coefBegPt << endl;
    float *pOut_tmp = new float[iGrdNum];
    memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

    if (useVType < 2)
    {

        float *pSpeedBtr = new float[iGrdNum];
        memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
        for (int i = 0; i < iGrdNum; i++)
        {
            if (useVType == 0)
            {
                pSpeedBtr[i] = speed_p;
            }
            else
            {
                pSpeedBtr[i] = speed_s;
            }
        }
        getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                     coal_z, layer_from, false);
        if (istestCalMig)
        {
            auto pretime2 = pretime * deltT;
            if (hzi::config.ms_mining_type == 1)
            {
            }
            else
            {
                PureCommonOperation::CalMigration(
                    pData, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                    pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                    pcoParm.ampType, hzi::config.ms_components);
            }
        }
    }
    else if (useVType == 2)
    {
        for (int type = 0; type < useVType; type++)
        {
            // float* pOut_tmp = new float[iGrdNum];
            // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);
            float *pSpeedBtr = new float[iGrdNum];
            memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
            for (int i = 0; i < iGrdNum; i++)
            {
                if (type == 0)
                {
                    pSpeedBtr[i] = speed_p;
                }
                else
                {
                    pSpeedBtr[i] = speed_s;
                }
            }
            getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                         coal_z, layer_from, false);
            if (istestCalMig)
            {
                auto pretime2 = pretime * deltT;
                if (hzi::config.ms_mining_type == 1)
                {
                }
                else
                {
                    PureCommonOperation::CalMigration(
                        pData, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                        pcoParm.ampType, hzi::config.ms_components);
                }
            }
        }
    }
    if (istestCalMig)
    {
        bool ret =
            saveResult(tmStmp, devId, iGrdNum, pcoLocParm, pOut_tmp, 0, 1, outType);

        hzi::serverStatus.lastSampTimes[7] = tmStmp;
    }
    if (!istestCalMig)
    {
        cout << " handleDataFrameVec_test " << endl;

        PureCommonOperation::handleDataFrameVec_test(
            pData, pcoParm, pOut, &pcoCalChnParms[0], &pcoLocParm, pSpeedBtr,
            pOutSignal, point, chns, deltT, prepoint, tmStmp);
        cout << " handleDataFrameVec_test  endl " << endl;

        if (true)
        {
            // 写文件
            //  auto pretime = 0;

            unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
            char *pHead2 = pHeadData2.get();
            *(double *)(pHead2) = (double)tmStmp;
            auto classId2 = *(uint8_t *)(pHead2 + 8) = 9;
            *(float *)(pHead2 + 9) = deltT;
            *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
            *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
            *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
            *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
            auto conn21 = hzi::config.pConnPool->getConnection();
            conn21.execute(
                "INSERT INTO "
                "e_mining_signaldata_frm_info "
                "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,"
                "frm_"
                "loc)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE samp_intvl= "
                "values(samp_intvl),valNum= "
                "values(valNum) , vecSize= values(vecSize),outLen= "
                "values(outLen)",
                (uint8_t)devId,  // dev_id
                tmStmp / 1000.0, // samp_time
                classId2,        // class_id
                deltT,           // curt_ch
                valNum,          // channels
                vecSize,
                pcoParm.outLen, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId2) /
                 std::to_string(tmStmp))
                    .c_str() // frm_loc
            );

            fs::path outSignalfileName(hzi::config.dataRoot);

            outSignalfileName /= relLocFromTime(tmStmp) /
                                 std::to_string(classId2) /
                                 std::to_string(tmStmp);
            try
            {
                auto dir = outSignalfileName.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(outSignalfileName,
                                         std::ofstream::binary);
                ofs_Signal.write(pHead2, 32);
                for (int ch = 0; ch < chns; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOutSignal[ch];
                    ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
                }
                ofs_Signal.close();
                //  return std::to_string(tmStmp);
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += outSignalfileName.string();
                msg += ":";
                msg += e.what();
                debugErr(msg);
                return "error";
            };
            //   auto classId =  10;
            float minpOut = *std::min_element(pOut, pOut + iGrdNum);
            float maxpOut = *std::max_element(pOut, pOut + iGrdNum);

            int32_t *p32 = (int32_t *)pOut;
            unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
            char *pHead = pHeadData.get();
            *(double *)(pHead) = (double)tmStmp;
            auto classId = *(uint8_t *)(pHead + 8) = 10;
            *(uint8_t *)(pHead + 9) = devId;
            *(uint16_t *)(pHead + 10) = pcoLocParm.m_iXGrdNum;
            *(uint16_t *)(pHead + 12) = pcoLocParm.m_iYGrdNum;
            *(uint16_t *)(pHead + 14) = pcoLocParm.m_iZGrdNum;
            *(int32_t *)(pHead + 16) = *((int32_t *)&minpOut);
            *(int32_t *)(pHead + 20) = *((int32_t *)&maxpOut);
            float dX = pcoLocParm.m_dXGrdLen;
            *(int32_t *)(pHead + 24) = *((int32_t *)&dX);

            auto conn2 = hzi::config.pConnPool->getConnection();
            conn2.execute(
                "INSERT INTO "
                "e_mining_pcodata_frm_info "
                "(dev_id,samp_time,class_id,XGrdNum,YGrdNum,ZGrdNum,frm_loc,validity)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE XGrdNum= values(XGrdNum),YGrdNum= "
                "values(YGrdNum),validity=values(validity)",
                (uint8_t)devId,        // dev_id
                tmStmp / 1000.0,       // samp_time
                classId,               // class_id
                pcoLocParm.m_iXGrdNum, // curt_ch
                pcoLocParm.m_iYGrdNum, // channels
                pcoLocParm.m_iZGrdNum, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId) /
                 std::to_string(tmStmp))
                    .c_str(), // frm_loc
                0
            );
            //   return std::to_string(tmStmp);

            fs::path fileName(hzi::config.dataRoot);

            fileName /= relLocFromTime(tmStmp) / std::to_string(classId) /
                        std::to_string(tmStmp);
            try
            {
                auto dir = fileName.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs(fileName, std::ofstream::binary);
                ofs.write(pHead, 32);
                ofs.write((char *)p32, iGrdNum * 4);
                ofs.close();
                // return std::to_string(tmStmp);
                // return fileName.string()''
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += fileName.string();
                msg += ":";
                msg += e.what();
                debugErr(msg);
                return "error";
            };
        }
    }

    return std::to_string(tmStmp);
}

/*
* 读取指定时间段内的提取文件（9），生成偏移图
*/
string handleExtSignalData_pianyi(uint64_t fromsampTime, uint64_t endsampTime)
{

    if (endsampTime <= fromsampTime)
    {
        return " error time";
    }
    auto tmStmp = nowMS();
    int vecSize0 = 0;
    int chns = 0;
    int pnts = 2048;
    float deltT = 0.2;
    int devId0 = 1;

    std::vector<string> pathVector;
    auto conn = hzi::config.pConnPool->getConnection();

    double fromtime = double(fromsampTime / 1000);
    double endtime = double(endsampTime / 1000);

    //读取9文件
    auto rslt11 = conn.executeQuery(
        "SELECT * FROM `e_mining_signaldata_frm_info`"
        " where  samp_time > FROM_UNIXTIME(?)  AND samp_time < FROM_UNIXTIME(?) "
        " AND outLen = ? and samp_intvl = ? ORDER BY samp_time ASC",
        fromtime, endtime, pnts, deltT);
    while (rslt11.next())
    {

        auto valNum = rslt11.getInt("valNum");
        auto vecSize = rslt11.getInt("vecSize");

        vecSize0 += vecSize;
        chns = valNum / vecSize;
        //  cout<<" valNum = "<<valNum<<" vecSize = "<<vecSize<<" chns = "<<chns<<endl;
        auto pathstr = rslt11.getString("frm_loc");
        pathVector.push_back(pathstr);
    }
    if (vecSize0 == 0 || chns == 0)
    {
        return " error vecSize";
    }
    if (hzi::config.verbose)
        cout << " vecSize0 = " << vecSize0 << " chns = " << chns << " pnts = " << pnts << endl;
    float **pOutSignal0 = new float *[vecSize0 * chns]; 
    for (int ch = 0; ch < vecSize0 * chns; ++ch)
    {
        pOutSignal0[ch] = new float[pnts];
        memset(pOutSignal0[ch], 0, sizeof(float) * pnts);
    }

    int index = 0;
    int prepoint0 = 0;

    string path = Config::dataRoot + "/";
    for (int i = 0; i < pathVector.size(); i++)
    {
        auto filePath = path + pathVector[i];
        if (!fs::exists(filePath))
            return " file Path error";

        auto pHead = std::make_unique<char[]>(32);
        std::ifstream ifs(filePath);
        ifs.read(pHead.get(), 32);
        auto valNum = *reinterpret_cast<int *>(pHead.get() + 13); // chns
        auto vecSize = *(uint16_t *)(pHead.get() + 17);
        // auto deltT = *(float*)(pHead.get() + 9);
        auto outLen = *reinterpret_cast<int *>(pHead.get() + 19);
        auto prepoint = *(uint32_t *)(pHead.get() + 23);
        auto devId = *(uint8_t *)(pHead.get() + 27);
        devId0 = (devId == 0) ? 1 : devId;
        prepoint0 = prepoint;
        int points = outLen;

        float **pData = new float *[valNum];//存从文件中读取的数据

        for (int ch = 0; ch < valNum; ++ch)
        {
            pData[ch] = new float[points];

            memset(pData[ch], 0, sizeof(float) * points);
        }
        float tmpf;
        for (int j = 0; j < valNum; ++j)
        {
            for (int k = 0; k < points; ++k)
            {
                ifs.read(reinterpret_cast<char *>(&tmpf), sizeof(float));
                pData[j][k] = tmpf;
            }
        }
        ifs.close();

        //把pData中数据拷贝到pOutSignal0
        for (int ch = 0; ch < valNum; ++ch)
        {
            for (int pt = 0; pt < pnts; pt++)
            {
                pOutSignal0[index][pt] = pData[ch][pt];
            }
            //  memcpy(pOutSignal0 + index,pData[ch], sizeof(float)*pnts);
            index++;
        }
        for (int ch = 0; ch < valNum; ++ch)
        {
            delete[] pData[ch];
        }
        delete[] pData;
    }
    bool outType = 0;
    float speed_p, speed_s = 0;
    auto useVType = 0; // 默认使用P波偏移
    PureCommonOperation::PCOSignalParm pcoParm;
    PureCommonOperation::PCOLocParm pcoLocParm;

    auto rslt = conn.executeQuery("SELECT * FROM `e_mining_PCOSignalParm_history`");

    if (rslt.next())
    {
        pcoParm.dcType = rslt.getInt("dcType");
        pcoParm.chnno = rslt.getInt("chn_no");
        pcoParm.coeLen = int(rslt.getInt("coeLen") * 60 * 1000 / deltT);
        pcoParm.outLen = rslt.getInt("outLen");       // 输出点数
        pcoParm.coefBegPt = rslt.getInt("coefBegPt"); // 超前点数
        pcoParm.biased = rslt.getInt("biased");
        pcoParm.extractMethod = rslt.getInt("extractMethod");
        // pcoParm.convLen = rslt.getInt("convLen");
        pcoParm.convLen = int(rslt.getInt("convLen") * 60 * 1000 / deltT);
        pcoParm.loCutF = rslt.getDouble("loCutF");
        pcoParm.hiCutF = rslt.getDouble("hiCutF");
        pcoParm.tranBW = rslt.getDouble("tranBW");
        pcoParm.isStop = rslt.getInt("isStop");
        pcoParm.wndFlag = rslt.getInt("wndFlag");
        pcoParm.isCut = rslt.getInt("isCut");
        pcoParm.isNotchCut = rslt.getInt("isNotchCut");

        pcoParm.Notch_jobs = rslt.getInt("Notch_jobs");
        pcoParm.NotchWn = rslt.getInt("NotchWn");
        pcoParm.NotchType = rslt.getInt("NotchType");

        string notchFStr = rslt.getString("notchF");
        // string tmpstr = notchFStr.substr(0, notchFStr.length() - 1);
        // pcoParm.notchF = atoi(tmpstr.c_str());
        pcoParm.notchF = atoi(notchFStr.c_str());

        pcoParm.isNotch_n = true;
        pcoParm.ampType = rslt.getInt("ampType");
        pcoParm.wndType = rslt.getInt("wndType");
        pcoParm.normalizedType = rslt.getInt("normalizedType");

        speed_p = rslt.getDouble("speed_p");
        speed_s = rslt.getDouble("speed_s");
        useVType = rslt.getInt("useVType");
        pcoLocParm.extensionAngle = rslt.getDouble("extensionAngle");
        pcoLocParm.is_exclude_directWaves = rslt.getInt("isExcludeDirectWaves");
        pcoLocParm.hasFouce = rslt.getInt("hasFouce");

        pcoParm.isSpikeDeconvolution = rslt.getInt("isSpikeDeconvolution");
        pcoParm.dcovLetPoint = int(rslt.getInt("dcovLetPoint") / deltT);
        pcoParm.deconvCoef = rslt.getDouble("deconvCoef");
        pcoParm.deAGCtype = rslt.getInt("deAGCtype");
        pcoParm.wnLen = int(rslt.getInt("wnLen") / deltT);
        pcoParm.expGainAlpha=rslt.getDouble("gainCoe");

        int cofLen2 = 2000;
        pcoParm.spikeDeCoeLen = int(cofLen2 / deltT);
        pcoLocParm.directWavesTimes = 10;

        pcoParm.isUseSlideWn = rslt.getInt("isUseSlideWn");
        pcoParm.slideWn = int(rslt.getInt("slideWn") * 1000 / deltT);

        pcoParm.isCalRandon = rslt.getInt("isCalRandon");
        pcoParm.fScale = rslt.getDouble("fScale");
        float v_min = rslt.getDouble("fPMin");
        pcoParm.fPMax = 1 / v_min;
        pcoParm.fPMin = 0 - pcoParm.fPMax;
        // pcoParm.fPMin = rslt.getDouble("fPMin");
        // pcoParm.fPMax = rslt.getDouble("fPMax");

        pcoParm.fPSpace = rslt.getDouble("fPSpace");
        pcoParm.bNegtiveV = rslt.getInt("bNegtiveV");
        pcoParm.CorrType = rslt.getInt("CorrType");
        outType = rslt.getInt("outType");
        pcoParm.interChnAmpEqual_type = rslt.getInt("interChnAmpEqualType");

        pcoParm.isShaping = rslt.getInt("isShaping");
        pcoParm.shapingRato = rslt.getDouble("shapingRato");
    }

    pcoParm.outLen = pnts;
    pcoParm.coefBegPt = prepoint0;
    pcoParm.is_extract = false;
    pcoParm.is_DataCorrect = false;

    double dateTime = (double)tmStmp / 1000.0;

    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(fromsampTime, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    // if (hzi::config.ms_mining_type == 2) {
    //     string sqlstr = "SELECT * FROM `e_tunnel_locInfo` WHERE tmstamp <= ";
    //     sqlstr += std::to_string(tmStmp);
    //     sqlstr += "  ORDER BY tmstamp DESC LIMIT 1";

    //     auto rslt2222 = conn.executeQuery(sqlstr.c_str());
    //     if(rslt2222.next()){
    //         pcoLocParm.m_locx = rslt2222.getDouble("mining_loc");
    //     }
    // }
    if (hzi::config.verbose)
        cout << "  pcoLocParm.m_locx = " << pcoLocParm.m_locx << endl;
    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }

    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }

    pcoParm.ms_components = hzi::config.ms_components;
    pcoLocParm.out_type = 1;

    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);
    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    cout << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
         << ";pcoLocParm.m_iZGrdNum = " << pcoLocParm.m_iZGrdNum
         << ";pcoLocParm.m_iYGrdNum = " << pcoLocParm.m_iYGrdNum
         << ";mark_len = " << pcoLocParm.mark_len
         << ";pcoLocParm.m_dZGrdLen= " << pcoLocParm.m_dZGrdLen
         << ";pcoLocParm.m_dZMin= " << pcoLocParm.m_dZMin
         << ";pcoLocParm.m_dXMax= " << pcoLocParm.m_dXMax
         << ";pcoLocParm.m_dXMin= " << pcoLocParm.m_dXMin
         << ";pcoLocParm.m_dYMax= " << pcoLocParm.m_dYMax
         << ";pcoLocParm.m_dXGrdLen = " << pcoLocParm.m_dXGrdLen
         << ";pcoLocParm.fx = " << pcoLocParm.fx << endl;
    // int vecSize = 1;
    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    setPCOCalChn(pcoCalChnParms, devId0, tmStmp, false);
    for (int i = 0; i < 3; i++)
    {
        pcoParm.dataChnNO[i] = pcoParm.chnno;
    }
    if (pcoParm.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            auto chn_no = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            auto is_out = rslt_comp.getInt("is_out");
            if (is_out)
                pcoLocParm.out_type = id;
            pcoParm.dataChnNO[id - 1] = chn_no_history;

            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num < pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                }
            }
        }
    }
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        //  pcoLocParm.is_exclude_directWaves = true;
        if (pcoParm.ms_components > 1)
        {
            auto chnno_tmp = pcoParm.dataChnNO[0];
            pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
        }
        else
        {
            pcoLocParm.fx = pcoCalChnParms[pcoParm.chnno - 1].x;
            pcoLocParm.fy = pcoCalChnParms[pcoParm.chnno - 1].y;
            pcoLocParm.fz = pcoCalChnParms[pcoParm.chnno - 1].z;
        }
    }

    pcoParm.mining_fx = pcoLocParm.fx;
    pcoParm.mining_fy = pcoLocParm.fy;
    pcoParm.mining_fz = pcoLocParm.fz;

    auto iGrdNum =
        pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;
    // pOut_tmp 单分量计算结果，pOut 考虑三分量进行累加
    float *pOut = new float[iGrdNum];
    memset(pOut, 0, sizeof(float) * iGrdNum);

    // 多分量分别设置
    for (int com = 0; com < pcoParm.ms_components; com++)
    {
        float *pOut_tmp = new float[iGrdNum];
        memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

        if (useVType < 2)
        {

            float *pSpeedBtr = new float[iGrdNum];
            memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
            for (int i = 0; i < iGrdNum; i++)
            {
                if (useVType == 0)
                {
                    pSpeedBtr[i] = speed_p;
                }
                else
                {
                    pSpeedBtr[i] = speed_s;
                }
            }
            getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                         coal_z, layer_from, false);
            auto pretime2 = prepoint0 * deltT;
            if (hzi::config.ms_mining_type == 1)
            {
            }
            else
            {
                PureCommonOperation::CalMigration(
                    pOutSignal0, pOut_tmp, &pcoCalChnParms[0], chns, vecSize0, deltT,
                    pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                    pcoParm.ampType, com + 1);
            }
        }
        else if (useVType == 2)
        {
            for (int type = 0; type < useVType; type++)
            {
                float *pSpeedBtr = new float[iGrdNum];
                memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                for (int i = 0; i < iGrdNum; i++)
                {
                    if (type == 0)
                    {
                        pSpeedBtr[i] = speed_p;
                    }
                    else
                    {
                        pSpeedBtr[i] = speed_s;
                    }
                }
                getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                             coal_z, layer_from, false);
                auto pretime2 = prepoint0 * deltT;
                if (hzi::config.ms_interface_type == 1)
                {
                }
                else
                {
                    PureCommonOperation::CalMigration(
                        pOutSignal0, pOut_tmp, &pcoCalChnParms[0], chns, vecSize0, deltT,
                        pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                        pcoParm.ampType, com + 1);
                }
            }
        }
        bool is_save = true;
        bool ret = saveResult(tmStmp, devId0, iGrdNum, pcoLocParm, pOut_tmp, com, is_save, outType);
    }

    return std::to_string(tmStmp);
}
// Function to parse FilterParm JSON data and convert it to structure
PCOFilterParm parseFilterParm(const rapidjson::Value &data)
{
    PCOFilterParm filterParm;
    if (data.HasMember("isCut"))
    {
        filterParm.isCut = data["isCut"].GetInt();
    }
    if (data.HasMember("convLen"))
    {
        filterParm.convLen = data["convLen"].GetInt();
    }
    if (data.HasMember("loCutF"))
    {
        filterParm.loCutF = data["loCutF"].GetFloat();
    }
    if (data.HasMember("hiCutF"))
    {
        filterParm.hiCutF = data["hiCutF"].GetFloat();
    }
    if (data.HasMember("tranBW"))
    {
        filterParm.tranBW = data["tranBW"].GetFloat();
    }
    if (data.HasMember("isStop"))
    {
        filterParm.isStop = data["isStop"].GetInt();
    }
    if (data.HasMember("wndFlag"))
    {
        filterParm.wndFlag = data["wndFlag"].GetInt();
    }
    if (data.HasMember("isNotchCut"))
    {
        filterParm.isNotchCut = data["isNotchCut"].GetInt();
    }
    if (data.HasMember("notchF"))
    {
        filterParm.notchF = data["notchF"].GetInt();
    }
    if (data.HasMember("isNotch_n"))
    {
        filterParm.isNotch_n = data["isNotch_n"].GetInt();
    }
    if (data.HasMember("Notch_jobs"))
    {
        filterParm.Notch_jobs = data["Notch_jobs"].GetInt();
    }
    if (data.HasMember("NotchWn"))
    {
        filterParm.NotchWn = data["NotchWn"].GetInt();
    }
    if (data.HasMember("NotchType"))
    {
        filterParm.NotchType = data["NotchType"].GetInt();
    }

    return filterParm;
}

// Function to parse SpikeDeconvolution JSON data and convert it to structure
PCOSpikeDeconvolution parseSpikeDeconvolution(const rapidjson::Value &data)
{
    PCOSpikeDeconvolution spikeDeconvolution;
    if (data.HasMember("isSpikeDeconvolution"))
        spikeDeconvolution.isSpikeDeconvolution = data["isSpikeDeconvolution"].GetBool();

    if (data.HasMember("spikeDeCoeLen"))
        spikeDeconvolution.spikeDeCoeLen = data["spikeDeCoeLen"].GetInt();
    if (data.HasMember("dcovLetPoint"))
        spikeDeconvolution.dcovLetPoint = data["dcovLetPoint"].GetInt();
    if (data.HasMember("deconvCoef"))
        spikeDeconvolution.deconvCoef = data["deconvCoef"].GetFloat();

    return spikeDeconvolution;
}

// Function to parse DeAGC JSON data and convert it to structure
PCODeAGC parseDeAGC(const rapidjson::Value &data)
{
    PCODeAGC deAGC;
    if (data.HasMember("deAGCtype"))
        deAGC.deAGCtype = data["deAGCtype"].GetInt();
    if (data.HasMember("wnLen"))
        deAGC.wnLen = data["wnLen"].GetInt();
    if (data.HasMember("gainCoe"))
        deAGC.expGainAlpha = data["gainCoe"].GetDouble();
    return deAGC;
}

// Function to parse CalRandon JSON data and convert it to structure
PCOCalRandon parseCalRandon(const rapidjson::Value &data)
{
    PCOCalRandon calRandon;
    if (data.HasMember("isCalRandon"))
    {
        calRandon.isCalRandon = data["isCalRandon"].GetBool();
    }
    if (data.HasMember("fScale"))
    {
        calRandon.fScale = data["fScale"].GetFloat();
    }
    // if (data.HasMember("fPMax")) {
    //     calRandon.fPMax = data["fPMax"].GetFloat();
    // }
    if (data.HasMember("fPMin"))
    {
        calRandon.fPMin = data["fPMin"].GetFloat();
        calRandon.fPMax = 1 / calRandon.fPMin;
        calRandon.fPMin = 0 - calRandon.fPMax;
    }

    if (data.HasMember("fPSpace"))
    {
        calRandon.fPSpace = data["fPSpace"].GetFloat();
    }
    if (data.HasMember("bNegtiveV"))
    {
        calRandon.bNegtiveV = data["bNegtiveV"].GetInt();
    }
    if (data.HasMember("mining_fx"))
    {
        calRandon.mining_fx = data["mining_fx"].GetFloat();
    }
    if (data.HasMember("mining_fy"))
    {
        calRandon.mining_fy = data["mining_fy"].GetFloat();
    }
    if (data.HasMember("mining_fz"))
    {
        calRandon.mining_fz = data["mining_fz"].GetFloat();
    }

    return calRandon;
}


/*
* 读取typeId类型文件，执行再提取算法流程，生成提取文件（99）
* typeId：文件类型，对该类型执行再提取算法流程
* methods：结构体，type-算法名称，pData-json格式的算法若干参数
*/
string  processMethods(uint64_t tmStmp, int typeId, const std::vector<ProcessingMethod> &methods)
{
    auto absPath = hzi::config.dataRoot / relLocFromTime(tmStmp) /
                   std::to_string(typeId);
    auto filePath = absPath / std::to_string(tmStmp);
    if (!fs::exists(filePath))
    {
        return "file not exists";
    }
    auto pHead = std::make_unique<char[]>(32);
    std::ifstream ifs(filePath);
    ifs.read(pHead.get(), 32);
    auto valNum = *reinterpret_cast<int *>(pHead.get() + 13); // chns
    auto vecSize = *(uint16_t *)(pHead.get() + 17);
    auto deltT = *(float *)(pHead.get() + 9);
    auto outLen = *reinterpret_cast<int *>(pHead.get() + 19);
    auto prepoint = *(uint32_t *)(pHead.get() + 23);
    auto devId = *(uint8_t *)(pHead.get() + 27);
    devId = (devId == 0) ? 1 : devId; // 根据devID 找到对应的通道

    auto sysType = *(uint8_t *)(pHead.get() + 28);
    auto imageType = *(uint8_t *)(pHead.get() + 29);

    // int chns = valNum/vecSize;  //多炮数据处理
    int points = outLen;
    float **pData = new float *[valNum];
    float **pOutSignal = new float *[valNum];

    for (int ch = 0; ch < valNum; ++ch)
    {
        pData[ch] = new float[points];
        pOutSignal[ch] = new float[points];
        memset(pOutSignal[ch], 0, sizeof(float) * points);
    }
    float tmpf;
    for (int j = 0; j < valNum; ++j)
    {
        for (int k = 0; k < points; ++k)
        {
            ifs.read(reinterpret_cast<char *>(&tmpf), sizeof(float));
            // v.at(j).at(k) = tmpf;
            pData[j][k] = tmpf;
        }
    }
    ifs.close();

    float speed_p, speed_s = 0;
    bool is_evenSpeed = 0;
    auto useVType = 0; // 默认使用P波偏移
    PureCommonOperation::PCOLocParm pcoLocParm;

    auto conn = hzi::config.pConnPool->getConnection();
    string sqlstr1;
    // 历史计算
    sqlstr1 = "SELECT * FROM `e_mining_PCOSignalParm_history`";
    bool outType = 0; // 偏移输出类型 0-偏移图 1-反射界面提取
    int chnno_yz = 1;
    int biased = 0;
    int outSurLineId = 0;
    int ampType, wndType, normalizedType = 0;
    auto rslt = conn.executeQuery(sqlstr1.c_str());
    if (rslt.next())
    {
        speed_p = rslt.getDouble("speed_p");
        speed_s = rslt.getDouble("speed_s");
        useVType = rslt.getInt("useVType");
        chnno_yz = rslt.getInt("chn_no");
        is_evenSpeed = rslt.getInt("is_evenSpeed");
        biased = rslt.getInt("biased");
        ampType = rslt.getInt("ampType");
        wndType = rslt.getInt("wndType");

        normalizedType = rslt.getInt("normalizedType");
        pcoLocParm.extensionAngle = rslt.getDouble("extensionAngle");
        pcoLocParm.is_exclude_directWaves = rslt.getInt("isExcludeDirectWaves");
        pcoLocParm.hasFouce = rslt.getInt("hasFouce");
        outType = rslt.getInt("outType");
        outSurLineId = rslt.getInt("outSurLineId");
    }

    double dateTime = (double)tmStmp / 1000.0;

    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(tmStmp, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    if (hzi::config.verbose)
        cout << "  pcoLocParm.m_locx = " << pcoLocParm.m_locx << endl;
    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }

    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }

    auto ms_components = hzi::config.ms_components;
    pcoLocParm.out_type = 1;

    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);
    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    // int vecSize = 1;
    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    setPCOCalChn(pcoCalChnParms, hzi::sysDevMask, tmStmp, false); // devId
    int chns = pcoCalChnParms.size();                             // 多炮数据处理
    int dataChnNO[3] = {0};
    for (int i = 0; i < 3; i++)
    {
        dataChnNO[i] = chnno_yz;
    }
    if (hzi::config.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            // auto chn_no  = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            // auto is_out  = rslt_comp.getInt("is_out");
            // if(is_out)pcoLocParm.out_type = id;
            dataChnNO[id - 1] = chn_no_history;

            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num < pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                }
            }
        }
    }
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        //  pcoLocParm.is_exclude_directWaves = true;
        if (hzi::config.ms_components > 1)
        {
            auto chnno_tmp = dataChnNO[0];
            pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
        }
        else
        {
            pcoLocParm.fx = pcoCalChnParms[chnno_yz - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_yz - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_yz - 1].z;
        }
    }
    if (hzi::config.ms_mining_type == 1)
    {
        auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
        while (rslt_surveyLine.next())
        {
            auto id = rslt_surveyLine.getInt("id");
            //    surveyLineCount = (id > surveyLineCount) ? id : surveyLineCount;
            auto chnsList = rslt_surveyLine.getString("chnsList");

            // std::vector<int> result
            auto chns_List = parseString(chnsList);

            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].id = id; // 测线id
                }
            }
        }
    }

    if (devId != hzi::sysDevMask)
    {
        // 指定测线数据处理 取对应基站的坐标 默认基站号与测线号对应
        pcoCalChnParms.erase(
            std::remove_if(
                pcoCalChnParms.begin(),
                pcoCalChnParms.end(),
                [devId](const PureCommonOperation::PCOCalChn &elem)
                {
                    return elem.id != devId;
                }),
            pcoCalChnParms.end());
        chns = pcoCalChnParms.size(); // 多炮数据处理
    }
    PureCommonOperation::PCOSignalParm pcoParm_tmp;
    pcoParm_tmp.ImageType = sysType;
    pcoParm_tmp.systemeType = imageType;
    pcoParm_tmp.ms_mining_type = hzi::config.ms_mining_type;
    if (hzi::config.ms_mining_type == 2)
        pcoParm_tmp.chnno == 1;

    PureCommonOperation::PCOExtractChn pChn_ext;
    setSignalChnInfo(pChn_ext, pcoCalChnParms, pcoParm_tmp, chns);
    auto chns_Count = valNum / vecSize;

    for (const auto &method : methods)
    {
        // if (hzi::config.verbose){
        //     std::cout << "Processing method type: " << method.type << std::endl;

        // }
        // 使用 rapidjson 提供的 API 访问 JSON 数据
        rapidjson::StringBuffer buffer;
        rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
        method.pData->Accept(writer);

        const char *jsonString = buffer.GetString();
        if (jsonString)
        {
            if (hzi::config.verbose)
            {
                std::cout << "Processing method type: " << method.type << std::endl;
                std::cout << method.type << ",Method data: " << jsonString << std::endl;
            }

            // 这里调用相应的处理方法
            if (method.type == "FilterParm")
            {
                // 使用 method.pData 指向的 JSON 数据，例如：
                // processFilterParm(*method.pData);
                PCOFilterParm filterParm = parseFilterParm(*method.pData);
                for (int vec = 0; vec < vecSize; vec++)
                {
                    for (int ch = 0; ch < chns_Count; ++ch)
                    {
                        int chNO = pChn_ext.chnNoVec[ch] - 1;
                        int chNO_coe = pChn_ext.coeChnNoVec[ch] - 1;
                        if (!pcoCalChnParms[chNO].enb)
                            continue; //|| !pcoCalChnParms[chNO_coe].enb

                        PureCommonOperation::Filter1dFD(pData[ch + vec * chns_Count], points, deltT,
                                                        filterParm.loCutF, filterParm.hiCutF, filterParm.tranBW,
                                                        filterParm.isStop);
                        if (filterParm.isNotchCut)
                        {
                            PureCommonOperation::NotchFilter1dFD(pData[ch + vec * chns_Count], points, deltT, filterParm.Notch_jobs, filterParm.NotchWn, filterParm.NotchType, filterParm.notchF);
                        }
                    }
                }
                //  cout<<" loCutF = "<<filterParm.loCutF<<endl;
            }
            else if (method.type == "SpikeDeconvolution")
            {
                PCOSpikeDeconvolution spikeDeconvolution = parseSpikeDeconvolution(*method.pData);
                for (int vec = 0; vec < vecSize; vec++)
                {
                    for (int ch = 0; ch < chns_Count; ++ch)
                    {
                        int chNO = pChn_ext.chnNoVec[ch] - 1;
                        int chNO_coe = pChn_ext.coeChnNoVec[ch] - 1;
                        if (!pcoCalChnParms[chNO].enb)
                            continue;
                        float *OutData_Deconvolution = new float[points];
                        memset(OutData_Deconvolution, 0, sizeof(float) * points);
                        PureCommonOperation::SpikeDeconvolution(pData[ch + vec * chns_Count], OutData_Deconvolution, points, spikeDeconvolution.spikeDeCoeLen, spikeDeconvolution.dcovLetPoint, spikeDeconvolution.deconvCoef, biased, prepoint);

                        memcpy(pData[ch + vec * chns_Count], OutData_Deconvolution, sizeof(float) * points);
                    }
                }
            }
            else if (method.type == "DeAGC")    //道内均衡
            {
                PCODeAGC deAGC = parseDeAGC(*method.pData);
                if(deAGC.deAGCtype==0 || deAGC.deAGCtype==1)    //AGC：为什么0-无也进行AGC？
                {
                    for (int vec = 0; vec < vecSize; vec++)
                    {
                        for (int ch = 0; ch < chns_Count; ++ch)
                        {
                            int chNO = pChn_ext.chnNoVec[ch] - 1;
                            int chNO_coe = pChn_ext.coeChnNoVec[ch] - 1;
                            if (!pcoCalChnParms[chNO].enb)
                                continue;
                            PureCommonOperation::DE_AGCGainCtrl(pData[ch + vec * chns_Count], points, deAGC.wnLen);
                        }
                    }
                }
                else if(deAGC.deAGCtype==2)     //指数增益
                {
                    for (int vec = 0; vec < vecSize; vec++)
                    {
                        for (int ch = 0; ch < chns_Count; ++ch)
                        {
                            int chNO = pChn_ext.chnNoVec[ch] - 1;
                            int chNO_coe = pChn_ext.coeChnNoVec[ch] - 1;
                            if (!pcoCalChnParms[chNO].enb)
                                continue;
                            PureCommonOperation::DE_ExpGainCtrl(pData[ch + vec * chns_Count], points, prepoint, deAGC.expGainAlpha, deltT/1000);
                        }
                    }
                }
                
            }
            else if (method.type == "CalRandon")
            {
                PCOCalRandon calRandon = parseCalRandon(*method.pData);
                CTPTransformation cTrans;
                for (int vec = 0; vec < vecSize; vec++)
                {
                    for (int i = 0; i < ms_components; i++)
                    {
                        for (int ch = 0; ch < chns_Count; ++ch)
                        {
                            int chNO = pChn_ext.chnNoVec[ch] - 1;
                            int chNO_coe = pChn_ext.coeChnNoVec[ch] - 1;
                            if (!pcoCalChnParms[chNO].enb)
                                continue;
                            if (pcoCalChnParms[chNO].flag != i + 1)
                                continue;
                            double yjg = PureCommonOperation::Distance(pcoLocParm.fx, pcoLocParm.fy, pcoLocParm.fz,
                                                                       pcoCalChnParms[chNO].x, pcoCalChnParms[chNO].y, pcoCalChnParms[chNO].z);
                            cTrans.Add(yjg, pData[ch + vec * chns_Count], points, deltT);
                        }
                        cTrans.SetFwdEnergyScale(calRandon.fScale);
                        cTrans.ForwardTransfromation(calRandon.fPMin, calRandon.fPMax, calRandon.fPSpace);
                        const vector<float *> &vtOutPut = cTrans.BackwardTransfromation(calRandon.bNegtiveV);
                        int index_tmp = 0;

                        for (int ch = 0; ch < chns_Count; ++ch)
                        {
                            int chNO = pChn_ext.chnNoVec[ch] - 1;
                            int chNO_coe = pChn_ext.coeChnNoVec[ch] - 1;
                            if (!pcoCalChnParms[chNO].enb)
                                continue;
                            if (pcoCalChnParms[chNO].flag != i + 1)
                                continue;
                            if (index_tmp < vtOutPut.size())
                            {
                                memcpy(pData[ch + vec * chns_Count], vtOutPut[index_tmp], sizeof(float) * points);
                            }
                            index_tmp++;
                        }
                        cTrans.Clear();
                    }
                }
            }
            else if (method.type == "Migration")
            {
                // 偏移
            }
        }
        else
        {
            std::cerr << "Failed to get JSON data." << std::endl;
        }
    }
    auto iGrdNum =
        pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;
    // pOut_tmp 单分量计算结果，pOut 考虑三分量进行累加
    bool isSavePianyi = true;
    float *pOut = new float[iGrdNum];
    memset(pOut, 0, sizeof(float) * iGrdNum);
    // 多分量分别设置
    for (int com = 0; com < ms_components; com++)
    {

        float *pOut_tmp = new float[iGrdNum];
        memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

        if (useVType < 2)
        {

            float *pSpeedBtr = new float[iGrdNum];
            memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
            for (int i = 0; i < iGrdNum; i++)
            {
                if (useVType == 0)
                {
                    pSpeedBtr[i] = speed_p;
                }
                else
                {
                    pSpeedBtr[i] = speed_s;
                }
            }
            getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                         coal_z, layer_from, false);
            auto pretime2 = prepoint * deltT;
            if (hzi::config.ms_mining_type == 1)
            {
                if (pcoParm_tmp.ImageType == 2)
                {
                    PureCommonOperation::CalMigration_mining(
                        pData, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        points, pretime2, pSpeedBtr, &pcoLocParm,
                        ampType, com + 1, pChn_ext, outSurLineId);
                }
                else
                {
                    isSavePianyi = false;
                }
            }
            else
            {
                PureCommonOperation::CalMigration(
                    pData, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                    points, pretime2, pSpeedBtr, &pcoLocParm,
                    ampType, com + 1);
            }
        }
        else if (useVType == 2)
        {
            for (int type = 0; type < useVType; type++)
            {
                float *pSpeedBtr = new float[iGrdNum];
                memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                for (int i = 0; i < iGrdNum; i++)
                {
                    if (type == 0)
                    {
                        pSpeedBtr[i] = speed_p;
                    }
                    else
                    {
                        pSpeedBtr[i] = speed_s;
                    }
                }
                getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                             coal_z, layer_from, false);
                auto pretime2 = prepoint * deltT;
                if (hzi::config.ms_mining_type == 1)
                {
                    if (pcoParm_tmp.ImageType == 2)
                    {
                        PureCommonOperation::CalMigration_mining(
                            pData, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            points, pretime2, pSpeedBtr, &pcoLocParm,
                            ampType, com + 1, pChn_ext, outSurLineId);
                    }
                    else
                    {
                        isSavePianyi = false;
                    }
                }
                else
                {
                    PureCommonOperation::CalMigration(
                        pData, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        points, pretime2, pSpeedBtr, &pcoLocParm,
                        ampType, com + 1);
                }
            }
        }
        bool is_save = false;
        if (isSavePianyi)
            bool ret =
                saveResult(tmStmp, devId, iGrdNum, pcoLocParm, pOut_tmp, com, is_save, outType);
    }

    // 写99文件
    if (true)
    {
        unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
        char *pHead2 = pHeadData2.get();
        *(double *)(pHead2) = (double)tmStmp;
        *(uint8_t *)(pHead2 + 8) = 9;   //这个字节存classid，为什么不是99？？
        *(uint8_t *)(pHead2 + 8) = 9;   //这个字节存classid，为什么不是99？？
        *(float *)(pHead2 + 9) = deltT;
        *(uint32_t *)(pHead2 + 13) = valNum;   // 可用通道总数
        *(uint16_t *)(pHead2 + 17) = vecSize;  // 数据分组数
        *(uint32_t *)(pHead2 + 19) = points;   // 数据长度
        *(uint32_t *)(pHead2 + 23) = prepoint; // 超前点数
        *(uint8_t *)(pHead2 + 27) = devId;     // 基站ID
        auto classId2 = 99;

        fs::path outSignalfileName(hzi::config.dataRoot);

        outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                             std::to_string(tmStmp);
        try
        {
            auto dir = outSignalfileName.parent_path();
            if (!fs::exists(dir))
            {
                fs::create_directories(dir);
            }
            std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
            ofs_Signal.write(pHead2, 32);
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < chns; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pData[ch + dex * chns];

                    ofs_Signal.write((char *)p32Signal, points * 4);
                }
            }
            ofs_Signal.close();
        }
        catch (std::exception &e)
        {
            string msg("error while writing to file:");
            msg += outSignalfileName.string();
            msg += ":";
            msg += e.what();
            debugErr(msg);
            return "error";
        };
    }
    return std::to_string(tmStmp);
}

// 根据时间戳读类型9的文件，进行信号处理
string  handleExtSignalData(uint64_t tmStmp, int typeId)
{
    // 开始处理信号
    //  auto classId = 9;
    auto absPath = hzi::config.dataRoot / relLocFromTime(tmStmp) /
                   std::to_string(typeId);
    auto filePath = absPath / std::to_string(tmStmp);
    if (!fs::exists(filePath))
    {
        return "file not exists";
    }
    auto pHead = std::make_unique<char[]>(32);
    std::ifstream ifs(filePath);
    ifs.read(pHead.get(), 32);
    auto valNum = *reinterpret_cast<int *>(pHead.get() + 13); // chns，9文件中的通道数
    auto vecSize = *(uint16_t *)(pHead.get() + 17);
    auto deltT = *(float *)(pHead.get() + 9);
    auto outLen = *reinterpret_cast<int *>(pHead.get() + 19);
    auto prepoint = *(uint32_t *)(pHead.get() + 23);
    auto devId = *(uint8_t *)(pHead.get() + 27);
    devId = (devId == 0) ? 1 : devId;

    auto sysType = *(uint8_t *)(pHead.get() + 28);
    auto imageType = *(uint8_t *)(pHead.get() + 29);

    // int chns = valNum/vecSize;  //多炮数据处理
    int points = outLen;
    float **pData = new float *[valNum];
    float **pOutSignal = new float *[valNum];

    for (int ch = 0; ch < valNum; ++ch)
    {
        pData[ch] = new float[points];
        pOutSignal[ch] = new float[points];
        memset(pOutSignal[ch], 0, sizeof(float) * points);
    }
    float tmpf;
    for (int j = 0; j < valNum; ++j)
    {
        for (int k = 0; k < points; ++k)
        {
            ifs.read(reinterpret_cast<char *>(&tmpf), sizeof(float));
            // v.at(j).at(k) = tmpf;
            pData[j][k] = tmpf;
        }
    }
    ifs.close();

    float speed_p, speed_s = 0;
    auto useVType = 0; // 默认使用P波偏移
    bool outType = 0;
    int outSurLineId = 0;
    int isUseCSP = 0;
    bool is_evenSpeed = 0;
    PureCommonOperation::PCOSignalParm pcoParm;
    PureCommonOperation::PCOLocParm pcoLocParm;
    bool ret = getPCO_parm(pcoParm, pcoLocParm, deltT, false, outType, outSurLineId, isUseCSP, useVType, is_evenSpeed, speed_p, speed_s);

    auto conn = hzi::config.pConnPool->getConnection();

    pcoParm.ImageType = sysType;
    pcoParm.systemeType = imageType;

    pcoParm.outLen = points;
    pcoParm.coefBegPt = prepoint;
    pcoParm.is_extract = false;
    pcoParm.is_DataCorrect = false;
    cout << "isCut: " << pcoParm.isCut << " ,isNotchCut: " << pcoParm.isNotchCut
         << " ,  pcoParm.notchF：" << pcoParm.notchF
         << " ,pcoParm.isNotch_n :" << pcoParm.isNotch_n
         << ",useVType = " << useVType << " , 反褶积： "
         << pcoParm.isSpikeDeconvolution << " 子波长度:" << pcoParm.dcovLetPoint
         << " , 白化系数：" << pcoParm.deconvCoef << " ,道内均衡 ："
         << pcoParm.deAGCtype << ", 窗口宽度 " << pcoParm.wnLen << endl;

    double dateTime = (double)tmStmp / 1000.0;

    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(tmStmp, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    // if (hzi::config.ms_mining_type == 2) {
    //     string sqlstr = "SELECT * FROM `e_tunnel_locInfo` WHERE tmstamp <= ";
    //     sqlstr += std::to_string(tmStmp);
    //     sqlstr += "  ORDER BY tmstamp DESC LIMIT 1";

    //     auto rslt2222 = conn.executeQuery(sqlstr.c_str());
    //     if(rslt2222.next()){
    //         pcoLocParm.m_locx = rslt2222.getDouble("mining_loc");
    //     }
    // }
    if (hzi::config.verbose)
        cout << "  pcoLocParm.m_locx = " << pcoLocParm.m_locx << endl;
    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }

    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }

    pcoParm.ms_components = hzi::config.ms_components;
    pcoLocParm.out_type = 1;

    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);
    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    cout << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
         << ";pcoLocParm.m_iZGrdNum = " << pcoLocParm.m_iZGrdNum
         << ";pcoLocParm.m_iYGrdNum = " << pcoLocParm.m_iYGrdNum
         << ";mark_len = " << pcoLocParm.mark_len
         << ";pcoLocParm.m_dZGrdLen= " << pcoLocParm.m_dZGrdLen
         << ";pcoLocParm.m_dZMin= " << pcoLocParm.m_dZMin
         << ";pcoLocParm.m_dXMax= " << pcoLocParm.m_dXMax
         << ";pcoLocParm.m_dXMin= " << pcoLocParm.m_dXMin
         << ";pcoLocParm.m_dYMax= " << pcoLocParm.m_dYMax
         << ";pcoLocParm.m_dXGrdLen = " << pcoLocParm.m_dXGrdLen
         << ";pcoLocParm.fx = " << pcoLocParm.fx
         << ";分量 = " << pcoParm.ms_components << endl;
    // int vecSize = 1;
    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    setPCOCalChn(pcoCalChnParms, hzi::sysDevMask, tmStmp, false); // devId
    int chns = pcoCalChnParms.size();                             // 多炮数据处理
    for (int i = 0; i < 3; i++)
    {
        pcoParm.dataChnNO[i] = pcoParm.chnno;
    }
    if (hzi::config.ms_mining_type == 1)
    {
        pcoParm.systemeType = sysType;
        pcoParm.ImageType = imageType;
        pcoParm.ms_mining_type = hzi::config.ms_mining_type;
    }
    if (pcoParm.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            auto chn_no = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            auto is_out = rslt_comp.getInt("is_out");
            if (is_out)
                pcoLocParm.out_type = id;
            pcoParm.dataChnNO[id - 1] = chn_no_history;
            //    cout<<" id = "<<id<<" chnsList = "<<chnsList<<" ,chn_no_history = "<<chn_no_history<<endl;
            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num < pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                }
            }
        }
    }
    int lineArry[3] = {0};
    // int mining_singalCount = 0;
    if (hzi::config.ms_mining_type == 1)
    {
        auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
        while (rslt_surveyLine.next())
        {
            auto id = rslt_surveyLine.getInt("id");
            //    surveyLineCount = (id > surveyLineCount) ? id : surveyLineCount;
            auto chnsList = rslt_surveyLine.getString("chnsList");

            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            lineArry[id - 1] = chns_List.size();
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].id = id; // 测线id
                                                     //   cout<<" 通道号："<<num<<" 测线："<<id<<endl;
                }
            }
        }
        //  mining_singalCount = getSignalChnCount(pcoParm.systemeType ,pcoParm.ImageType,lineArry[0],lineArry[1],lineArry[2],hzi::config.ms_components);

        for (int i = 0; i < 3; i++)
        {
            if (devId != hzi::sysDevMask)
            {
                if (lineArry[i] != 0 && devId == i + 1)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
            else
            {
                if (lineArry[i] != 0)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
        }
    }
    cout << "devId =  " << std::to_string(devId) << ",hzi::sysDevMask = " << hzi::sysDevMask << ",chns = " << std::to_string(chns) << " valNum = " << valNum << endl;
    if (devId != hzi::sysDevMask)
    {
        // 指定测线数据处理 取对应基站的坐标 默认基站号与测线号对应
        cout << "111" << endl;
        pcoCalChnParms.erase(
            std::remove_if(
                pcoCalChnParms.begin(),
                pcoCalChnParms.end(),
                [devId](const PureCommonOperation::PCOCalChn &elem)
                {
                    return elem.id != devId;
                }),
            pcoCalChnParms.end());
        chns = pcoCalChnParms.size();
    }
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        //  pcoLocParm.is_exclude_directWaves = true;
        if (pcoParm.ms_components > 1)
        {
            auto chnno_tmp = pcoParm.dataChnNO[0];
            pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
        }
        else
        {
            pcoLocParm.fx = pcoCalChnParms[pcoParm.chnno - 1].x;
            pcoLocParm.fy = pcoCalChnParms[pcoParm.chnno - 1].y;
            pcoLocParm.fz = pcoCalChnParms[pcoParm.chnno - 1].z;
        }
    }
    pcoParm.mining_fx = pcoLocParm.fx;
    pcoParm.mining_fy = pcoLocParm.fy;
    pcoParm.mining_fz = pcoLocParm.fz;
    PureCommonOperation::PCOExtractChn pcoExtractChnParms;
    // vector<PureCommonOperation::PCOExtractChn> pcoExtractChnParms;
    setSignalChnInfo(pcoExtractChnParms, pcoCalChnParms, pcoParm, chns);
    pcoParm.chns_Count = valNum / vecSize;

    // 采煤机定位 随采采煤机定位 从数据库中获取
    if (hzi::config.ms_mining_type == 1)
    {
        string sql(
            "SELECT * FROM `e_mining_signaldata_frm_info` WHERE samp_time = FROM_UNIXTIME((");
        sql += std::to_string(tmStmp);
        sql += ")/1000)";
        auto rslt13 = conn.executeQuery(sql.c_str());
        if (rslt13.next())
        {
            pcoLocParm.fx = rslt13.getDouble("fx");
            pcoLocParm.fy = rslt13.getDouble("fy");
            pcoLocParm.fz = rslt13.getDouble("fz");
            pcoLocParm.dis_y = rslt13.getDouble("dis");
        }
    }

    cout << " handleSignalData pcoParm.chns_Count 2 = " << pcoParm.chns_Count << " , size = " << pcoExtractChnParms.count
         << ", pcoLocParm.fx = " << pcoLocParm.fx
         << ", pcoLocParm.fy = " << pcoLocParm.fy
         << ", pcoLocParm.fz = " << pcoLocParm.fz << endl;

    PureCommonOperation::handleSignalData(pData, pcoParm, &pcoCalChnParms[0], pOutSignal, vecSize,
                                          points, chns, deltT, prepoint, pcoExtractChnParms);
    cout << " handleSignalData  endl isUseCSP = " << isUseCSP << ",useVType = " << useVType << ",pcoParm.ms_components = " << pcoParm.ms_components << endl;
    bool isSavePianyi = true;
    if (isUseCSP != 0 && hzi::config.ms_mining_type == 1)
    {
        // 随采 散射 CSP道集提取
        if (hzi::config.ms_mining_type == 1 && pcoParm.ImageType == 0)
        {
            PureCommonOperation::CSPTraceParm cspParm;
            cspParm.nComponentCount = hzi::config.ms_components;
            cspParm.iCalTraces = pcoExtractChnParms.count;
            cspParm.nSamplePoints = pcoParm.outLen - pcoParm.coefBegPt;
            cspParm.fSampleInterval = deltT;
            cspParm.nAdvanPoints = 0; // pcoParm.coefBegPt
            cspParm.fPV = speed_p;
            cspParm.fSV = speed_s;
            int surLineNum = (pcoParm.systemeType == 0) ? 2 : ((pcoParm.systemeType == 1) ? 1 : 3);

            float **pSignal = new float *[valNum];
            for (int ch = 0; ch < valNum; ++ch)
            {
                // pSignal[ch] = new float[cspParm.nSamplePoints];
                pSignal[ch] = new float[static_cast<int>(cspParm.nSamplePoints)];
                for (int i = 0; i < cspParm.nSamplePoints; i++)
                {
                    pSignal[ch][i] = pOutSignal[ch][i + pcoParm.coefBegPt];
                }
            }

            getCSPTrace(tmStmp, pSignal, pcoCalChnParms, cspParm, pcoLocParm,
                        pcoExtractChnParms, surLineNum);
        }
    }
    else
    {
        auto iGrdNum =
            pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;
        // pOut_tmp 单分量计算结果，pOut 考虑三分量进行累加
        float *pOut = new float[iGrdNum];
        memset(pOut, 0, sizeof(float) * iGrdNum);
        // 多分量分别设置

        for (int com = 0; com < pcoParm.ms_components; com++)
        {

            float *pOut_tmp = new float[iGrdNum];
            memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

            // auto pretime = pcoParm.coefBegPt;

            if (useVType < 2)
            {

                float *pSpeedBtr = new float[iGrdNum];
                memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                for (int i = 0; i < iGrdNum; i++)
                {
                    if (useVType == 0)
                    {
                        pSpeedBtr[i] = speed_p;
                    }
                    else
                    {
                        pSpeedBtr[i] = speed_s;
                    }
                }
                getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                             coal_z, layer_from, false);
                auto pretime2 = prepoint * deltT;
                if (hzi::config.ms_mining_type == 1)
                {
                    if (pcoParm.ImageType == 2)
                    {
                        cout << " CalMigration_mining " << pcoCalChnParms.size() << endl;
                        PureCommonOperation::CalMigration_mining(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                            pcoParm.ampType, com + 1, pcoExtractChnParms, outSurLineId);
                        cout << " CalMigration_mining endl" << endl;
                    }
                    else
                    {
                        isSavePianyi = false;
                    }
                }
                else
                {
                    PureCommonOperation::CalMigration(
                        pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                        pcoParm.ampType, com + 1);
                }
            }
            else if (useVType == 2)
            {
                for (int type = 0; type < useVType; type++)
                {
                    float *pSpeedBtr = new float[iGrdNum];
                    memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                    for (int i = 0; i < iGrdNum; i++)
                    {
                        if (type == 0)
                        {
                            pSpeedBtr[i] = speed_p;
                        }
                        else
                        {
                            pSpeedBtr[i] = speed_s;
                        }
                    }
                    getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                                 coal_z, layer_from, false);
                    auto pretime2 = prepoint * deltT;
                    if (hzi::config.ms_mining_type == 1)
                    {
                        if (pcoParm.ImageType == 2)
                        {
                            cout << " CalMigration_mining  2" << endl;
                            PureCommonOperation::CalMigration_mining(
                                pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                                pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                                pcoParm.ampType, com + 1, pcoExtractChnParms, outSurLineId);
                        }
                        if (pcoParm.ImageType != 2)
                            isSavePianyi = false;
                    }
                    else
                    {
                        PureCommonOperation::CalMigration(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                            pcoParm.ampType, com + 1);
                    }
                }
            }

            if (isSavePianyi)
                bool ret =
                    saveResult(tmStmp, devId, iGrdNum, pcoLocParm, pOut_tmp, com, true, outType);
        }
    }

    if (true)
    {
        // 写文件
        unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
        char *pHead2 = pHeadData2.get();
        *(double *)(pHead2) = (double)tmStmp;
        *(uint8_t *)(pHead2 + 8) = 9;
        *(float *)(pHead2 + 9) = deltT;
        *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
        *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
        *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
        *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
        *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
        *(uint8_t *)(pHead2 + 28) = sysType;
        *(uint8_t *)(pHead2 + 29) = imageType;
        auto classId2 = 99;//再提取文件

        fs::path outSignalfileName(hzi::config.dataRoot);

        outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                             std::to_string(tmStmp);
        try
        {
            auto dir = outSignalfileName.parent_path();
            if (!fs::exists(dir))
            {
                fs::create_directories(dir);
            }
            std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
            ofs_Signal.write(pHead2, 32);
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < pcoParm.chns_Count; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOutSignal[ch + dex * pcoParm.chns_Count];

                    ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
                }
            }
            ofs_Signal.close();
        }
        catch (std::exception &e)
        {
            string msg("error while writing to file:");
            msg += outSignalfileName.string();
            msg += ":";
            msg += e.what();
            debugErr(msg);
            return "error";
        };
    }

    return std::to_string(tmStmp);
}
// 铁建随掘 同一个基站该时间内的多个文件合并
//fromsampTime，endsampTime单位为s
tl::expected<DataFrame, string> mergeMs_tunnel(
    uint64_t fromsampTime,
    uint64_t endsampTime)
{ // 多并一，自电并到激电
    if (endsampTime <= fromsampTime)
    {
        return tl::make_unexpected(
            "mergeMs_tunnel DataFrame::merge error: negative from point");
    }

    string logstr = "mergeMs_tunnel 开始时间: ";
    logstr += std::to_string(fromsampTime);
    logstr += " 结束时间： ";
    logstr += std::to_string(endsampTime);
    debugLog(logstr);

    auto pnts0 = 0;
    auto chns0 = 0;
    auto pnts = 0;
    double fromtime = double(fromsampTime / 1000);
    double endtime = double(endsampTime / 1000);
    std::vector<string> pathVector;
    std::map<double, double> timeStampMap;
    auto conn = hzi::config.pConnPool->getConnection();

    auto rslt0 = conn.executeQuery(
        "select channels,count(1) as number from e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?)  GROUP BY channels ORDER BY "
        "count(1) desc limit 1",
        hzi::mining_classId, fromtime, endtime);
    if (rslt0.next())
    {
        chns0 = rslt0.getInt("channels");
    }
    auto rslt_tunnel = conn.executeQuery(
        " SELECT UNIX_TIMESTAMP(start_time),"
        "UNIX_TIMESTAMP(end_time),start_mining_locx,end_mining_locx "
        "FROM `e_tunnel_RunningDataInfo` "
        " WHERE is_running = 1 and  end_time >= FROM_UNIXTIME(?) "
        "and start_time <=FROM_UNIXTIME(?)  ORDER BY start_time ASC",
        fromtime, endtime);
    while (rslt_tunnel.next())
    {
        auto time_start = rslt_tunnel.getDouble("UNIX_TIMESTAMP(start_time)");
        auto time_end = rslt_tunnel.getDouble("UNIX_TIMESTAMP(end_time)");
        if (time_start < fromtime)
        {
            time_start = fromtime;
        }
        if (time_end > endtime)
        {
            time_end = endtime;
        }
        // cout<<"time_start = "<<std::to_string(time_start) <<" time_end =
        // "<<std::to_string(time_end)<<endl;
        timeStampMap.insert_or_assign(time_start, time_end);
    }

    for (auto &timeMap : timeStampMap)
    {
        cout << " start_time = " << std::to_string(timeMap.first)
             << "  end_time = " << std::to_string(timeMap.second) << endl;
        auto start_time = timeMap.first;
        auto end_time = timeMap.second;
        auto rslt = conn.executeQuery(
            "SELECT samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
            " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
            "  AND samp_time < FROM_UNIXTIME(?)  AND channels = ? ORDER BY "
            "samp_time ASC",
            hzi::mining_classId, start_time, end_time, chns0);
        while (rslt.next())
        {
            pnts0 = rslt.getInt("ch_pnts");
            // chns0 = rslt.getInt("channels");
            auto pathstr = rslt.getString("frm_loc");
            pnts += pnts0;
            pathVector.push_back(pathstr);
        }
    }

    cout << "pnts0 = " << pnts0 << " pnts = " << pnts << " chns0 =" << chns0
         << endl;

    if (pnts0 == 0 || pnts == 0 || chns0 == 0)
        return tl::make_unexpected(
            "DataFrame::merge: The data for that time period is empty");
    DataFrame newDF(chns0, pnts);
    string path = Config::dataRoot + "/";
    for (int i = 0; i < pathVector.size(); i++)
    {
        auto filePath = path + pathVector[i];
        //  cout<<" i = "<<i<<"  path = "<<pathVector[i]<<endl;;
        if (!fs::exists(filePath))
            return tl::make_unexpected("DataFrame::merge: file Path error");
        std::ifstream ifs(filePath);
        auto fileSize = fs::file_size(filePath);
        DataFrame fileDF(chns0, pnts0);
        ifs.read(fileDF.upHead.get(), 32);
        // ifs.seekg(0);
        ifs.read(fileDF.upData.get(), fileSize - 32);
        ifs.close();
        if (i == 0)
        {
            memcpy(newDF.upHead.get(), fileDF.upHead.get(), 32);
            newDF.setPoints(pnts);
        }

        for (int ch = 0; ch < chns0; ch++)
        {
            memcpy(newDF.upData.get() + ch * pnts * 4 + i * pnts0 * 4,
                   fileDF.upData.get() + ch * pnts0 * 4, pnts0 * 4);
        }
    }

    return std::move(newDF);
}
// 从数据库读取参数信息
string getEngDenityParm(uint64_t fromsampTime, uint64_t endsampTime, int channels, int classId, bool flag)
{
    // string retStr = "";
    auto conn = hzi::config.pConnPool->getConnection();
    std::vector<ParmEngDenity> engParmList;
    auto rslt0 = conn.executeQuery("SELECT * FROM `e_tunnel_pickDateTime`");
    while (rslt0.next())
    {
        ParmEngDenity engParm;
        auto chnno = rslt0.getInt("chnno");
        auto min = rslt0.getDouble("min");
        auto max = rslt0.getDouble("max");
        auto rate = rslt0.getDouble("rate");
        auto low = rslt0.getDouble("low");
        auto engWn = rslt0.getInt("engWn");
        auto wn = rslt0.getInt("wn");
        if (min < 0 || min > 1)
            return "最小能量比例参数有误";

        float sumvalue = 0.0;
        uint64_t points = 0;
        uint64_t fromsampTime0 = endsampTime - engWn * 60 * 60 * 1000;
        bool flag2 = getWnEng(fromsampTime0, endsampTime, channels, classId, chnno, sumvalue, points);
        //    cout<<" getWnEng flag2 = "<<flag2<<" points = "<<std::dec<<points<<" sumvalue = "<<sumvalue<<endl;
        if (flag2 && points > 0)
        {
            engParm.wnEngValue = sumvalue / points;
        }
        else
        {

            return " 获取平均能量失败";
        }
        engParm.engWn = engWn;
        engParm.low = low;
        engParm.chnno = chnno;
        engParm.minValue = engParm.wnEngValue * (1 - min);
        engParm.maxValue = engParm.wnEngValue * (1 + max);
        if (flag)
        {
            engParm.wn = hzi::miningDateLen * 60;
        }
        else
        {
            engParm.wn = wn * 60;
        }

        engParm.rate = rate;
        engParm.locX = 0.0;
        //  cout<<"wnEngValue = "<<engParm.wnEngValue<<";minValue = "<<engParm.minValue<<";maxValue = "<<engParm.maxValue<<endl;
        engParmList.push_back(engParm);
    }
    if (engParmList.size() > 0)
    {
        readEngDenity(fromsampTime, endsampTime, channels, classId, engParmList, flag);
    }
    else
    {
        return "e_tunnel_pickDateTime 表数据 为空";
    }
    return "success";
}

bool getWnEng(uint64_t fromsampTime, uint64_t endsampTime, int channels, int classId, int chnno, float &sumvalue, uint64_t &points)
{
    bool flag = false;

    uint64_t midnite = midnight(endsampTime);
    uint64_t endSampTime = endsampTime - midnite; // 当日相对采样时刻(ms)
    uint64_t fromSampTime = 0;
    if (fromsampTime < midnite)
    {
        bool flag_tmp = getWnEng(fromsampTime, midnite - 1, channels, classId, chnno, sumvalue, points);
        // if(!flag_tmp)return flag_tmp;
    }
    else
    {
        fromSampTime = fromsampTime - midnite;
    }
    // uint64_t fromSampTime =(fromsampTime > midnite) ? (fromsampTime - midnite) : 0 ;  // 当日相对采样时刻(ms) 暂时不考虑跨日
    double endtime = ((double)endSampTime) / 1000.0;
    double fromtime = ((double)fromSampTime) / 1000.0;

    uint16_t du_end = std::floor(endtime * 256 / 3600);
    uint16_t du_from = std::floor(fromtime * 256 / 3600);

    uint32_t pixelWidth = 24 * 256;
    auto size1 = channels * pixelWidth * 4;
    auto size2 = channels * pixelWidth * 8;
    auto size3 = channels * pixelWidth * 16;

    auto absPath = hzi::config.dataRoot / relLocFromTime(endsampTime) /
                   std::to_string(classId);
    auto filePath = absPath / string("digest_256.dat");
    auto fileSize = fs::file_size(filePath);

    auto pData = std::make_unique<char[]>(size1);                     // 极值
    auto pData2 = std::make_unique<char[]>(size1);                    // 点数
    auto pData3 = std::make_unique<char[]>(fileSize - size1 - size1); // 能量和

    std::ifstream ifs(filePath);
    if (!ifs.is_open())
    {
        std::cerr << "Error opening file: " << filePath << std::endl;
        return flag;
    }

    ifs.read(pData.get(), size1);
    ifs.read(pData2.get(), size1);
    ifs.read(pData3.get(), fileSize - size1 - size1);
    // 关闭文件
    ifs.close();

    int32_t *p32 = (int32_t *)pData.get();
    int32_t *p32_2 = (int32_t *)pData2.get();
    int64_t *p64 = (int64_t *)pData3.get();

    for (int du = du_from; du <= du_end; du++)
    {

        int chn = chnno;

        auto loc = (chn - 1) * pixelWidth + du; // 数据位置
                                                // float Value1 = (float)p32[loc]* 3.0 / 8388607.0;
                                                //  float sumPoint = p32_2[loc];
                                                //  float value = 0.0;
        float sumValue0 = (float)p64[loc] * 3.0 / 8388607.0;
        sumvalue += sumValue0 * 1000.0;
        points += p32_2[loc];
    }
    flag = true;
    //  cout<<" points = "<<std::dec<<points<<" sumvalue = "<<sumvalue<<endl;

    return flag;
}
// endsampTime 是最新数据时间 fromsampTime是上次结束的时间
void readEngDenity(uint64_t fromsampTime, uint64_t endsampTime, int channels, int classId, std::vector<ParmEngDenity> engParmList, bool flag)
{

    if (engParmList.size() < 1)
        return;
    auto wn = engParmList[0].wn;
    auto locX = engParmList[0].locX;
    uint64_t midnite = midnight(endsampTime);
    uint64_t endSampTime = endsampTime - midnite;                                    // 当日相对采样时刻(ms)
    uint64_t fromSampTime = (fromsampTime > midnite) ? (fromsampTime - midnite) : 0; // 当日相对采样时刻(ms) 暂时不考虑跨日
    double endtime = ((double)endSampTime) / 1000.0;
    double fromtime = ((double)fromSampTime) / 1000.0;
    if (endtime - fromtime < wn)
    {
        return;
    }
    // cout<<"wn = "<<wn<<endl;
    uint16_t du_end = std::floor(endtime * 256 / 3600);
    uint16_t du_from = std::floor(fromtime * 256 / 3600);
    uint16_t count = std::floor(wn * 256 / 3600) + 1;

    uint32_t pixelWidth = 24 * 256;
    auto size1 = channels * pixelWidth * 4;
    auto size2 = channels * pixelWidth * 8;
    auto size3 = channels * pixelWidth * 16;

    // cout<<" count = "<<count<<" endtime = "<<endtime<<" fromtime = "<<fromtime
    //     <<" du_end = "<<du_end<<" du_from = "<<du_from<<endl;

    auto absPath = hzi::config.dataRoot / relLocFromTime(endsampTime) /
                   std::to_string(classId);
    auto filePath = absPath / string("digest_256.dat");
    auto fileSize = fs::file_size(filePath);

    auto pData = std::make_unique<char[]>(size1);                     // 极值
    auto pData2 = std::make_unique<char[]>(size1);                    // 点数
    auto pData3 = std::make_unique<char[]>(fileSize - size1 - size1); // 能量和
    // 1695751200000 1695751800000
    // 打开文件
    std::ifstream ifs(filePath);
    if (!ifs.is_open())
    {
        std::cerr << "Error opening file: " << filePath << std::endl;
        return;
    }

    ifs.read(pData.get(), size1);
    ifs.read(pData2.get(), size1);
    ifs.read(pData3.get(), fileSize - size1 - size1);
    // 关闭文件
    ifs.close();

    int32_t *p32 = (int32_t *)pData.get();
    int32_t *p32_2 = (int32_t *)pData2.get();
    int64_t *p64 = (int64_t *)pData3.get();

    std::map<int, std::vector<float>> chnMap;
    for (int i = 0; i < engParmList.size(); i++)
    {
        int chn = engParmList[i].chnno;
        std::vector<float> pmatchlist;
        chnMap[chn] = pmatchlist;
    }
    bool is_getConstLength = false;
    int du_last = 0;
    bool is_match = false;
    for (int du = du_from; du <= du_end; du++)
    {
        for (int i = 0; i < engParmList.size(); i++)
        {
            int chn = engParmList[i].chnno;
            // cout<<"chn = "<<chn<<endl;
            //  std::vector<float> pmatchlist;
            auto loc = (chn - 1) * pixelWidth + du; // 数据位置
            float Value1 = (float)p32[loc] * 3.0 / 8388607.0;
            float sumPoint = p32_2[loc];
            float value = 0.0;
            float sumValue = (float)p64[loc] * 3.0 / 8388607.0;
            if (sumPoint > 0)
                value = float(sumValue / sumPoint) * 1000.0; // 单位mv
            // cout<<"chn = "<<std::to_string(chn)<<",du = "<<std::to_string(du)<<",sumValue = "<<std::to_string(sumValue)
            //     <<",sumPoint = "<<std::to_string(sumPoint)
            //     <<",value = "<<std::to_string(value)<<endl;

            chnMap[chn].push_back(value);
            if (chnMap[chn].size() == count)
            {
                is_getConstLength = true;
            }
        }
        du_last = du;
        if (is_getConstLength)
        {
            // 进行比较，如果数据满足条件 continue;进行下一个通道验证
            bool ret = matchValue(chnMap, engParmList);

            if (ret)
            {
                // 应该跳出循环 记录起始时间 入库，记录最后时间即可，前面的时间可用 减去时窗
                is_match = true;
                break;
            }
            else
            {
                for (int i = 0; i < engParmList.size(); i++)
                {
                    int chn = engParmList[i].chnno;

                    vector<float>::iterator k = chnMap[chn].begin();
                    chnMap[chn].erase(k); // 删除第一个元素
                    is_getConstLength = false;
                }
            }
        }
    }
    if (is_match)
    {
        auto lasttime = std::floor((du_last + 1) * 3600 / 256);
        uint64_t lastSamptime = midnite + lasttime * 1000;
        uint64_t lastSamp_fromtime = lastSamptime - wn * 1000;
        // 记录时间计算

        insertTunnelDataInfo(lastSamp_fromtime, lastSamptime, 1, locX,
                             locX, 1, 1);
        hzi::fromToEndMap.insert({lastSamp_fromtime, lastSamptime});
        if (flag)
            hzi::laststamp = lastSamptime;
        // hzi::fromToEndMap[lastSamp_fromtime] = lastSamptime;
        readEngDenity(lastSamptime, endsampTime, channels, classId, engParmList, flag);
    }
}

bool matchValue(std::map<int, std::vector<float>> datamap, std::vector<ParmEngDenity> engParmList)
{
    // bool ret = false;
    bool is_eff = false;
    for (auto &tmpmap : datamap)
    {
        auto chn = tmpmap.first;
        auto dataVec = tmpmap.second;
        int count_eff = 0;
        for (int index = 0; index < engParmList.size(); index++)
        {
            if (chn == engParmList[index].chnno)
            {
                float min = engParmList[index].minValue;
                float max = engParmList[index].maxValue;
                float low = engParmList[index].low;
                float rate = engParmList[index].rate;
                // cout<<" chn = "<<std::to_string(chn)<<" ";

                for (int i = 0; i < dataVec.size(); i++)
                {
                    auto value = dataVec[i];
                    //   cout<<" "<<value<<" ";
                    if (value >= min && value <= max && value >= low)
                        count_eff++;
                }
                double rate_eff = (double)count_eff * 1.0 / dataVec.size();
                //   cout<<" rate_eff = "<<rate_eff<<endl;
                is_eff = (rate_eff >= rate) ? true : false;
                if (!is_eff)
                    return is_eff;
            }
        }
    }

    return is_eff;
}

void mergeEngDenity(uint64_t fromsampTime, uint64_t endsampTime)
{
    if (endsampTime <= fromsampTime)
    {
        cout << "DataFrame::merge error: negative from point" << endl;
        return;
    }

    string logstr = "mergeEngDenity 开始时间: ";
    logstr += std::to_string(fromsampTime);
    logstr += " 结束时间： ";
    logstr += std::to_string(endsampTime);
    logstr += " 数据类型： ";
    logstr += std::to_string(hzi::mining_classId);
    debugLog(logstr);
    auto pnts0 = 0;
    auto chns0 = 0;
    auto pnts = 0;

    std::vector<string> pathVector;
    auto conn = hzi::config.pConnPool->getConnection();

    double fromtime = double(fromsampTime / 1000);
    double endtime = double(endsampTime / 1000);
    int classID = 3;

    auto rslt0 = conn.executeQuery(
        "select channels,count(1) as number from e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?)  GROUP BY channels ORDER BY "
        "count(1) desc limit 1",
        classID, fromtime, endtime);
    if (rslt0.next())
    {
        chns0 = rslt0.getInt("channels");
    }
    //,
    auto rslt = conn.executeQuery(
        "SELECT samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
        " where class_id= ?  AND samp_time >= FROM_UNIXTIME(?) "
        "  AND samp_time <= FROM_UNIXTIME(?)  AND channels = ? ORDER BY "
        "samp_time ASC",
        classID, fromtime, endtime, chns0);
    while (rslt.next())
    {
        pnts0 = rslt.getInt("ch_pnts");
        // chns0 = rslt.getInt("channels");
        auto pathstr = rslt.getString("frm_loc");
        pnts += pnts0;
        pathVector.push_back(pathstr);
    }

    if (pnts0 == 0 || pnts == 0 || chns0 == 0)
        return;

    string path = Config::dataRoot + "/";
    if (hzi::config.verbose)
        cout << " pathVector.size() = " << pathVector.size() << endl;
    for (int i = 0; i < pathVector.size(); i++)
    {
        auto filePath = path + pathVector[i];
        if (!fs::exists(filePath))
            return;
        std::ifstream ifs(filePath);
        auto fileSize = fs::file_size(filePath);
        DataFrame fileDF(chns0, pnts0);
        ifs.read(fileDF.upHead.get(), 32);
        // ifs.seekg(0);
        ifs.read(fileDF.upData.get(), fileSize - 32);
        ifs.close();
        createEngDensity(fileDF);
        // fileDF.clone().map([&](DataFrame df) {
        //         createEngDensity(df);
        //     })
        //     .map_error([&](auto err){
        //         std::stringstream ss;
        //         logErr(ss.str());

        //     });
    }
}
// 随采 同一个基站该时间内的多个文件合并 根据指定devid进行数据提前
// 如果devid = 0 则是全部数据
tl::expected<DataFrame, string> mergeMs(
    uint64_t fromsampTime,
    uint64_t endsampTime, int dev_id)
{ // 多并一，自电并到激电
    if (endsampTime <= fromsampTime)
    {
        return tl::make_unexpected(
            "DataFrame::merge error: negative from point"); 
    }

    string logstr = "mergeMs 开始时间: ";
    logstr += std::to_string(fromsampTime);
    logstr += " 结束时间： ";
    logstr += std::to_string(endsampTime);
    cout << logstr << endl;

    auto pnts0 = 0; // 一次采样一个通道的点数：2500/5000
    auto chns0 = 0; // 通道数
    auto pnts = 0;  // 该时间范围内一个通道的点数之和

    std::vector<string> pathVector;
    auto conn = hzi::config.pConnPool->getConnection();

    cout<<fixed<<"fromsampTime="<<fromsampTime<<"endsampTime="<<endsampTime<<endl;

    double fromtime = double(fromsampTime / 1000);
    double endtime = double(endsampTime / 1000);
    // 随采随掘区分开，随采数据，多基站只进行合并帧数据拼接处理 添加基站id处理

    std::cout << "dev_id=" << dev_id << std::endl;

    if (dev_id == 0)
    {
        int devId = hzi::sysDevMask;
        auto rslt0 = conn.executeQuery(
            "select channels,count(1) as number from e_data_frm_info  "
            " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
            "  AND samp_time < FROM_UNIXTIME(?) and dev_id = ? GROUP BY channels ORDER BY "
            "count(1) desc limit 1",
            hzi::mining_classId, fromtime, endtime, devId);
        
        cout<<fixed<<"mining_classId="<<hzi::mining_classId<<"fromtime="<<fromtime<<"endtime="<<endtime<<"devId="<<devId<<endl;
        
        if (rslt0.next())
        {
            chns0 = rslt0.getInt("channels");   //获取通道数
        }

        auto rslt = conn.executeQuery(
            "SELECT samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
            " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
            "  AND samp_time < FROM_UNIXTIME(?)  AND channels = ?  and dev_id = ? ORDER BY "
            "samp_time ASC",
            hzi::mining_classId, fromtime, endtime, chns0, devId);

        while (rslt.next())
        {
            pnts0 = rslt.getInt("ch_pnts");
            // chns0 = rslt.getInt("channels");
            auto pathstr = rslt.getString("frm_loc");
            pnts += pnts0;  //[fromtime,endtime]内一个通道的所有点数之和
            pathVector.push_back(pathstr);  //每个数据文件的路径
        }

        cout<<"pnts0="<<pnts0<<"pnts="<<pnts<<"chns0="<<chns0<<endl;

        if (pnts0 == 0 || pnts == 0 || chns0 == 0)
            return tl::make_unexpected(
                "DataFrame::merge: The data for that time period is empty");
        DataFrame newDF(chns0, pnts); // 所有通道在时间段内的所有点，拼一个帧
        string path = Config::dataRoot + "/";
        for (int i = 0; i < pathVector.size(); i++)
        {
            auto filePath = path + pathVector[i];
            if (!fs::exists(filePath))
                return tl::make_unexpected("DataFrame::merge: file Path error");
            std::ifstream ifs(filePath);
            auto fileSize = fs::file_size(filePath);
            DataFrame fileDF(chns0, pnts0);//一个数据文件（保存了每个通道在一个采样周期内的数据）的帧
            ifs.read(fileDF.upHead.get(), 32);
            // ifs.seekg(0);
            ifs.read(fileDF.upData.get(), fileSize - 32);   //读取一个数据文件到fileDF中
            ifs.close();
            if (i == 0)
            {
                memcpy(newDF.upHead.get(), fileDF.upHead.get(), 32);
                newDF.setPoints(pnts); // fileDF在memcpy时把newDF原本的pnts改成了pnts0，这里重新设置回来
            }

            //把每次采样的数据文件中的数据，遍历通道，拷贝到newDF中（i循环是采集数/数据文件数，ch是通道数）
            for (int ch = 0; ch < chns0; ch++)
            {
                memcpy(newDF.upData.get() + ch * pnts * 4 + i * pnts0 * 4,
                       fileDF.upData.get() + ch * pnts0 * 4, pnts0 * 4);
            }
        }

        return std::move(newDF);
    }
    else
    {

        chns0 = hzi::config.devicesMap[dev_id].dataChns[2];

        auto rslt = conn.executeQuery(
            "SELECT dev_id, samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
            " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
            "  AND samp_time < FROM_UNIXTIME(?)   ORDER BY "
            "samp_time ASC",
            hzi::mining_classId, fromtime, endtime);
        while (rslt.next())
        {
            pnts0 = rslt.getInt("ch_pnts");
            // chns0 = rslt.getInt("channels");
            int tmp_devID = rslt.getInt("dev_id");
            if ((tmp_devID & (1 << (dev_id - 1))) == 0)
            {
                continue; // 如果标记值不包含目标基站，跳过该文件
            }
            auto pathstr = rslt.getString("frm_loc");

            pnts += pnts0;
            pathVector.push_back(pathstr);
        }

        if (pnts0 == 0 || pnts == 0 || chns0 == 0)
            return tl::make_unexpected(
                "DataFrame::merge: The data for that time period is empty");
        DataFrame newDF(chns0, pnts);
        string path = Config::dataRoot + "/";

        for (int i = 0; i < pathVector.size(); i++)
        {
            auto filePath = path + pathVector[i];
            if (!fs::exists(filePath))
                return tl::make_unexpected("DataFrame::merge: file Path error");
            std::ifstream ifs(filePath);
            auto fileSize = fs::file_size(filePath);
            auto pHead = std::make_unique<char[]>(32);

            auto pData = std::make_unique<char[]>(fileSize - 32);
            ifs.read(pHead.get(), 32);
            ifs.read(pData.get(), fileSize - 32); // 不带帧头 数据
            ifs.close();

            // 获取文件头中基站标记值
            int devMark = static_cast<unsigned char>(pHead[26]); // 从文件头第17位置读取基站标记值
            // if ((devMark & (1 << (dev_id - 1))) == 0) {
            //     continue;  // 如果标记值不包含目标基站，跳过该文件
            // }
            auto chns = *(uint16_t *)(pHead.get() + 10);       // 文件包含的通道数
            auto pntsInFile = *(uint32_t *)(pHead.get() + 12); // 文件包含的数据点数

            // 创建一个临时的 DataFrame 来存储文件数据
            DataFrame fileDF(chns, pntsInFile);
            memcpy(fileDF.upHead.get(), pHead.get(), 32);
            memcpy(fileDF.upData.get(), pData.get(), fileSize - 32);

            if (i == 0)
            {

                memcpy(newDF.upHead.get(), fileDF.upHead.get(), 32);
                if (dev_id != 0)
                    *(uint8_t *)(newDF.upHead.get() + 26) = dev_id;
                newDF.setPoints(pnts);
                newDF.setChannels(chns0);
            }
            // 计算 dev_id 的起始位置
            int chnOffset = 0;
            for (int bit = 0; bit < dev_id - 1; ++bit)
            {
                if (devMark & (1 << bit))
                {
                    chnOffset += hzi::config.devicesMap[bit + 1].dataChns[2]; // 假设每个基站有单独存储的通道数
                }
            }
            // cout<<" chns0 = "<<chns0<<",chns="<<chns<<",chnOffset = "<<chnOffset<<",pnts0 = "<<pnts0
            //     <<",pntsInFile = "<<pntsInFile<<",pnts = "<<pnts<<endl;

            // 处理通道数据拷贝，将指定 `chns0` 的数据合并到目标 `newDF`
            for (int ch = 0; ch < chns0; ++ch)
            {
                int sourceCh = chnOffset + ch; // 计算文件数据的实际通道位置
                if (sourceCh < chns)
                { // 确保文件中的通道数足够
                    memcpy(newDF.upData.get() + ch * pnts * 4 + i * pnts0 * 4,
                           fileDF.upData.get() + sourceCh * pntsInFile * 4, pntsInFile * 4);
                }
            }
        }

        return std::move(newDF);
    }
}

void getWarningInfo()
{
    auto conn = hzi::config.pConnPool->getConnection();
    // 回采位置 从库中获取还是tunnel_mining_loc ？
    int dimNum = 3; // 维度
    int numK = 3;
    float threX = 3.5;
    float threY = 0;
    float threZ = 3.5;
    float threAngle = 5;
    float effect_pro = 0.3;
    float markLenx = 50;
    float sse = 0.2;

    auto rslt = conn.executeQuery("SELECT * FROM `e_tunnel_threshold`");
    if (rslt.next())
    {
        dimNum = rslt.getInt("dimNum");
        numK = rslt.getInt("centNumK");
        threX = rslt.getDouble("threX");
        threY = rslt.getDouble("threY");
        threZ = rslt.getDouble("threZ");
        threAngle = rslt.getDouble("threAngle");
        effect_pro = rslt.getDouble("effectPro");
        markLenx = rslt.getDouble("markLenX");
        sse = rslt.getDouble("threSSE");
    }
    numK = numK * 2;
    auto locX = hzi::tunnel_mining_loc;
    // cout<<" threX = "<<threX
    //     <<" effect_pro = "<<effect_pro
    //     <<" markLenx = "<<markLenx
    //     <<" threY = "<<threY
    //     <<" threAngle = "<<threAngle<<endl;

    // auto rslt01 = conn.executeQuery("SELECT * FROM `e_tunnel_cur_status`");
    auto rslt01 = conn.executeQuery("SELECT * FROM e_tunnel_locInfo");
    if (rslt01.next())
    {
        locX = rslt01.getDouble("mining_loc");
    }

    cout << "locX = " << locX << endl;
    std::vector<vector<float>> dataVec;
    auto rslt0 = conn.executeQuery(
        "SELECT mid_x,mid_y,fAngle FROM `e_tunnel_lineInfo` WHERE mid_x < ? "
        "and mid_x > ?",
        locX + markLenx, locX);
    while (rslt0.next())
    {
        vector<float> datatmp;
        auto mid_x = rslt0.getDouble("mid_x");
        auto mid_y = rslt0.getDouble("mid_y");
        auto fAngle = rslt0.getDouble("fAngle");
        datatmp.push_back(mid_x);
        datatmp.push_back(mid_y);
        datatmp.push_back(fAngle);
        dataVec.push_back(datatmp);
    }
    int dataNum = dataVec.size(); // 样本数量

    if (dataNum < 10)
    {
        // 样本量太少 不处理
        return;
    }
    PureCommonOperation::CKmeansCluster kmeansCluster;
    kmeansCluster.SetDataSize(dataNum, dimNum);
    for (int i = 0; i < dataNum; i++)
    {
        vector<float> datatmp = dataVec[i];
        for (int j = 0; j < dimNum; j++)
        {
            kmeansCluster.SetData(i, j, datatmp[j]);
        }
    }

    float tmpData[5] = {7.5, 22.5, 40, 0, 0}; // 质心位置 m_nK 默认为3
    // float **centData;

    std::vector<std::vector<float>> initCentVec; // 初始化质心
    for (int k = 0; k < numK; k++)
    {
        std::vector<float> cent;
        int dex = k / 2;
        cout << " k = " << k << " dex = " << dex << " (";
        for (int d = 0; d < dimNum; d++)
        {
            if (d == 0)
            {
                cout << locX + tmpData[dex] << " , ";
                cent.push_back(locX + tmpData[dex]);
            }
            else if (d == 2)
            {
                // 角度分开
                if (k % 2 == 0)
                {
                    cout << "45 , ";
                    cent.push_back(45);
                }
                else
                {
                    cout << "-45 , ";
                    cent.push_back(-45);
                }
                // if(k%2 == 1)cent.push_back(-45);
            }
            else
            {
                cout << "0 , ";
                cent.push_back(0);
            }
        }
        cout << ")" << endl;
        initCentVec.push_back(cent);
    }
    // 阈值设置
    auto thre_Y = (threY == 0) ? threZ : threY;
    std::vector<float> threshold; // 阈值

    threshold.push_back(threX);
    threshold.push_back(thre_Y);
    threshold.push_back(threAngle);

    kmeansCluster.setParm(initCentVec, threshold, effect_pro);
    //  kmeansCluster.setLocX(locX);
    kmeansCluster.ToCluster(numK);
    std::vector<std::vector<float>> CentVec; // 异常
    //  std::vector<PCOSpeedParm>speedParm;
    std::vector<ERRORInfoParm> errInfoParm;

    bool ret = kmeansCluster.getWarnInfo(CentVec);
    cout << "CentVec.size =  " << CentVec.size() << endl;
    if (CentVec.size() > 0)
    {
        for (int i = 0; i < CentVec.size(); i++)
        {
            std::vector<PCOSpeedParm> speedParm;

            std::vector<float> datatmp = CentVec[i];
            cout << "errInfo:" << i + 1 << " ( ";
            for (int j = 0; j < datatmp.size(); j++)
            {
                cout << datatmp[j] << ",";
            }
            cout << ")" << endl;
            auto rslt2 = conn.executeQuery(
                "SELECT * FROM `e_tunnel_lineInfo` WHERE mid_x < ? and mid_x > "
                "? and mid_y < ? and mid_y > ? "
                "and fAngle < ? and fAngle > ?",
                datatmp[0] + threX, datatmp[0] - threX, datatmp[1] + thre_Y,
                datatmp[1] - thre_Y, datatmp[2] + threAngle,
                datatmp[2] - threAngle);
            if (rslt2.next())
            { // 选一个文件
                PCOSpeedParm tmpParm;
                tmpParm.samp_time =
                    static_cast<uint64_t>(rslt2.getLLong("samp_time"));
                tmpParm.mining_locx = rslt2.getDouble("mining_locx");
                tmpParm.mining_dir = rslt2.getInt("mining_dir");
                tmpParm.x = datatmp[0];
                tmpParm.y = datatmp[1];
                tmpParm.fAngle = datatmp[2];
                speedParm.push_back(tmpParm);
            }
            handleScanSpeed(speedParm, errInfoParm);
        }
    }
    saveErrInfoTable(errInfoParm);
}
void handleCSVFile(string path)
{
    PureCommonOperation::handleCSVFile(path);
}
void updateDateLenAndFreq()
{
    auto conn = hzi::config.pConnPool->getConnection();

    auto rslt0 = conn.executeQuery(
        "SELECT dataFreq,dataLen  FROM `e_mining_PCOSignalParm`");
    if (rslt0.next())
    {
        hzi::miningFreq = rslt0.getInt("dataFreq");
        hzi::miningDateLen = rslt0.getInt("dataLen");
    }
}
void threadHanleData(uint64_t fromsampTime, uint64_t endsampTime, int len, int dev_id)
{
    // std::unique_lock<std::mutex> lck(hzi::globalMtx);
    uint64_t fromTime = fromsampTime;
    uint64_t toTime = endsampTime;
    // 处理上一个时间段数据 拼接
    auto diff = toTime - fromTime;
    if (diff <= 0)
        return;
    auto dataLen = len;

    int datasize = (int)diff / dataLen;
    datasize += 1;

    std::vector<DataFrame *> dfvec;
    std::vector<DataFrame> sps;
    auto endLoc =
        (fromTime + (uint64_t)dataLen) > endsampTime ? endsampTime : (fromTime + (uint64_t)dataLen);
    for (int i = 0; i < datasize; i++)
    {
        mergeMs(fromTime, endLoc, dev_id)
            .map([&](DataFrame df){
                auto dftmp = std::move(df);
                sps.push_back(std::move(dftmp)); })
            .map_error([&](auto err){
                if (hzi::config.verbose) {
                    std::stringstream ss;
                    logErr(ss.str());
                } });
        fromTime += (uint64_t)dataLen;
        endLoc =
            (fromTime + (uint64_t)dataLen) > endsampTime ? endsampTime : (fromTime + (uint64_t)dataLen);
    }
    for (auto &sp : sps)
    {
        dfvec.push_back(&sp);
    }
    if (dfvec.size() > 0)
    {
        debugLog("start threadHanleData1 handleSignalProcess1");
        string filepath = handleSignalProcess(dfvec, true, dev_id);//true：实时计算，进行了再提取和偏移
        hzi::serverStatus.lastSampTimes[7] = fromsampTime;
        debugLog("endl threadHanleData1 handleSignalProcess1");
    }
}
void handleTimeStamp(uint64_t tm)
{
    hzi::laststamp = (hzi::laststamp == 0) ? tm : hzi::laststamp;
    hzi::nextstamp = tm;
    auto channels = hzi::msChannelsLabels.size();
    auto classId = 3;
    string str = getEngDenityParm(hzi::laststamp, hzi::nextstamp, channels, classId, true);
}
void threadHanleData_tunnel(uint64_t fromsampTime,
                            uint64_t endsampTime,
                            int len)
{
    // std::unique_lock<std::mutex> lck(hzi::globalMtx);
    uint64_t fromTime = fromsampTime;
    uint64_t toTime = endsampTime;
    // 处理上一个时间段数据 拼接
    auto diff = toTime - fromTime;
    auto dataLen = len;

    int datasize = (int)diff / dataLen + 1;

    uint64_t endTime = (fromTime + (uint64_t)dataLen) > toTime
                           ? toTime
                           : (fromTime + (uint64_t)dataLen);

    std::vector<DataFrame *> dfvec;
    std::vector<DataFrame> sps;
    for (int i = 0; i < datasize; i++)
    {
        mergeMs_tunnel(fromTime, endTime)
            .map([&](DataFrame df)
                 {
                auto dftmp = std::move(df);
                sps.push_back(std::move(dftmp)); })
            .map_error([&](auto err)
                       {
                if (hzi::config.verbose) {
                    std::stringstream ss;
                    logErr(ss.str());
                } });
        fromTime += (uint64_t)dataLen;
        endTime = (fromTime + (uint64_t)dataLen) > toTime
                      ? toTime
                      : (fromTime + (uint64_t)dataLen);
    }
    for (auto &sp : sps)
    {
        dfvec.push_back(&sp);
    }
    if (dfvec.size() > 0)
    {
        debugLog("start threadHanleData_tunnel handleSignalProcess1");
        string filepath = handleSignalProcess(dfvec, true, 0);
        hzi::serverStatus.lastSampTimes[7] = fromsampTime;
        debugLog("endl threadHanleData_tunnel handleSignalProcess1");
    }
}
void handleTimeStamp_tunnel(uint64_t tm)
{
    if ((hzi::config.ms_mining_type == 2) && hzi::isGetStopSignal)
    {
        if (hzi::config.verbose)
        {
            cout << " start handleTimeStamp_tunnel "
                 << std::to_string(hzi::realTimeStart) << ","
                 << std::to_string(hzi::realTimeStop) << endl;
        }
        auto timestamp = tm;
        hzi::isGetStopSignal = false;
        // 开始处理信号
        std::thread handerSignalthread(threadHanleData_tunnel,
                                       hzi::realTimeStart, hzi::realTimeStop,
                                       hzi::miningDateLen * 60 * 1000);
        handerSignalthread.detach();
    }
}
void getSourceLoc(float **p_data1, float **p_data2)
{
}
// 对随采震源进行定位  对双巷 计算理论值
void getMSourceLoc(vector<PureCommonOperation::PCOCalChn> pcoCalChnParms, int RNum, float speed_v, int constNum,
                   float mining_locX1, float mining_locX2, float y_min, float y_max, float **p_data1, float **p_data2)
{
    // float mining_locX1 = 100.0;
    // float mining_locX2 = 120.0;
    //  int constNum  = 100;
    //  int RNum = 16; // 单条测线16个接收点
    int surLineNum = 2;
    // float y_min = 0;
    // float y_max = 200;
    // float** p_data1 = new float*[RNum];
    // float** p_data2 = new float*[RNum];
    // for (int dex = 0; dex < RNum; dex++) {
    //     p_data1[dex] = new float[constNum];
    //     p_data2[dex] = new float[constNum];
    //     memset(p_data1[dex], 0, sizeof(float) * constNum);
    //     memset(p_data2[dex], 0, sizeof(float) * constNum);
    // }

    auto dx = (mining_locX2 - mining_locX1) / constNum;
    auto dy = (y_max - y_min) / constNum;
    for (int i = 0; i < constNum; i++)
    {
        // 获取每一个d值的（x,y,z）值
        auto x = mining_locX1 + dx * i;
        auto y = y_min + dy * i;
        float z = 0;

        for (int lineId = 0; lineId < 2; lineId++)
        {
            int tmp_dex = 0;
            int firt_chn = 0;
            for (int j = 0; j < pcoCalChnParms.size(); j++)
            {
                // 取通道
                if (pcoCalChnParms[j].id != lineId + 1)
                    continue;
                tmp_dex++;
                if (tmp_dex == 1)
                    firt_chn = j;
                auto dis = sqrtf((pcoCalChnParms[j].x - x) * (pcoCalChnParms[j].x - x) + (pcoCalChnParms[j].y - y) * (pcoCalChnParms[j].y - y)) - sqrtf((pcoCalChnParms[firt_chn].x - x) * (pcoCalChnParms[firt_chn].x - x) + (pcoCalChnParms[firt_chn].y - y) * (pcoCalChnParms[firt_chn].y - y));
                auto t = dis / speed_v;
                if (lineId == 0)
                {
                    p_data1[j - firt_chn][constNum] = t;
                }
                else
                {
                    p_data2[j - firt_chn][constNum] = t;
                }
            }
        }
    }
}


/**
* @brief 自相关频谱
* @param fromsampTime 起点时间戳
* @param endsampTime 终点时间戳
* @param timeSegment 分段时长（min）
* @param dev_id 基站id
* @param isRealTime 查实时表或历史表（默认值false，历史）
* @return 异常信息/保存11文件名
*/
tl::expected<string,string> selfCorrSpectrum(uint64_t fromsampTime, uint64_t endsampTime, uint64_t timeSegment, int dev_id, bool isRealTime)
{
    cout<<"selfCorrSpectrum started.."<<endl;


    /*拼帧*/
    // uint64_t fromTime = fromsampTime;
    // uint64_t toTime = endsampTime;
    // auto diff = toTime - fromTime;
    // if (diff <= 0)
    //     return;
    // auto dataLen = timeSegment*60*1000;//timeSegment(min)

    // int datasize = (int)diff / dataLen;
    // datasize += 1;

    // std::vector<DataFrame*> dfvec;
    // std::vector<DataFrame> sps;
    // auto endLoc = (fromTime + (uint64_t)dataLen) > endsampTime ? endsampTime : (fromTime + (uint64_t)dataLen);
    // cout<<"mergeMs"<<endl;
    // for (int i = 0; i < datasize; i++)
    // {
    //     mergeMs(fromTime, endLoc, dev_id)
    //         .map([&](DataFrame df){
    //             auto dftmp = std::move(df);
    //             sps.push_back(std::move(dftmp)); })
    //         .map_error([&](auto err){
    //             if (hzi::config.verbose) 
    //             {
    //                 std::stringstream ss;
    //                 logErr(ss.str());
    //             } });
    //     fromTime += (uint64_t)dataLen;
    //     endLoc = (fromTime + (uint64_t)dataLen) > endsampTime ? endsampTime : (fromTime + (uint64_t)dataLen);
    // }
    // for (auto &sp : sps)
    // {
    //     dfvec.push_back(&sp);
    // }

    // if(dfvec.size()<=0)
    // {
    //     return tl::make_unexpected(string("时间段内没数据"));
    // }
        
    vector<unique_ptr<DataFrame>> dfvecTmp;
    auto retMerge = mergeByTimeSegment(dfvecTmp, fromsampTime, endsampTime, timeSegment, dev_id);
    if(!retMerge.has_value())
    {
        return tl::make_unexpected(string("mergeByTimeSegment错误:") + retMerge.error());
    }
    vector<DataFrame*> dfvec;
    for(auto& df : dfvecTmp)
    {
        dfvec.push_back(df.get());
    }


    /*查表取参数*/
    // PureCommonOperation::PCOSignalParm pcoParm;
    // PureCommonOperation::PCOLocParm pcoLocParm;
    // PureCommonOperation::PCOCalChn pChn;
    auto conn = hzi::config.pConnPool->getConnection();
    if (isRealTime)
    {
        auto rslt0 = conn.executeQuery("SELECT dataFreq,dataLen,class_Id FROM `e_mining_PCOSignalParm`");
        if (rslt0.next())
        {
            hzi::miningFreq = rslt0.getInt("dataFreq");     // 数据频度（单位时间 h)
            hzi::miningDateLen = rslt0.getInt("dataLen");   // 数据时长（单位时间min)
            hzi::mining_classId = rslt0.getInt("class_Id"); // 拼接数据类型（6 微震全时 3-微震背景）
            std::cout << "realtime class_id=" << hzi::mining_classId << std::endl;
        }
    }
    else
    {
        auto rslt0 = conn.executeQuery("SELECT dataFreq,dataLen,class_Id FROM `e_mining_PCOSignalParm_history`");
        if (rslt0.next())
        {
            hzi::miningFreq = rslt0.getInt("dataFreq");     // 数据频度（单位时间 h)
            hzi::miningDateLen = rslt0.getInt("dataLen");   // 数据时长（单位时间min)
            hzi::mining_classId = rslt0.getInt("class_Id"); // 拼接数据类型（6 微震全时 3-微震背景）
            std::cout << "history class_id=" << hzi::mining_classId << std::endl;
        }
    }

    int vecSize = dfvec.size();//分段数
    int channelNum = dfvec[0]->channels();//通道数
  
    auto deltT = dfvec[0]->sampIntvl(); // 采样间隔(ms)
	auto tmStmp = dfvec[0]->sampTime(); // 采样时间
	auto devId = dfvec[0]->devMask();
	float speed_p, speed_s = 0;
	bool is_evenSpeed = 0;
	auto pntss = dfvec[0]->points();
	int useVType = 0; // 默认使用P波偏移，偏移类型（0-P波 ，1-S波 2-PS波)

	PureCommonOperation::PCOLocParm pcoLocParm;
	PureCommonOperation::PCOSignalParm pcoParm;
	bool outType = 0;
	int outSurLineId = 0; // 随采输出测线id 使用测线数量
	int isUseCSP = 0;
	bool ret = getPCO_parm(pcoParm, pcoLocParm, deltT, isRealTime, outType, outSurLineId, isUseCSP, useVType, is_evenSpeed, speed_p, speed_s);

	double dateTime = (double)tmStmp / 1000.0;
	auto coal_z = 0.0;	   // 煤层位置
	auto layer_from = 0.0; // 坐标开始位置

	auto rslt12 = conn.executeQuery("SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
	if (rslt12.next())
	{
		pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
		pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
		pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
		pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
		coal_z = rslt12.getDouble("coal_z");
		layer_from = rslt12.getDouble("layer_from");
	}
	if (!setPCOLocParm(tmStmp, pcoLocParm))
		return "e_mining_PCOLocParm表 数据为空";

	if (!hzi::config.ms_tunnel_listen)
	{
		hzi::tunnel_mining_loc = pcoLocParm.m_locx;
	}

	if (hzi::config.verbose)
		cout << " 回采位置：" << pcoLocParm.m_locx << endl;

	if (pcoLocParm.m_dir == 0)
	{
		pcoLocParm.m_dXMin = pcoLocParm.m_locx;
		if (hzi::config.ms_mining_type == 2)
		{
			// 随掘
			pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
		}
		pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
	}
	else
	{
		pcoLocParm.m_dXMax = pcoLocParm.m_locx;
		if (hzi::config.ms_mining_type == 2)
		{
			// 随掘
			pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
		}
		pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
	}
	if (hzi::config.ms_interface_type == 0)
	{
		pcoLocParm.m_iZGrdNum = 1;
		pcoLocParm.m_dZMax = 1;
		pcoLocParm.m_dZMin = 0;
		pcoLocParm.m_dZGrdLen = 1;
	}
	if (hzi::config.ms_interface_type == 1)
	{
		pcoLocParm.m_iYGrdNum = 1;
		pcoLocParm.m_dYMax = 1;
		pcoLocParm.m_dYMin = 0;
		pcoLocParm.m_dYGrdLen = 1;
	}

	pcoParm.ms_components = hzi::config.ms_components;
	pcoLocParm.out_type = 1;

	pcoLocParm.interface_type = hzi::config.ms_interface_type;
	pcoLocParm.m_iZGrdNum =
		int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);

	pcoLocParm.m_iXGrdNum =
		int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
	pcoLocParm.m_iYGrdNum =
		int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

	vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
	// 先找出所有通道，进行分量和测线配置，然后删除不需要的通道  devId
	setPCOCalChn(pcoCalChnParms, hzi::sysDevMask, tmStmp, isRealTime);

	for (int i = 0; i < 3; i++)
	{
		pcoParm.dataChnNO[i] = pcoParm.chnno;
	}

	if (pcoParm.ms_components > 1)
	{
		// 多分量 给pcoCalChnParms 分配分量属性
		auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
		while (rslt_comp.next())
		{
			auto id = rslt_comp.getInt("id");
			auto enb = rslt_comp.getInt("enb"); // 输出分量结果
			auto chnsList = rslt_comp.getString("chnsList");
			auto chn_no = rslt_comp.getInt("chn_no");
			auto chn_no_history = rslt_comp.getInt("chn_no_history");
			auto is_out = rslt_comp.getInt("is_out");
			if (is_out)
				pcoLocParm.out_type = id;
			if (isRealTime)
			{
				// 实时计算
				pcoParm.dataChnNO[id - 1] = chn_no;
			}
			else
			{
				// 历史计算
				pcoParm.dataChnNO[id - 1] = chn_no_history;
			}
			auto chns_List = parseString(chnsList);
			for (int num : chns_List)
			{
				if (num <= pcoCalChnParms.size())
				{
					pcoCalChnParms[num - 1].flag = id; // 分量id
					pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
				}
			}
		}
	}

	int lineArry[3] = {0};
	if (hzi::config.ms_mining_type == 1)
	{
		auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
		while (rslt_surveyLine.next())
		{
			auto id = rslt_surveyLine.getInt("id");
			//    surveyLineCount = (id > surveyLineCount) ? id : surveyLineCount;
			auto chnsList = rslt_surveyLine.getString("chnsList");

			// std::vector<int> result
			auto chns_List = parseString(chnsList);
			lineArry[id - 1] = chns_List.size();
			for (int num : chns_List)
			{
				if (num <= pcoCalChnParms.size())
				{
					pcoCalChnParms[num - 1].id = id; // 测线id
					//   cout<<" 通道号："<<num<<" 测线："<<id<<endl;
				}
			}
		}

		for (int i = 0; i < 3; i++)
		{
			if (dev_id != 0)
			{
				if (lineArry[i] != 0 && dev_id == i + 1)
					pcoParm.lineCountVec.push_back(lineArry[i]);
			}
			else
			{
				if (lineArry[i] != 0)
					pcoParm.lineCountVec.push_back(lineArry[i]);
			}
		}
	}

	// 随掘
	if (hzi::config.ms_mining_type == 2)
	{
		//  pcoLocParm.hasFouce = true;
		//  pcoLocParm.is_exclude_directWaves = true;
		if (pcoParm.ms_components > 1)
		{
			auto chnno_tmp = pcoParm.dataChnNO[0];
			pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
			pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
			pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
		}
		else
		{
			pcoLocParm.fx = pcoCalChnParms[pcoParm.chnno - 1].x;
			pcoLocParm.fy = pcoCalChnParms[pcoParm.chnno - 1].y;
			pcoLocParm.fz = pcoCalChnParms[pcoParm.chnno - 1].z;
		}
	}

	if (dev_id != 0)
	{
		// 指定测线数据处理 取对应基站的坐标 默认基站号与测线号对应
		pcoCalChnParms.erase(
			std::remove_if(
				pcoCalChnParms.begin(),
				pcoCalChnParms.end(),
				[dev_id](const PureCommonOperation::PCOCalChn &elem)
				{
					return elem.id != dev_id;
				}),
			pcoCalChnParms.end());
	}
	// 在此区分随掘和随采的信号提取通道数量 随采根据测线来决定


	auto iGrdNum = pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

	pcoParm.mining_fx = pcoLocParm.fx;
	pcoParm.mining_fy = pcoLocParm.fy;
	pcoParm.mining_fz = pcoLocParm.fz;
	pcoParm.chns_Count = channelNum;
	pcoParm.chns = channelNum;

	// 采煤机定位 随采采煤机定位
	int sumCount_jh = 170;
	float dis = 1.75;
	if (hzi::config.ms_mining_type == 1 && hzi::start_jh != 0 && hzi::end_jh != 0)
	{
		//  float dis_y = (pcoLocParm.m_dYMax - pcoLocParm.m_dYMin)/100;
		float y = pcoLocParm.m_dYMin + hzi::start_jh * dis;
		float dis_y = (hzi::end_jh - hzi::start_jh) * dis / vecSize;

		pcoLocParm.fx = pcoLocParm.m_locx;
		pcoLocParm.fy = y;
		pcoLocParm.fz = pcoLocParm.fz;
		pcoLocParm.dis_y = dis_y;
	}
	// cout<<"size = "<<dfVec.size()<<" , 通道："<<dfVec[0]->channels()<<", 时间戳"<<std::to_string(dfVec[0]->sampTime())
	//     <<"震源位置："<<pcoLocParm.fx<<" ,"<<pcoLocParm.fy<<", 间隔："<<pcoLocParm.dis_y<<endl;;

    if (true) 
	{
		pcoParm.isCut = 0;					  // 无滤波
		pcoParm.isCalRandon = false;		  // 无反射波提取
		pcoParm.isSpikeDeconvolution = false; // 无反褶积
		pcoParm.deAGCtype = 0;				  // 无道内均衡
		isUseCSP = 0;						  // 无CSP道集提取
		pcoParm.interChnAmpEqual_type = 0;	  // 无道间均衡
	}

    
    /*执行自相关*/
    const int icorrResultSize = channelNum*vecSize;//总通道数
    
    auto myDeleter = [vecSize, channelNum](float **ptr)
	{
		for (int dex = 0; dex < vecSize; dex++)
		{
			for (int chIndex = 0; chIndex < channelNum; chIndex++)
			{
                if(ptr[chIndex + dex * channelNum])
                {
                    delete[] ptr[chIndex + dex * channelNum];
                }
			}
		}
		if(ptr)
        {
            delete[] ptr;
        }
	};

    // unique_ptr<float*[], decltype(myDeleter)> pCorrResult(new float*[icorrResultSize], myDeleter);//暂存自相关结果
    // memset(pCorrResult.get(), 0, sizeof(float*) * icorrResultSize);
    // cout<<"pCorrResult创建时地址为:"<<pCorrResult.get()<<endl;
	// for (int dex = 0; dex < vecSize; dex++)
	// {
	// 	for (int ch = 0; ch < channelNum; ++ch)
	// 	{
	// 		pCorrResult[ch + dex * channelNum] = new float[pcoParm.outLen]; 
	// 		memset(pCorrResult[ch + dex * channelNum], 0, sizeof(float) * pcoParm.outLen);
	// 	}
	// }
    

    float** pCorrResult = new float*[icorrResultSize]; //暂存自相关结果
    cout<<"pCorrResult创建时地址为:"<<pCorrResult<<endl;
    memset(pCorrResult, 0, sizeof(float*) * icorrResultSize);
    for (int dex = 0; dex < vecSize; dex++)
	{
		for (int ch = 0; ch < channelNum; ++ch)
		{
			if(!pCorrResult[ch + dex * channelNum])
            {
                pCorrResult[ch + dex * channelNum] = new float[pcoParm.outLen]; 
			    memset(pCorrResult[ch + dex * channelNum], 0, sizeof(float) * pcoParm.outLen);
            } 
		}
	}

    if (dfvec.size() > 0)
    {
        cout<<"start selfCorr.."<<endl;
        // selfCorrCalc(dfvec, pcoParm, pcoLocParm, pcoCalChnParms, pCorrResult.get());
        selfCorrCalc(dfvec, pcoParm, pcoLocParm, pcoCalChnParms, pCorrResult);
        cout<<"end selfCorr.."<<endl;
    }

    // cout<<"---------------自相关数据-----------------"<<endl;
    // for(int dex = 0; dex < vecSize; dex++)
    // {
    //     for (int chIndex = 0; chIndex < channelNum; chIndex++)
    //     {
    //         cout << "chIndex=" << chIndex << endl;
    //         for (int pt = 0; pt < 20; pt++)
    //         {
    //             cout << "pt=" << pt << ",corrResult=" << pCorrResult[chIndex + dex * channelNum][pt] << endl;
    //         }
    //     }
    // }
    // cout<<"---------------自相关数据-----------------"<<endl;


    /*自相关谱图：时域+自相关+正fft*/
	unique_ptr<float*[], decltype(myDeleter)> pOutSelfCorrSpectrum(new float*[icorrResultSize], myDeleter);//存自相关谱图结果
	for (int dex = 0; dex < vecSize; dex++)
	{
		for (int chIndex = 0; chIndex < channelNum; chIndex++)
		{
			pOutSelfCorrSpectrum[chIndex + dex * channelNum] = new float[pcoParm.outLen];
			memset(pOutSelfCorrSpectrum[chIndex + dex * channelNum], 0, sizeof(float) * pcoParm.outLen);
		}
	}

	// 对时域自相关信号执行fft
	unique_ptr<float[]> pChDataR = make_unique<float[]>(pcoParm.outLen); // 暂存一个通道的数据
	unique_ptr<float[]> pChDataI = make_unique<float[]>(pcoParm.outLen);

	for (int dex = 0; dex < vecSize; dex++)
	{
		for (int ch = 0; ch < channelNum; ch++)
		{
			// cout << "-------------ch=------------" << ch << endl;
            // cout << "pcoParm.outLen=" << pcoParm.outLen << endl;

			memset(pChDataR.get(), 0, sizeof(float) * pcoParm.outLen);
			memset(pChDataI.get(), 0, sizeof(float) * pcoParm.outLen);
			memcpy(pChDataR.get(), pCorrResult[ch + dex * channelNum], sizeof(float) * pcoParm.outLen);

			// for (int i = 0; i < 30; i++)
			// {
			// 	cout << "相关数据,pt" << to_string(i) << "=" << pCorrResult[ch + dex * channelNum][i] << endl;
			// 	cout << "实部=" << pChDataR[i] << ",虚部=" << pChDataI[i] << endl;
			// }

            PureCommonOperation::DataCorrect(pChDataR.get(), pcoParm.outLen, 0);//去零漂
			PureCommonOperation::DataFFT(pChDataR.get(), pChDataI.get(), pcoParm.outLen, true);

			// for (int i = 0; i < 30; i++)
			// {
			// 	cout << "fft后实部=" << pChDataR[i] << ",fft后虚部=" << pChDataI[i] << endl;
			// }

			for (int pt = 0; pt < pcoParm.outLen; pt++)
			{
				// float frequencyPt = pt / deltT * pcoParm.outLen;  //横轴-频率：k*采样频率/采样点数。频谱左右对称，只需显示一半的点。
				float AmplitudePt = sqrt(std::pow(pChDataR[pt], 2.0f) + std::pow(pChDataI[pt], 2.0f)); // 纵轴-幅值:平方和的平方根
				pOutSelfCorrSpectrum[ch + dex * channelNum][pt] = AmplitudePt;

				// cout << "频率=" << (1000*(pt+1)) / (deltT * pcoParm.outLen) << ",幅值=" << AmplitudePt << endl;
			}
		}
	}

    // 释放pCorrResult
    for (int dex = 0; dex < vecSize; dex++)
    {
        for (int ch = 0; ch < channelNum; ++ch)
        {
           if(pCorrResult[ch + dex * channelNum])
            {
                delete[] pCorrResult[ch + dex * channelNum];
                pCorrResult[ch + dex * channelNum] = nullptr;
            }
        }
    }
    if(pCorrResult)
    {
        delete[] pCorrResult;
        pCorrResult=nullptr;
    }


    // 线性插值
    bool isInsert=false;
    if(isInsert)
    {
        constexpr int outLenInsert = 512;                                                   
        constexpr int channelNumEachChnInsert = 10;                                         
        int channelNumEachDex = ((1 + channelNumEachChnInsert) * (channelNum - 1) + 1); 
        int channelNumTotal = channelNumEachDex * vecSize;                              

        auto myDeleterInsert = [vecSize, channelNumEachDex](float **ptr)
        {
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int chIndex = 0; chIndex < channelNumEachDex; chIndex++)
                {
                    if (ptr[chIndex + dex * channelNumEachDex])
                    {
                        delete[] ptr[chIndex + dex * channelNumEachDex];
                    }
                }
            }
            if (ptr)
            {
                delete[] ptr;
            }
        };
        unique_ptr<float *[], decltype(myDeleterInsert)> pSelfCorrSpectrumInsert(new float *[channelNumTotal], myDeleterInsert); // 存插值后自相关谱图结果
        for (int dex = 0; dex < vecSize; dex++)
        {
            for (int chIndex = 0; chIndex < channelNumEachDex; chIndex++)
            {
                pSelfCorrSpectrumInsert[chIndex + dex * channelNumEachDex] = new float[outLenInsert];
                memset(pSelfCorrSpectrumInsert[chIndex + dex * channelNumEachDex], 0, sizeof(float) * outLenInsert);
            }
        }

        for (int dex = 0; dex < vecSize; dex++)
        {
            for (int ch = 0; ch < channelNum; ch++)
            {
                if (ch < channelNum - 1) 
                {
                    for (int pt = 0; pt < outLenInsert; pt++)
                    {
                        for (int chInsert = 0; chInsert < channelNumEachChnInsert + 1; chInsert++)
                        {
                            float k = (pOutSelfCorrSpectrum[ch + 1 + dex * channelNum][pt] - pOutSelfCorrSpectrum[ch + dex * channelNum][pt]) / (channelNumEachChnInsert + 1);
                            if (chInsert == 0) 
                            {
                                pSelfCorrSpectrumInsert[ch * (1 + channelNumEachChnInsert) + chInsert + dex * channelNumEachDex][pt] = pOutSelfCorrSpectrum[ch + dex * channelNum][pt];
                            }
                            else
                            {
                                pSelfCorrSpectrumInsert[ch * (1 + channelNumEachChnInsert) + chInsert + dex * channelNumEachDex][pt] = k * chInsert + pOutSelfCorrSpectrum[ch + dex * channelNum][pt];
                            }
                        }
                    }
                }
                else if (ch == channelNum - 1) 
                {
                    for (int pt = 0; pt < outLenInsert; pt++)
                    {
                        pSelfCorrSpectrumInsert[ch * (1 + channelNumEachChnInsert) + 0 + dex * channelNumEachDex][pt] = pOutSelfCorrSpectrum[ch + dex * channelNum][pt];
                    }
                }
            }
        }
        float fs = 1000.0 / (deltT * pcoParm.outLen);
        // cout << "fs=" << fs << endl;
        // for (int dex = 0; dex < vecSize; dex++)
        // {
        //     for (int ch = 0; ch < channelNumTotal; ch++)
        //     {
        //         for (int pt = 0; pt < outLenInsert; pt++)
        //         {
        //             cout<<"dex="<<dex<<",ch="<<ch<<",f="<<(pt+1)*fs<<",insert value="<<pSelfCorrSpectrumInsert[ch+dex*channelNumEachDex][pt]<<endl;
        //         }
        //     }
        // }
        auto pSelfCorrSpectrumInsertTmp = pSelfCorrSpectrumInsert.get();
        saveInsert(pSelfCorrSpectrumInsertTmp, tmStmp, channelNumTotal, outLenInsert, fs, string("2024-10-1.txt"));
        saveFile11(pSelfCorrSpectrumInsertTmp, tmStmp, fs, channelNumTotal, vecSize, outLenInsert, dev_id, pcoParm, pcoLocParm);
    }
   
    // 保存自相关谱图（pcoParm.outLen/2个点数）
    int outLen = pcoParm.outLen / 2;//点数：pcoParm.outLen/2
	unique_ptr<char[]> pHeadData11 = std::make_unique<char[]>(32);
	char *pHead11 = pHeadData11.get();
	int classId11 = 11;
	*(double *)(pHead11) = (double)tmStmp;
	*(uint8_t *)(pHead11 + 8) = classId11;
	*(float *)(pHead11 + 9) = 1000.0 / (deltT*pcoParm.outLen);  //频率分辨率，fs=1/(deltT/1000); frequency_resolution=fs/pcoParm.outLen
	*(uint32_t *)(pHead11 + 13) = channelNum;		// 可用通道总数
	*(uint16_t *)(pHead11 + 17) = vecSize;			// 数据分组数
	*(uint32_t *)(pHead11 + 19) = outLen;	        // 数据长度
	*(uint32_t *)(pHead11 + 23) = 0;                // 超前点数（频域无超前这个概念）
	*(uint8_t *)(pHead11 + 27) = dev_id;		    // 基站ID
	if (hzi::config.ms_mining_type == 1)
	{
		*(uint8_t *)(pHead11 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
		*(uint8_t *)(pHead11 + 29) = pcoParm.ImageType;	  //'随采成像方式:0-散射，1-透射，2-爆炸成像'
	}

	conn.execute(
		"INSERT INTO "
		"e_mining_selfcorrdata_frm_info "
		"(dev_id,samp_time,class_id,frequency_resolution,valNum,vecSize,outLen,frm_"
		"loc,fx,fy,fz,dis)"
		"values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
		" ON DUPLICATE KEY UPDATE frequency_resolution=values(frequency_resolution),valNum= "
		"values(valNum),vecSize=values(vecSize),outLen=values(outLen)",
		(uint8_t)devId,	 
		tmStmp / 1000.0, 
		classId11,		 
		1000.0 / (deltT*pcoParm.outLen),			
		channelNum,	    
		vecSize,
		outLen,
		(relLocFromTime(tmStmp) / std::to_string(classId11) / std::to_string(tmStmp)).c_str(),
		pcoLocParm.fx,
		pcoLocParm.fy,
		pcoLocParm.fz,
		pcoLocParm.dis_y);

	fs::path outClassId11FileName(hzi::config.dataRoot);
	outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId11) / std::to_string(tmStmp);
	try
	{
		auto dir = outClassId11FileName.parent_path();
		if (!fs::exists(dir))
		{
			fs::create_directories(dir);
		}
		std::ofstream ofsClassId11(outClassId11FileName, std::ofstream::binary);
		ofsClassId11.write(pHead11, 32);
		for (int dex = 0; dex < vecSize; dex++)
		{
			for (int ch = 0; ch < channelNum; ++ch)
			{
				// if (!pcoCalChnParms[ch].enb)
				//     continue;

				int32_t* p32SelfCorrSpectrumEachChn = reinterpret_cast<int32_t*>(pOutSelfCorrSpectrum[ch + dex * channelNum]);
				ofsClassId11.write(reinterpret_cast<char*>(p32SelfCorrSpectrumEachChn), outLen * 4);
			}
		}
		ofsClassId11.close();
    }
	catch (std::exception &e)
	{
		string msg("error while writing to file:");
		msg += outClassId11FileName.string();
		msg += ":";
		msg += e.what();
		if (hzi::config.verbose)
			cout << "msg = " << msg << endl;
		debugErr(msg); 
		return "save type 11 file error";
	};

    cout<<"selfCorrSpectrum completed.."<<endl;
    return std::to_string(tmStmp);//返回采样时间
}


/// @brief 给定时间段内拼帧
/// @param mergeResult 拼帧结果（size()由timeSegmentMinute控制）
/// @param fromSampTime 时间段起始时间(ms)
/// @param endSampTime 时间段结束时间(ms)
/// @param timeSegmentMinute 分段时长(min)
/// @param dev_id 
/// @return 
tl::expected<bool,string> mergeByTimeSegment(std::vector<std::unique_ptr<DataFrame>>& mergeResult,uint64_t fromSampTime,uint64_t endSampTime,int timeSegmentMinute,int dev_id)
{
    uint64_t fromTime = fromSampTime;
    uint64_t toTime = endSampTime;
    auto diff = toTime - fromTime;
    if (diff <= 0)
        return tl::make_unexpected(string("时间范围无效"));
    auto dataLen = timeSegmentMinute * 60 * 1000; // timeSegment(min)
    int datasize = (int)diff / dataLen;
    datasize += 1;  
    auto endLoc = (fromTime + (uint64_t)dataLen) > endSampTime ? endSampTime : (fromTime + (uint64_t)dataLen);

    cout << "mergeMs started.." << endl;
    for (int i = 0; i < datasize; i++)
    {
        mergeMs(fromTime, endLoc, dev_id)
            .map([&](DataFrame df){
                mergeResult.push_back(std::make_unique<DataFrame>(std::move(df)));
            })
            .map_error([&](auto err){
                if (hzi::config.verbose) 
                {
                    std::stringstream ss;
                    ss << err;
                    logErr(ss.str());
                }
                return tl::make_unexpected(err);
            });
        fromTime += (uint64_t)dataLen;
        endLoc = (fromTime + (uint64_t)dataLen) > endSampTime ? endSampTime : (fromTime + (uint64_t)dataLen);
    }
    cout << "mergeMs completed..mergeResult.size()=" << mergeResult.size() << endl;

    if (mergeResult.size() <= 0)
    {
        cout<<"时间段内没数据"<<endl;
        return tl::make_unexpected(string("时间段内没数据"));
    }

    return true;
}

/// @brief 封装保存到csv（列分别为：通道号、频率，幅值）
/// @param pData 
/// @param tmStmp 
/// @param channelNumTotal 
/// @param outLenInsert 
/// @param frequencyResolution 
/// @param fileName 
/// @return 
tl::expected<string, string> saveInsert(float** pData, uint64_t tmStmp, int channelNumTotal, int outLenInsert, float frequencyResolution, const std::string& fileName)
{
    try
    {
        fs::path csvInsertFilename(hzi::config.dataRoot);
        int classId11 = 11;
        string fileNameTmp = std::to_string(tmStmp) + "-" + fileName;
        csvInsertFilename /= relLocFromTime(tmStmp) / std::to_string(classId11) / fileNameTmp;
        std::ofstream outFile(csvInsertFilename);
        if (!outFile.is_open())
        {
            std::cout << "Error: Failed to open file " << fileName << std::endl;
            return tl::make_unexpected(string("Error: Failed to open file:" + fileName).c_str());
        }

        outFile.precision(6);
        outFile << std::fixed;
        for (int ch = 0; ch < channelNumTotal; ++ch)
        {
            float* pEachChn = pData[ch];
            float deltX = 75.0/channelNumTotal;
            for (int pt = 0; pt < outLenInsert; pt++)
            {
                outFile << (ch + 1)*deltX << ","
                        << (pt + 1) * frequencyResolution << ","
                        << pEachChn[pt] << "\n";
            }
        }

        outFile.close();
        std::cout << "Data saved to " << fileName << " successfully." << std::endl;
        return fileName;
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += fileName;
        msg += ":";
        msg += e.what();
        if (hzi::config.verbose)
            cout << "msg = " << msg << endl;
        debugErr(msg);

        return tl::make_unexpected(msg.c_str());
    };
}

/// @brief 封装保存11文件函数
/// @param pData 
/// @param tmStmp 
/// @param frequencyResolution 
/// @param channelNum 
/// @param dexNum 
/// @param outLen 
/// @param devId 
/// @param pcoParm 
/// @param pcoLocParm 
/// @return 
tl::expected<string, string> saveFile11(float** pData, uint64_t tmStmp, float frequencyResolution, int channelNum, int dexNum, int outLen, int devId, PureCommonOperation::PCOSignalParm pcoParm, PureCommonOperation::PCOLocParm pcoLocParm)
{
    unique_ptr<char[]> pHeadData11 = std::make_unique<char[]>(32);
    char *pHead11 = pHeadData11.get();

    int classId11 = 11;
    *(double *)(pHead11) = (double)tmStmp;
    *(uint8_t *)(pHead11 + 8) = classId11;
    *(float *)(pHead11 + 9) = frequencyResolution; // 频率分辨率：fs=1/(deltT/1000); frequency_resolution=fs/pcoParm.outLen
    *(uint32_t *)(pHead11 + 13) = channelNum;      // 可用通道总数
    *(uint16_t *)(pHead11 + 17) = dexNum;          // 数据分组数
    *(uint32_t *)(pHead11 + 19) = outLen;          // 数据长度
    *(uint32_t *)(pHead11 + 23) = 0;               // 超前点数（频域无超前这个概念）
    *(uint8_t *)(pHead11 + 27) = devId;            // 基站ID
    if (hzi::config.ms_mining_type == 1)
    {
        *(uint8_t *)(pHead11 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式
        *(uint8_t *)(pHead11 + 29) = pcoParm.ImageType;   // 随采成像方式:0-散射，1-透射，2-爆炸成像
    }

    auto conn = hzi::config.pConnPool->getConnection();
    conn.execute(
        "INSERT INTO "
        "e_mining_selfcorrdata_frm_info "
        "(dev_id,samp_time,class_id,frequency_resolution,valNum,vecSize,outLen,frm_"
        "loc,fx,fy,fz,dis)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE frequency_resolution= values(frequency_resolution),valNum= "
        "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
        (uint8_t)devId,
        tmStmp / 1000.0,
        classId11,
        frequencyResolution,
        channelNum,
        dexNum,
        outLen,
        (relLocFromTime(tmStmp) / std::to_string(classId11) / std::to_string(tmStmp)).c_str(),
        pcoLocParm.fx,
        pcoLocParm.fy,
        pcoLocParm.fz,
        pcoLocParm.dis_y);

    fs::path outClassId11FileName(hzi::config.dataRoot);
    outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId11) / std::to_string(tmStmp);
    try
    {
        auto dir = outClassId11FileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofsClassId11(outClassId11FileName, std::ofstream::binary);
        ofsClassId11.write(pHead11, 32);
        for (int dex = 0; dex < dexNum; dex++)
        {
            for (int ch = 0; ch < channelNum; ++ch)
            {
                // if (!pcoCalChnParms[ch].enb)
                //     continue;

                int32_t *p32Data = reinterpret_cast<int32_t *>(pData[ch + dex * channelNum]);
                ofsClassId11.write(reinterpret_cast<char *>(p32Data), outLen * 4);
            }
        }
        ofsClassId11.close();
        return std::to_string(tmStmp); // 返回采样时间
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += outClassId11FileName.string();
        msg += ":";
        msg += e.what();
        if (hzi::config.verbose)
            cout << "msg = " << msg << endl;
        debugErr(msg);

        return tl::make_unexpected(string("save type 11 file error:" + std::to_string(tmStmp)).c_str());
    };
}
```
```cpp
//MSDataFrame.hpp
#ifndef MSDATAFRAME_HPP
#define MSDATAFRAME_HPP

#include <chrono>
#include <deque>
#include <map>
#include <mutex>
#include <optional>
#include <unordered_map>

#include "Config.hpp"
#include "DataFrame.hpp"
#include "common.hpp"
#include "ms_regression.hpp"
#include "ms_variance.hpp"
#include "types.hpp"
#include "zdbpp.h"

using namespace std::chrono_literals;
class MSDataFrame : public DataFrame {
public:
  MSDataFrame(DataFrame &df) : DataFrame(std::move(df)), step_(20.0) {}
  // 计算各通道maxAmps个最大绝对值振幅标准差,
  // 返回标差阈值小于deviThrld的通道编号
  tl::expected<int, string> validChns();

  // 从前端传入或直接从库表获取
  inline void setValidChns(const std::vector<string> &chns) {
    validChns_ = chns;
  }

  tl::expected<int, string> setLocatingParams();
  tl::expected<int, string> setValidity(bool valid = true);

  tl::expected<int, string> locating();
  tl::expected<int, string> locateByEnergy();
  tl::expected<int, string> locateByRegression();

  void print(string prefix = "") const;

  // 无效触发判断，暂定条件：5秒内触发3次或以上
  static bool invalidTrig(string chLbl, uint64_t samptime) {
    std::lock_guard<std::mutex> lck(MSDataFrame::mutx);
    MSDataFrame::chnTrigs[chLbl].push_back(samptime);

    while (samptime - MSDataFrame::chnTrigs[chLbl].front() > 5000) {
      MSDataFrame::chnTrigs[chLbl].pop_front();
    }
    return MSDataFrame::chnTrigs[chLbl].size() >= 3;
  }

  // 设置chLbl触发状态，enable=true or false
  tl::expected<int, string> toggleTrig(string chLbl, bool enable);

  // 保存触发通道信息
  static inline std::map<string, std::deque<uint64_t>> chnTrigs;
  static inline std::mutex mutx;

  string trigChnLabel() const;
  // 按点检距排序与能量衰减序得到通道标号相似性评价
  float similarityBySortedDists(const LocF &loc);

  // 按能量-源检距递减最优相似性获取可行定位空间范围
  // givenData: 从前端传来经过预处理的通道最值参数
  tl::expected<std::pair<LocF, LocF>, string> spaceLimitsByEnergy(
      const LocF &minLoc, const LocF &maxLoc,
      const std::optional<
          std::unordered_map<string, std::pair<float, uint16_t>>> &givenData =
          std::nullopt);

  inline float getStep() { return step_; }
  void setStep(float newStep) { step_ = newStep; }
  inline void setCurrentChnsConfig() {
    currentChnsConfig_ = getChnConfigByTime(0, sampTime());
  }

  inline const std::unordered_map<std::string, ChanelsConfig> &
  getCurrentChnsConfig() const {
    return currentChnsConfig_;
  }

  // 从微震背景生成事件
  static tl::expected<MSDataFrame, string>
  MSDataFrame::digEventFromBg(double samptime) {
    try {
      std::this_thread::sleep_for(10s); //等待背景帧
      double stSecs = samptime / 1000.0;
      stSecs -= 10; //从前一帧取3帧
      auto conn = hzi::config.pConnPool->getConnection();
      string sql("select frm_loc from e_data_frm_info where class_id=3 and "
                 "samp_time>=from_unixtime(");
      sql += std::to_string(stSecs);
      sql += ") limit 3";

      vector<DataFrame> dfs;
      auto rslt = conn.executeQuery(sql.c_str());
      while (rslt.next()) {
        string frmLoc = rslt.getString("frm_loc");
        fs::path fileName(hzi::config.dataRoot);
        fileName /= frmLoc;
        auto dfExp = loadFrmFromFile(3, fileName);
        if (dfExp) {
          dfs.push_back(std::move(dfExp.value()));
        }
      }
      if (dfs.empty()) {
        return tl::make_unexpected("没有查询时刻前的微震背景数据");
      }
      string msg("digEventFromBg:事件时间：");
      msg += timestampToString((int64_t)samptime);
      msg += "；预取背景帧:";
      for (const auto &df : dfs) {
        msg += timestampToString((int64_t)df.sampTime());
        msg += ",";
      }

      msg.pop_back();
      debugLog(msg);
      // cout << msg << "\n";
      int reqPnts = 1024; //固定帧点数
      int reqAheads = 64; //固定超前点数
      double aheadTimestamp =
          samptime - (double)reqAheads * dfs[0].sampIntvl(); //超前点时刻
      double cutTimestamp =
          aheadTimestamp + (double)reqPnts * dfs[0].sampIntvl(); //结尾时刻
      // cout << "aheadtimestamp:" << aheadTimestamp
      //      << ",cutimestam:" << cutTimestamp << "\n";
      uint8_t i = 0;
      for (i = 0; i < dfs.size(); i++) {
        if (dfs[i].endTime() > aheadTimestamp) {
          break;
        }
      }

      auto &thisFrm = dfs[i];
      int fromPnt =
          (int)((aheadTimestamp - thisFrm.sampTime()) / thisFrm.sampIntvl());
      // cout << "fromPnt:" << fromPnt << "\n";
      // if (i == dfs.size() - 1 && fromPnt + reqPnts < thisFrm.points()) {
      //   return tl::make_unexpected("背景帧数据点不够");
      // }

      DataFrame df(thisFrm.channels(), reqPnts);
      MSDataFrame msdf(df);
      // msdf.print("init msdf");
      memcpy(msdf.upHead.get(), thisFrm.upHead.get(), 32);
      msdf.setClassId(2);
      msdf.setPoints(reqPnts);
      msdf.setSampTime(aheadTimestamp);
      char *destP = msdf.upData.get();
      char *fromP = thisFrm.upData.get() + fromPnt * 4;
      if (thisFrm.endTime() > cutTimestamp) { //本帧截取
        for (int j = 0; j < msdf.channels(); j++) {
          memcpy(destP, fromP, reqPnts * 4);
          destP += reqPnts * 4;
          fromP += thisFrm.points() * 4;
        }
        // msdf.print("背景事件成功1");
        msdf.save();
      } else if (i + 1 < dfs.size() &&
                 thisFrm.devMask() == dfs[i + 1].devMask()) {
        // &&
        //  thisFrm.endTime() == dfs[i + 1].sampTime()) { // 拼帧
        auto &nextFrm = dfs[i + 1];
        char *nextP = nextFrm.upData.get();
        auto thisPnts = thisFrm.points() - fromPnt; //本帧点数
        auto nextPnts = reqPnts - thisPnts;         //下帧点数

        // cout << "thisPnts:" << thisPnts << ",nextPnts:" << nextPnts
        //      << std::endl;

        for (int j = 0; j < msdf.channels(); j++) {
          memcpy(destP, fromP, thisPnts * 4);
          memcpy(destP + thisPnts * 4, nextP, nextPnts * 4);
          destP += reqPnts * 4;
          fromP += thisFrm.points() * 4;
          nextP += nextFrm.points() * 4;
        }

        msdf.save();
        // 记为无效事件
        msdf.setValidity(false);
      } else {
        return tl::make_unexpected(
            string("没有合适微震背景帧数据用于提取微震事件"));
      }
      return msdf;
    } catch (zdb::sql_exception e) {
      return tl::make_unexpected(string("MSDataFrame::digEventFromBg error:") +
                                 e.what());
    }
  }

private:
  tl::expected<int, string> setLocatingParams(zdb::ResultSet &rslt);
  tl::expected<int, std::string> psArrsByVarAic();

  tl::expected<int, string> saveLocation();
  tl::expected<int, string> locating1();
  tl::expected<EvtRecord, string> locating2(std::string waveType);
  tl::expected<EnergyFitRecord, string> locating3(LocF &lastLoc,
                                                  const LocF &minLoc,
                                                  const LocF &maxLoc,
                                                  float lastCost);
  tl::expected<int, string> calcEnergy();
  tl::expected<float, string>
  energyByRegression(LocF source);         //按回归法计算能量
  tl::expected<int, string> delBiasChns(); // 剔除p波到时偏差过大通道
  tl::expected<int, string> savePSArrivals();
  tl::expected<int, string> prepare();
  tl::expected<int, string> chnSortedByEnergy(
      const std::optional<
          std::unordered_map<string, std::pair<float, uint16_t>>> &givenData =
          std::nullopt);

  // std::vector<double> validDists(const LocF &loc);
  std::vector<string> sortedValidChnsByDists(const LocF &loc);
  double squares(const EnergyFitRecord &rec,
                 std::vector<std::pair<double, double>> fitData);

  // 特征函数：
  int CF(size_t cf, size_t chn, size_t pnt);

  uint8_t characFunc_;
  uint8_t engMagNo_; // 能量震级转换公式编号
  int maxAmps_;
  int maxAmpsDevi_;
  // std::vector<string> waveTypes_; 后台暂只按p波计算定位
  bool evenVelocity_;
  float pMin_;
  float pMax_;
  // float sMin_;
  // float sMax_;
  float minTime_;
  std::vector<VTISpeed> vtis_;
  uint8_t minValidChns_;
  float pwChkCoef_;
  int abnormPeak_;
  float sensitivity_; // 传感器灵敏系数
  float
      pulseThreshold_; // 脉冲干扰判断阈值，默认1ms。最大振幅与其前反向极值时差

  std::vector<std::string> validChns_;
  std::unordered_map<std::string, std::pair<size_t, size_t>> psArrivals_;
  std::unordered_map<std::string, size_t> maxPnt_; // 最大振幅所在点
  EvtRecord evtResult_;
  std::vector<std::pair<std::string, uint64_t>>
      chEnergies_; // 按振幅能量排序：通道标->能量值
  std::map<std::string, uint8_t> chnsByEnergy_; // 按振幅能量排序：通道标->序号
  LocF minLoc_, maxLoc_;                        // 定位限定范围
  float step_ = 20;                             // 默认步长20米
  std::unordered_map<std::string, ChanelsConfig>
      currentChnsConfig_;         // 当时通道信息
  ms_reg::peaks_t validChnPeaks_; //各有效通道峰值绝对值
  ms_reg::coords_t validChnLocs_; //各有效通道坐标
  ms_reg::RegVariables regVariables_;
};

#endif
```
```cpp
//MSDataFrame.cpp
#include <cmath>
#include <cstdlib>
#include <execution>
#include <functional>
#include <map>
#include <mutex>
#include <numeric>

#include "Config.hpp"
#include "MSDataFrame.hpp"
#include "algorithms/commonalg/CommonAlgorithm.hpp"
#include "common.hpp"
#include "ms_regression.hpp"
#include "sender.hpp"
#include "web/Data.hpp"
#include "web/commands.hpp"

namespace {
std::pair<LocF, LocF>
findMinMaxLocs(const std::multimap<int, LocF> &minSimils) {
  LocF minLoc = {std::numeric_limits<float>::max(),
                 std::numeric_limits<float>::max(),
                 std::numeric_limits<float>::max()};
  LocF maxLoc = {std::numeric_limits<float>::lowest(),
                 std::numeric_limits<float>::lowest(),
                 std::numeric_limits<float>::lowest()};

  for (const auto &pair : minSimils) {
    const LocF &loc = pair.second;

    minLoc.x = std::min(minLoc.x, loc.x);
    minLoc.y = std::min(minLoc.y, loc.y);
    minLoc.z = std::min(minLoc.z, loc.z);

    maxLoc.x = std::max(maxLoc.x, loc.x);
    maxLoc.y = std::max(maxLoc.y, loc.y);
    maxLoc.z = std::max(maxLoc.z, loc.z);
  }

  return {minLoc, maxLoc};
}
}; // namespace

void MSDataFrame::print(string prefix) const {
  DataFrame::print(prefix);
  cout << "采用特征函数:" << (unsigned)characFunc_ << ",";
  cout << "取最大值数据点数:" << maxAmps_ << ",";
  cout << "最大值分布标准差:" << maxAmpsDevi_ << ",";
  cout << std::boolalpha << "均匀速度模型?" << evenVelocity_ << ",";
  cout << "p波最小波速:" << pMin_ << ",";
  cout << "p波最大波速:" << pMax_ << ",";
  cout << "最小相对到时(ms):" << minTime_ << ",";
  cout << "定位最少有效道数:" << (unsigned)minValidChns_ << ",";
  cout << "工频检测系数:" << pwChkCoef_ << ",";
  cout << "异常峰值(v):" << abnormPeak_ << ",";
  cout << "脉冲判断阈值(ms):" << pulseThreshold_ << "\n";
}
string MSDataFrame::trigChnLabel() const {
  if (msTrigChn() == 0) {
    return "";
  }
  auto conn = hzi::config.pConnPool->getConnection();
  auto rslt = conn.executeQuery(
      "select chn_label from e_chns_config where type_id=0 and dev_id=? and "
      "chn_no=?",
      msTrigDev(), msTrigChn());
  return rslt.next() ? rslt.getString("chn_label") : "";
}

tl::expected<int, string> MSDataFrame::validChns() {
  debugLog("MSDataFrame::validChns start...");
  if (upData == nullptr) {
    return tl::make_unexpected("maxAmpDevis error: data not ready");
  }
  auto labels = chnLabels();
  auto chnsConfig = getChnConfigByTime(0, sampTime());

  for (int i = 0; i < channels(); i++) {
    // 剔除坏道
    if (chnsConfig[labels[i]].stateId != 0) {
      continue;
    }

    int32_t *pData = chnData(i);
    std::multimap<uint32_t, uint16_t, std::greater<uint32_t>> maxAbsLocs;
    for (int j = 0; j < points(); j++) {
      maxAbsLocs.insert(std::pair<uint32_t, uint16_t>(std::abs(pData[j]), j));
    }

    double avrg = 0;
    auto itr = maxAbsLocs.begin();
    auto validPnts = maxAmps_ < points() ? maxAmps_ : points();
    for (int j = 0; j < validPnts; ++j, ++itr) {
      avrg += itr->second;
    }
    avrg /= validPnts;

    double variance = 0;
    itr = maxAbsLocs.begin();
    for (int j = 0; j < maxAmps_ && itr != maxAbsLocs.end(); ++j, ++itr) {
      variance += std::pow(itr->second - avrg, 2);
    }
    variance /= validPnts;

    auto maxLocsDevi = std::sqrt(variance);

    // maxAmps_个最大值分布偏差较大，视为无效通道
    if (maxLocsDevi >= maxAmpsDevi_) {
      string msg("MSDataFrame::validChns: 无效通道: ");
      msg += labels[i] + ", 大振幅分散";
      debugLog(msg);
      continue;
    }

    auto vCoef = hzi::config.voltageCoef;
    auto peakVal = maxAbsLocs.begin()->first * vCoef;
    // 峰值特别大，视为无效通道

    if (peakVal > abnormPeak_ * 1000) {
      string msg("MSDataFrame::validChns: 无效通道: ");
      msg += labels[i] + ", 峰值过高:" + std::to_string(peakVal) + ">" +
             std::to_string(abnormPeak_ * 1000);
      debugLog(msg);
      continue;
    }

    // 测试4个50Hz数据点方差
    const size_t peakIdx = maxAbsLocs.begin()->second;
    int pnts50 = std::round(20.0 / sampIntvl());
    vector<double> pwData;
    for (int j = peakIdx; j < 4 * pnts50 + peakIdx && j < points();
         j += pnts50) {
      auto val = pData[j] * vCoef;
      pwData.push_back(std::abs(val));
    }
    double pwAvg = std::reduce(pwData.begin(), pwData.end(), 0.0,
                               [](auto &a, auto &b) { return a + b; }) /
                   pwData.size();
    double pwVari = std::reduce(pwData.begin(), pwData.end(), 0.0,
                                [&](double &a, double &b) {
                                  return a + (b - pwAvg) * (b - pwAvg);
                                }) /
                    pwData.size();

    double pwSqrSum =
        std::reduce(pwData.begin(), pwData.end(), 0.0,
                    [&](double &a, double &b) { return a + b * b; });
    double pwDevi = std::sqrt(pwVari);
    double dispersionIndex = 4 * pwVari / pwSqrSum;

    // cout << "pwAvg:" << pwAvg << ",pwVari:" << pwVari << ",pwDevi:" << pwDevi
    //      << ",pwChkCoef_:" << pwChkCoef_ << ",dispIndex:" << dispersionIndex
    //      << ",CV:" << pwVari / pwAvg << "\n";

    // 符合工频分布特点，视为无效通道
    if (pwDevi < pwChkCoef_) {
      string msg("MSDataFrame::validChns: 无效通道: ");
      msg += labels[i] + ", 工频干扰:";
      msg += "pwDevi:" + to_string_with_precision(pwDevi, 4);
      msg += ",dispersionIndex:" + to_string_with_precision(dispersionIndex, 4);
      msg += ",coef of variance:" + to_string_with_precision(pwVari / pwAvg, 4);

      debugLog(msg);
      continue;
    }

    auto j = peakIdx - 1;
    // while (j > 0 && (pData[peakIdx] * vCoef * (pData[j] * vCoef) > 0))
    while (j > 0 &&
           (std::copysign(1, pData[peakIdx]) * std::copysign(1, pData[j]) > 0))
      j--;
    auto jj = j;
    while (jj > 0 && (abs(pData[jj]) > abs(pData[jj + 1])))
      jj--;

    //如果最大振幅与其前面极值处时差小于pulseThreshold，认为是脉冲干扰
    float delt = (peakIdx - jj) * sampIntvl();
    if (delt < pulseThreshold_) {
      string msg("MSDataFrame::validChns: 无效通道: ");
      msg += labels[i] + ", 脉冲干扰:";
      msg += std::to_string(delt) + "<" + std::to_string(pulseThreshold_);
      debugLog(msg);
      continue;
    }
    validChns_.push_back(labels[i]);
  }
  return 0;
}

tl::expected<int, std::string> MSDataFrame::psArrsByVarAic() {
  auto labels = chnLabels();
  psArrivals_.clear();
  for (size_t i = 0; i < channels(); i++) {
    auto lbl = labels[i];

    if (std::find(validChns_.begin(), validChns_.end(), lbl) ==
        validChns_.end()) {
      continue;
    }
    int32_t *cData = chnData(i);

    // 找出幅值绝对值最大点
    size_t max = 0, p = 0;
    for (size_t j = 0; j < points(); j++) {
      if (std::abs(cData[j]) > max) {
        max = std::abs(cData[j]);
        p = j;
      }
    }

    if (p < 20) { // p太小，没啥意义
      p = 20;
    }

    // 时窗
    auto l = p > 2000 ? 2000 : p;
    auto start = p - l;

    double minAIC = std::numeric_limits<float>::max();
    auto k = start + 10, kk = k;
    double sumLeft = 0, sumRight = 0, meanLeft, meanRight;
    std::vector<int> cfs;

    for (int j = start; j < p; j++) {
      auto val = CF(characFunc_, i, j);
      cfs.push_back(val);
      if (j < k) {
        sumLeft += val;
      } else {
        sumRight += val;
      }
    }

    for (; k < p - 10; k++) {
      size_t lefts = k + 1 - start; //左点数
      size_t rights = p - k - 1;    //右点数
      size_t ii = k - start;
      // 初值: ii = start + 10 - start = 10
      // 终值: ii =p -10 -1 -start = p - 11 -(p - l) = l - 11
      // cfs.size = p - start = p - (p - l) = l
      sumLeft += cfs[ii];
      sumRight -= cfs[ii];
      meanLeft = sumLeft / lefts;
      meanRight = sumRight / rights;

      double varLeft = 0, varRight = 0;
      for (int m = p - l; m < p; m++) {
        double val;
        auto mm = m - p + l;
        if (m <= k) {
          val = cfs[mm] - meanLeft;
          varLeft += val * val;
        } else {
          val = cfs[mm] - meanRight;
          varRight += val * val;
        }
      }
      varLeft /= lefts;
      varRight /= rights;

      auto aic = lefts * std::log10(varLeft) + rights * std::log10(varRight);
      if (aic < minAIC) {
        minAIC = aic;
        kk = k;
      }
    }
    size_t sPnt = p, count = 0;
    for (int j = sPnt; j > 0; j--) {
      if (cData[j] * cData[sPnt] < 0) {
        count++;
        sPnt = j;
        if (count == 3) {
          break;
        }
      }
    }
    if (sPnt < kk) {
      sPnt = kk;
    }
    maxPnt_.insert({lbl, p});
    psArrivals_.insert({lbl, std::make_pair(kk, sPnt)});
  }
  return 0;
}

tl::expected<int, string> MSDataFrame::setLocatingParams(zdb::ResultSet &rslt) {
  try {
    characFunc_ = rslt.getInt("charac_func");
    maxAmps_ = rslt.getInt("max_amps");
    maxAmpsDevi_ = rslt.getInt("maxamps_devi");
    evenVelocity_ =
        rslt.getInt("velocity_type") == 0 ? true : false; // 是否均匀速度
    pMin_ = rslt.getDouble("p_min");
    pMax_ = rslt.getDouble("p_max");
    minTime_ = rslt.getDouble("min_time");
    minValidChns_ = rslt.getInt("min_valid_chns");
    pwChkCoef_ = rslt.getDouble("pw_chk_coef");
    abnormPeak_ = rslt.getInt("abnorm_peak");
    engMagNo_ = rslt.getInt("eng_mag_no");
    sensitivity_ = rslt.getDouble("sensitivity");
    pulseThreshold_ = rslt.getDouble("pulse_threshold");
    hzi::config.probeTo.minX = rslt.getDouble("probe_minx");
    hzi::config.probeTo.minY = rslt.getDouble("probe_miny");
    hzi::config.probeTo.minZ = rslt.getDouble("probe_minz");
    hzi::config.probeTo.maxX = rslt.getDouble("probe_maxx");
    hzi::config.probeTo.maxY = rslt.getDouble("probe_maxy");
    hzi::config.probeTo.maxZ = rslt.getDouble("probe_maxz");

    if (!evenVelocity_) { // 层状速度模型
      auto conn = hzi::config.pConnPool->getConnection();
      return cmd::queryDb(conn, "select start_loc,end_loc,p_speed,s_speed from "
                                "e_vti_speeds order by "
                                "start_loc")
          .and_then([&](ResultSet rslt) -> tl::expected<int, string> {
            do {
              VTISpeed vti{rslt.getDouble("start_loc"),
                           rslt.getDouble("end_loc"), rslt.getDouble("p_speed"),
                           rslt.getDouble("s_speed")};
              vtis_.push_back(vti);
            } while (rslt.next());

            if (vtis_.size() > 1) {
              return 0;
            } else {
              tl::make_unexpected("MSDataFrame::setLocationgParams error: "
                                  "vti层数过少");
            }
          });
    }

    auto conn = hzi::config.pConnPool->getConnection();
    return cmd::queryDb(
               conn,
               "select "
               "min(loc_x),max(loc_x),min(loc_y),max(loc_y),min(loc_z),max("
               "loc_z) from e_chns_config where type_id=0")
        .and_then([&](zdb::ResultSet rslt) -> tl::expected<int, string> {
          minLoc_.x = std::floor(rslt.getDouble("min(loc_x)") / 10.0) * 10 -
                      hzi::config.probeTo.minX;
          minLoc_.y = std::floor(rslt.getDouble("min(loc_y)") / 10.0) * 10 -
                      hzi::config.probeTo.minY;
          minLoc_.z = std::floor(rslt.getDouble("min(loc_z)") / 10.0) * 10 -
                      hzi::config.probeTo.minZ;
          maxLoc_.x = std::ceil(rslt.getDouble("max(loc_x)") / 10.0) * 10 +
                      hzi::config.probeTo.maxX;
          maxLoc_.y = std::ceil(rslt.getDouble("max(loc_y)") / 10.0) * 10 +
                      hzi::config.probeTo.maxY;
          maxLoc_.z = std::ceil(rslt.getDouble("max(loc_z)") / 10.0) * 10 +
                      hzi::config.probeTo.maxZ;
          return 0;
        });
  } catch (zdb::sql_exception e) {
    return tl::make_unexpected(string("MSDataFrame::setLocatingParams error:") +
                               e.what());
  }
}
tl::expected<int, string> MSDataFrame::setLocatingParams() {
  auto conn = hzi::config.pConnPool->getConnection();
  auto dbExp =
      cmd::queryDb(conn, "select * from e_ms_locating_params where id=1");
  if (!dbExp) {
    // 数据库插入默认参数
    auto dbExp1 =
        cmd::queryDb(conn, "select * from p_ms_locating_types where id=1");
    if (!dbExp1) {
      conn.execute(
          "insert into p_ms_locating_types (id, name) values(1, '煤矿')");
    }
    conn.execute(
        "insert into e_ms_locating_params (id, name) values(1, '煤矿')");

    return tl::make_unexpected(string("MSDataFrame::setLocatingParams error:") +
                               dbExp.error());
  }

  zdb::ResultSet &rslt = dbExp.value();
  return setLocatingParams(rslt);
}

int MSDataFrame::CF(size_t cf, size_t chn, size_t pnt) {
  int32_t *pData = (int32_t *)upData.get();
  auto i = chn * points() + pnt;
  switch (cf) {
  case 1:
    return std::abs(pData[i]);
  case 2:
    return pData[i] * pData[i];
  case 3:
    return (pData[i] - pData[i - 1]);
  case 4:
    return pData[i] * pData[i] - pData[i - 1] * pData[i + 1];
  default:
    break;
  }
}

tl::expected<int, string> MSDataFrame::setValidity(bool valid) {
  try {
    auto conn = hzi::config.pConnPool->getConnection();
    auto vld = valid ? 1 : 0;
    double ts = sampTime() / 1000.0;
    conn.execute(
        "update e_data_frm_info set ms_validity=? where class_id=2 and "
        "(unix_timestamp(samp_time)*1000+2)>? limit 1 ", // 提速
        // "unix_timestamp(samp_time)*1000-2<?",
        vld, (double)sampTime());
    return 0;
  } catch (zdb::sql_exception e) {
    return tl::make_unexpected(string("MSDataFrame::setValidity error:") +
                               e.what());
  }
}

tl::expected<int, string> MSDataFrame::savePSArrivals() {
  try {
    auto labels = chnLabels();
    auto conn = hzi::config.pConnPool->getConnection();
    conn.execute("delete from e_msevt_1st_arrs where samp_time=?",
                 (double)sampTime());

    PreparedStatement prp = conn.prepareStatement(
        "INSERT INTO  e_msevt_1st_arrs "
        "(chn_label,dev_id,samp_time,chn_no,p_time,s_time) "
        "values(?,?,?,?,?,?)");
    conn.beginTransaction();
    for (int i = 0; i < channels(); i++) {
      auto lbl = labels[i];
      auto devAddr = atoi(lbl.substr(1, 1).c_str());
      auto chnno = atoi(lbl.substr(4, 2).c_str());
      prp.bind(1, lbl);
      prp.bind(2, (int)devAddr);
      prp.bind(3, (double)sampTime());
      prp.bind(4, chnno);
      auto itr = psArrivals_.find(lbl);
      if (itr != psArrivals_.end()) {
        prp.bind(5, (float)itr->second.first * sampIntvl());
        prp.bind(6, (float)itr->second.second * sampIntvl());
      } else {
        prp.bind(5, -10000);
        prp.bind(6, -10000);
      }
      prp.execute();
    }
    conn.commit();
    return 0;
  } catch (zdb::sql_exception e) {
    return tl::make_unexpected(string("MSDataFrame::savePSArrivals error:") +
                               e.what());
  }
}

tl::expected<EvtRecord, string> MSDataFrame::locating2(string waveType) {
  auto minSpeed = pMin_;
  auto maxSpeed = pMax_;

  std::multimap<float, string> arrivals;

  for (const auto &item : psArrivals_) {
    const std::string &key = item.first;
    float value = waveType == "p_time" ? item.second.first : item.second.second;

    arrivals.insert(std::make_pair(value * sampIntvl(), key));
  }
  auto spcExp = cmd::querySpcLimits(sampTime(), minTime_, maxSpeed);
  if (!spcExp) {
    return tl::make_unexpected(string("MSDataFrame::locating1 error:") +
                               spcExp.error());
  }

  LocF minLoc = spcExp.value().first;
  LocF maxLoc = spcExp.value().second;
  return ms_vari::locating(std::move(arrivals), minSpeed, maxSpeed, minTime_,
                           sampTime(), minLoc, maxLoc,
                           evenVelocity_ ? "even" : "layered", waveType, vtis_);
}
tl::expected<int, string> MSDataFrame::locating1() {
  if (psArrivals_.size() < minValidChns_) {
    return setValidity(false)
        .and_then([&](auto ret) -> tl::expected<int, string> {
          string msg("有效通道数为");
          msg += std::to_string(psArrivals_.size());
          msg += ",少于预设值:" + std::to_string(minValidChns_);
          return tl::make_unexpected(msg);
        })
        .or_else([&](auto err) -> tl::expected<int, string> {
          return tl::make_unexpected(string("MSDataFrame::locating1 error:") +
                                     err);
        });
  }

  auto exp = locating2("p_time").and_then([&](EvtRecord record) {
    debugLog("定位成功");
    evtResult_ = record;
    return calcEnergy().and_then([&](auto r) {
      debugLog("能量计算完成");
      return saveLocation();
    });
  });
  if (!exp) {
    string errMsg("定位失败, 原因：");
    errMsg += exp.error();
    debugErr(errMsg);
    return tl::make_unexpected(string("MSDataFrame::locating1 error:") +
                               exp.error());
  }
  return 0;
}
tl::expected<int, string> MSDataFrame::saveLocation() {
  return setValidity(true).and_then([&](auto ret) -> tl::expected<int, string> {
    try {
      auto conn = hzi::config.pConnPool->getConnection();
      string ms_locationStr = "";
      auto rslt = conn.executeQuery("select  wf_name from e_info");
      if (rslt.next()) {
        ms_locationStr = rslt.getString("wf_name"); //工作面名称
      }
      string sql("insert into e_msevt_rslts "
                 "(samp_time,dev_id,validity,loc_x"
                 ",loc_y,loc_z,energy,magnitude,"
                 "evt_time,"
                 "speed_p,mainfreq,max_amp,ave_amp,ms_location,msg)values(?,?,?"
                 ",?,?,?,?,?,?,?,?,?,?,?,?) on duplicate key "
                 "update "
                 "dev_id=values(dev_id),validity="
                 "values(validity),loc_x=values(loc_x),"
                 "loc_y=values(loc_y),"
                 "loc_z=values(loc_z)"
                 ",energy=values(energy),magnitude=values("
                 "magnitude),evt_time=values(evt_time),speed_p=values("
                 "speed_p),mainfreq=values(mainfreq),"
                 "max_amp=values(max_amp),ave_amp=values(ave_amp),"
                 "ms_location=values(ms_location),msg=values(msg)");
      conn.execute(sql.c_str(), (double)sampTime(), devMask(), 1,
                   evtResult_.loc.x, evtResult_.loc.y, evtResult_.loc.z,
                   evtResult_.energy, evtResult_.magnitude, evtResult_.time,
                   evtResult_.speed, evtResult_.mainfreq, evtResult_.maxAmp,
                   evtResult_.aveAmp, ms_locationStr, "null");
      return 0;
    } catch (zdb::sql_exception e) {
      return tl::make_unexpected(string("MSDataFrame::saveLocation error:") +
                                 e.what());
    }
  });
}
tl::expected<int, string> MSDataFrame::prepare() {
  return setLocatingParams()
      .and_then([&](auto ret) {
        debugLog("setLocatingParams ok");
        return validChns();
      })
      .and_then([&](auto ret) {
        string msg("validChns_.size:");
        msg += std::to_string(validChns_.size());
        debugLog(msg);
        return psArrsByVarAic();
      })
      .and_then([&](auto ret) {
        debugLog("calculate psArrsByVarAic ok");
        return delBiasChns();
      })
      .and_then([&](auto ret) {
        debugLog("delBiasChns ok");
        return savePSArrivals();
      })
      .and_then([&](auto ret) -> tl::expected<int, string> {
        debugLog("savePSArrivals ok");
        string trigLbl = trigChnLabel();
        debugLog("trigChnLabel ok");
        if (!trigLbl.empty() && !emitting() &&
            std::find(validChns_.begin(), validChns_.end(), trigLbl) ==
                validChns_.end() &&
            invalidTrig(trigLbl, sampTime())) {
          toggleTrig(trigLbl, false)
              .map([&](auto r) {
                string msg(trigLbl);
                msg += "频繁触发微震，已取消触发";
                logInfo(msg);
                string cmd("./send_message.sh \"msg\" \"");
                cmd += msg;
                cmd += "\"";
                system(cmd.c_str());
              })
              .map_error([&](auto e) {
                logErr(trigLbl + "频繁触发微震，取消失败:" + string(e));
              });
        }
        return 0;
      });
}

tl::expected<int, string> MSDataFrame::locating() {
  std::chrono::milliseconds duration(sampTime());
  std::chrono::time_point<std::chrono::system_clock> timePoint(duration);
  string msg("MSDataFrame::locating 定位微震事件:");
  msg += timeStr(timePoint);
  debugLog(msg);

  return prepare()
      .and_then([&](auto ret) {
        debugLog("MSDataFrame::locating: prepare ok");
        return locating1();
      })
      .or_else([&](auto err) {
        string msg("MSDataFrame::locating 失败：");
        msg += err;
        debugLog(msg);
        setValidity(false).map([&](auto r) { debugLog("设置该事件无效"); });

        return tl::expected<int, string>(
            tl::make_unexpected(string("MSDataFrame::locating error:") + err));
      });
}

tl::expected<int, string> MSDataFrame::delBiasChns() {
  if (psArrivals_.size() < minValidChns_) {
    return 0;
  }
  double pSum = 0;
  for (const auto &ps : psArrivals_) {
    pSum += ps.second.first;
  }
  double pMean = pSum / psArrivals_.size();
  vector<float> bias;
  for (auto it = validChns_.begin(); it != validChns_.end(); ++it) {
    auto ps = psArrivals_[*it];
    double b = ((ps.first - pMean) / pMean) * 100;
    if (std::fabs(b) >= 100) {
      psArrivals_.erase(*it);
      validChns_.erase(it);
      return delBiasChns();
    }
  }
  return 0;
}
tl::expected<float, string> MSDataFrame::energyByRegression(LocF source) {
  if (validChns_.size() == 0) {
    return tl::make_unexpected("error calcEnergy:有效通道数不够");
  }

  ms_reg::RegVariables regVar;
  cout << "abs peaks:\n";
  for (auto &v : validChnPeaks_) {
    cout << v.first << ":" << v.second << "\n";
  }
  return 0;
}

tl::expected<int, string> MSDataFrame::calcEnergy() {
  if (validChns_.size() == 0) {
    return tl::make_unexpected("error calcEnergy:有效通道数不够");
  }
  auto chLbls = chnLabels();
  auto labels = std::reduce(
      std::next(validChns_.begin()), validChns_.end(), validChns_[0],
      [](string const &acc, string const &cur) { return acc + "','" + cur; });
  string sql(
      "select chn_label,loc_x,loc_y,loc_z from e_chns_config where chn_label "
      "in ('");
  sql += labels + "')";
  std::map<string, std::tuple<float, float, float>> locs;
  auto conn = hzi::config.pConnPool->getConnection();
  cmd::queryDb(conn, sql.c_str()).map([&](zdb::ResultSet rslt) {
    do {
      locs.insert({rslt.getString("chn_label"),
                   {rslt.getDouble("loc_x"), rslt.getDouble("loc_y"),
                    rslt.getDouble("loc_z")}});
    } while (rslt.next());
  });

  int m = 2048;

  vector<float> energies;
  std::vector<float> maxAmps;                   //最大振幅
  std::vector<float> amps_pj;                   //平均振幅
  std::vector<float> mainfreqs;                 //主频
  float smpFreq_cy = 1000 * 1.0f / sampIntvl(); //采样频率

  for (const auto &ch : validChns_) {
    auto locMap = locs[ch];
    //计算主频
    auto tp = psArrivals_[ch].first * sampIntvl() - evtResult_.time,
         ts = psArrivals_[ch].second * sampIntvl() - evtResult_.time;
    int pnts = std::floor((ts - tp) / sampIntvl());

    int from = psArrivals_[ch].first;
    int to = from + pnts;
    if (to > points()) {
      to = points();
    }

    auto itr = std::find(chLbls.begin(), chLbls.end(), ch);
    auto ii = std::distance(chLbls.begin(), itr);
    int32_t *cData = chnData(ii);

    vector<float> real(m, 0.0f), imag(m, 0.0f);
    for (size_t i = from; i < to && i < from + m; i++) {
      real.push_back(cData[i] * hzi::config.voltageCoef);
    }
    // float amp_pj = std::accumulate(real.begin(), real.end(), 0.0f) /
    // real.size(); 使用lambda表达式计算绝对值累加
    float totalAbsoluteValue = std::accumulate(
        real.begin(), real.end(), 0.0f,
        [](float sum, float value) { return sum + std::fabs(value); });

    // 计算平均值
    float amp_pj = totalAbsoluteValue / real.size();
    amps_pj.push_back(amp_pj); //存储平均振幅
    // 以频域最大幅值计算能量结果太小 FFT
    HZIComAlg::tfft(real.data(), imag.data(), m, 1);

    double maxAmp = 0.0;
    size_t maxIndex = 0;

    // double max = std::reduce(real.begin(), real.end(), 0,
    //                          [](auto const& a, auto const& b) {
    //                              return a > std::fabs(b) ? a :
    //                              std::fabs(b);
    //                          });
    float df = smpFreq_cy / real.size();
    for (size_t i = 0; i < m; i++) {
      auto a = real[i], b = imag[i];
      double val = std::sqrt(a * a + b * b) / pnts;
      if (val > maxAmp) {
        if (i * df > 60 && i * df < 300) {
          maxAmp = val;
          maxIndex = i;
        }
        // maxAmp = val;
        // maxIndex = i; // 保存最大幅度的索引
      }
    }
    //主频
    float mainFrequency = maxIndex * df;
    mainfreqs.push_back(mainFrequency); //主频
    // 以时域最大幅值均值计算能量
    // std::fabs(cData[psArrivals_[ch].second] * hzi::config.voltageCoef);
    double max = std::fabs(cData[maxPnt_[ch]] * hzi::config.voltageCoef);
    maxAmps.push_back(max);

    double Ai = max / sensitivity_ / 1000;
    auto x = std::get<0>(locMap), y = std::get<1>(locMap),
         z = std::get<2>(locMap);
    auto x0 = evtResult_.loc.x, y0 = evtResult_.loc.y, z0 = evtResult_.loc.y;

    double r = std::sqrt((x - x0) * (x - x0) + (y - y0) * (y - y0) +
                         (z - z0) * (z - z0));
    auto eng =
        Ai * Ai * r * r * std::exp(r / 500) * 4 * 3.1415926 * 9.8 * 2.6 * 1000;
    energies.push_back(eng);
  }

  float main_freq = std::accumulate(mainfreqs.begin(), mainfreqs.end(), 0.0f) /
                    mainfreqs.size();
  evtResult_.mainfreq = main_freq;
  evtResult_.aveAmp = *std::max_element(amps_pj.begin(), amps_pj.end());
  evtResult_.maxAmp = *std::max_element(maxAmps.begin(), maxAmps.end());

  evtResult_.energy =
      std::accumulate(energies.begin(), energies.end(), 0.0) / energies.size();

  evtResult_.magnitude = engMagNo_ == 1
                             ? (std::log10(evtResult_.energy) - 1.8) / 1.9
                             : (std::log10(evtResult_.energy) - 4.8) / 1.5;

  return 0;
}

tl::expected<int, string> MSDataFrame::toggleTrig(string chLbl, bool enable) {
  try {
    uint8_t enbl = enable ? 1 : 0;
    auto conn = hzi::config.pConnPool->getConnection();
    // string sql("update e_chns_config set is_ms_trig=0 where
    // chn_label='"); sql += chLbl + "'"; sql += " and is_ms_trig=1";
    string sql("update e_chns_config set is_ms_trig=");
    sql += (enable ? "1" : "0");
    sql += " where chn_label='" + chLbl + "'";
    // string sql("update e_chns_config set is_ms_trig=? where chn_label='?'");
    // conn.execute(sql.c_str(), enbl, chLbl);
    debugLog(sql);
    conn.execute(sql.c_str());
    int devId = (int)chLbl[1] - '0';
    auto upData = std::unique_ptr<DevConfig>(new DevConfig());

    auto upData1 = std::unique_ptr<StartMonitor>(new StartMonitor());
    return upData->setValues(devId)
        .and_then([&](auto r) {
          buf_t upBuf = upData->getBuf();
          return sender::sendCmd(devId, 3, upBuf.get());
        })
        .and_then([&](auto r) {
          Document nullDoc;
          return upData1->setValues(devId, nullDoc).and_then([&](auto r) {
            buf_t upBuf1 = upData1->getBuf();
            return sender::sendCmd(devId, 4, upBuf1.get());
          });
        });
  } catch (zdb::sql_exception e) {
    return tl::make_unexpected(string("MSDataFrame::toggleTrig sql error:") +
                               e.what());
  } catch (zdb::sql_exception e) {
    return tl::make_unexpected(
        string("MSDataFrame::toggleTrig general error:") + e.what());
  }
}
tl::expected<int, string> MSDataFrame::chnSortedByEnergy(
    const std::optional<std::unordered_map<string, std::pair<float, uint16_t>>>
        &givenData) {
  try {
    std::multimap<double, std::pair<string, uint16_t>, std::greater<uint64_t>>
        energies;
    auto chLbls = chnLabels();
    string msg(timestampToString(sampTime()));
    msg += ":number of valid channels:" + std::to_string(validChns_.size());
    debugLog(msg);
    for (int i = 0; i < channels(); i++) {
      if (std::find(validChns_.begin(), validChns_.end(), chLbls[i]) ==
          validChns_.end()) {
        continue;
      }
      if (givenData.has_value()) {
        auto itr = givenData->find(chLbls[i]);
        if (itr != givenData->end()) {
          energies.insert({itr->second.first, {chLbls[i], itr->second.second}});
        }
      } else {
        int32_t *pData = chnData(i);
        //改用峰值绝对值
        auto peakItr =
            std::max_element(pData, pData + points(), [](int32_t a, int32_t b) {
              return std::abs(a) < std::abs(b); // Compare by absolute value
            });
        auto peakVal = *peakItr;
        auto peakIdx = std::distance(pData, peakItr);
        energies.insert({abs(peakVal), {chLbls[i], peakIdx}});
        // uint64_t sum = std::accumulate(
        //     pData, pData + points(), 0,
        //     [](uint64_t acc, int32_t val) { return acc + val * val; });
        // energies.insert({sum, chLbls[i]});
      }
    }

    for (auto it = energies.begin(); it != energies.end(); ++it) {
      double atTime = sampTime() + (double)it->second.second * sampIntvl();
      auto timeStr = timestampToString(atTime);
      timeStr = timeStr.substr(timeStr.find(' ') + 1);
      string msg =
          it->second.first + ":peak absolute value:" +
          to_string_with_precision(
              it->first * (givenData ? 1.0 : hzi::config.voltageCoef)) +
          " at:" + timeStr + "(" + std::to_string(it->second.second) + ")";
      debugLog(msg);
    }

    if (!chEnergies_.empty()) {
      chEnergies_.clear();
    }
    for (const auto &pair : energies) {
      chEnergies_.push_back(std::make_pair(pair.second.first, pair.first));
    }

    if (!chnsByEnergy_.empty()) {
      chnsByEnergy_.clear();
    }
    uint8_t order = 0;
    for (const auto &c : chEnergies_) {
      chnsByEnergy_[c.first] = order++;
    }
    return 0;
  } catch (std::exception e) {
    return tl::make_unexpected(
        string("MSDataFrame::chnSortedByEnergy() error:") + e.what());
  }
}

std::vector<string> MSDataFrame::sortedValidChnsByDists(const LocF &loc) {
  std::multimap<double, string> svd;
  auto chnsConfig = currentChnsConfig_;
  for (auto &chn : chEnergies_) {
    // auto x1 = hzi::msChannelsConfigsMap[chn.first].locX;
    // auto y1 = hzi::msChannelsConfigsMap[chn.first].locY;
    // auto z1 = hzi::msChannelsConfigsMap[chn.first].locZ;
    auto x1 = chnsConfig[chn.first].locX;
    auto y1 = chnsConfig[chn.first].locY;
    auto z1 = chnsConfig[chn.first].locZ;

    auto dist =
        std::sqrt((x1 - loc.x) * (x1 - loc.x) + (y1 - loc.y) * (y1 - loc.y) +
                  (z1 - loc.z) * (z1 - loc.z));
    svd.insert(std::make_pair(dist, chn.first));
  }
  std::vector<string> chns;
  for (const auto &entry : svd) {
    chns.push_back(entry.second);
  }
  return chns;
}

double MSDataFrame::squares(const EnergyFitRecord &rec,
                            std::vector<std::pair<double, double>> fitData) {
  return std::accumulate(fitData.begin(), fitData.end(), 0.0,
                         [&](double acc, std::pair<double, double> cur) {
                           return std::pow(rec.fitValue(cur.first) - cur.second,
                                           2);
                         });
}

tl::expected<std::pair<LocF, LocF>, string> MSDataFrame::spaceLimitsByEnergy(
    const LocF &minLoc, const LocF &maxLoc,
    const std::optional<std::unordered_map<string, std::pair<float, uint16_t>>>
        &givenData) {
  return setLocatingParams()
      .and_then([&](auto ret) { return chnSortedByEnergy(); })
      .and_then([&](auto ret) -> tl::expected<std::pair<LocF, LocF>, string> {
        std::mutex mtx;
        std::multimap<int, LocF> minSimilarities;
        vector<LocF> points;
        for (float x = minLoc.x; x <= maxLoc.x; x += step_) {
          for (float y = minLoc.y; y <= maxLoc.y; y += step_) {
            for (float z = minLoc.z; z <= maxLoc.z; z += step_) {
              // points.push_back({x, y, z});
              LocF loc{x, y, z};
              auto similarity = similarityBySortedDists(loc);
              minSimilarities.insert(std::make_pair(similarity, loc));
              // if (minSimilarities.size() < 10 ||
              //     minSimilarities.rbegin()->first == similarity) {
              //   minSimilarities.insert(std::make_pair(similarity, loc));
              // }
            }
          }
        }

        // std::for_each(std::execution::par_unseq, points.begin(),
        // points.end(),
        //               [&](LocF &loc) {
        //                 auto similarity = similarityBySortedDists(loc);
        //                 std::unique_lock<std::mutex> lck(mtx);
        //                 if (minSimilarities.size() < 200 &&
        //                     minSimilarities.size() < points.size()) {
        //                   minSimilarities.insert(
        //                       std::make_pair(similarity, loc));
        //                 }
        //               });

        cout << "minSimilarities size:" << minSimilarities.size() << "\n";
        auto itr = minSimilarities.begin();
        uint8_t i = 0;
        while (i < 10) {
          itr->second.print(std::to_string(itr->first));
          ++itr;
          ++i;
        }
        cout << "\n";
        return findMinMaxLocs(minSimilarities);
      });
}

tl::expected<EnergyFitRecord, string> MSDataFrame::locating3(LocF &lastLoc,
                                                             const LocF &minLoc,
                                                             const LocF &maxLoc,
                                                             float lastCost) {
  float curCost = lastCost;
  EnergyFitRecord minRec;
  std::multimap<int, LocF> minSimilarities;

  for (float x = minLoc.x; x <= maxLoc.x; x += step_) {
    for (float y = minLoc.y; y <= maxLoc.y; y += step_) {
      for (float z = minLoc.z; z <= maxLoc.z; z += step_) {
        // vector<std::pair<double, double>> fitData;
        LocF loc{x, y, z};
        auto similarity = similarityBySortedDists(loc);
        if (minSimilarities.size() < 10 ||
            minSimilarities.rbegin()->first == similarity) {
          minSimilarities.insert(std::make_pair(similarity, loc));
        }
      }
    }
  }
  std::pair<LocF, LocF> minMaxLocs = findMinMaxLocs(minSimilarities);
  minMaxLocs.first.x -= step_;
  minMaxLocs.second.x += step_;
  minMaxLocs.first.y -= step_;
  minMaxLocs.second.y += step_;
  minMaxLocs.first.z -= step_;
  minMaxLocs.second.z += step_;

  std::multimap<float, string> arrivals;

  string waveType("p_time");

  for (const auto &item : psArrivals_) {
    const std::string &key = item.first;
    float value = waveType == "p_time" ? item.second.first : item.second.second;

    arrivals.insert(std::make_pair(value * sampIntvl(), key));
  }
  auto minSpeed = pMin_;
  auto maxSpeed = pMax_;

  auto variLocExp =
      ms_vari::locating(std::move(arrivals), minSpeed, maxSpeed, minTime_,
                        sampTime(), minMaxLocs.first, minMaxLocs.second,
                        evenVelocity_ ? "even" : "layered", waveType, vtis_);
  if (variLocExp) {
    minRec.loc = variLocExp.value().loc;
  } else {
    return tl::make_unexpected(variLocExp.error());
  }
  return minRec;
}

tl::expected<int, string> MSDataFrame::locateByEnergy() {
  return prepare()
      .and_then([&](auto r) {
        if (psArrivals_.size() < minValidChns_) {
          return setValidity(false)
              .and_then([&](auto ret) -> tl::expected<int, string> {
                string msg("有效通道数为");
                msg += std::to_string(psArrivals_.size());
                msg += ",少于预设值:" + std::to_string(minValidChns_);
                return tl::make_unexpected(msg);
              })
              .or_else([&](auto err) -> tl::expected<int, string> {
                return tl::make_unexpected(
                    string("MSDataFrame::locateByEnergy error:") + err);
              });
        }
        return chnSortedByEnergy();
      })
      .and_then([&](auto r) {
        LocF initLoc{0, 0, 0};
        return locating3(initLoc, minLoc_, maxLoc_,
                         std::numeric_limits<float>::max());
      })
      .and_then([&](EnergyFitRecord efr) {
        debugLog("微震定位完成");
        evtResult_.loc = efr.loc;
        return calcEnergy();
      })
      .and_then([&](auto ret) {
        debugLog("能量计算完成");
        return saveLocation();
      })
      .or_else([&](auto err) { return setValidity(false); });
}

tl::expected<int, string> MSDataFrame::locateByRegression() {
  return prepare() // 主频等需要到时等
      .and_then([&](auto ret) {
        if (psArrivals_.size() < minValidChns_) {
          return setValidity(false).and_then(
              [&](auto ret) -> tl::expected<int, string> {
                string msg("有效通道数为");
                msg += std::to_string(psArrivals_.size());
                msg += ",少于预设值:" + std::to_string(minValidChns_);
                return tl::make_unexpected(msg);
              });
        }
        auto labels = chnLabels();
        debugLog("坐标和振幅峰值\nLabel\tx\ty\tz\tmaxVal");
        for (int i = 0; i < channels(); i++) {
          string label = labels[i];
          if (std::find(validChns_.begin(), validChns_.end(), label) ==
              validChns_.end())
            continue;
          auto &cc = hzi::msChannelsConfigsMap[label];
          int32_t *pData = chnData(i);
          auto itr = std::max_element(
              pData, pData + points(),
              [](int32_t a, int32_t b) { return abs(a) < abs(b); });
          validChnPeaks_[label] = std::abs(*itr) * hzi::config.voltageCoef;
          validChnLocs_[label] = {cc.locX, cc.locY, cc.locZ};
          if (hzi::config.verbose) {
            cout << label << "\t" << validChnLocs_[label].x << "\t"
                 << validChnLocs_[label].y << "\t" << validChnLocs_[label].z
                 << "\t" << validChnPeaks_[label] << "\n";
          }
        }
        return 0;
      })
      .and_then([&](auto r) {
        LocF minLoc{1e10, 1e10, 1e10}, maxLoc{-1e10, -1e10, -1e10};
        float minDist = 1e10; //检波器最小间距
        LocF lastPnt{1e4, 1e4, 1e4};
        for (const auto &ch : validChnLocs_) {
          auto c = ch.second;
          if (c.x < minLoc.x)
            minLoc.x = c.x;
          if (c.y < minLoc.y)
            minLoc.y = c.y;
          if (c.z < minLoc.z)
            minLoc.z = c.z;
          if (c.x > maxLoc.x)
            maxLoc.x = c.x;
          if (c.y > maxLoc.y)
            maxLoc.y = c.y;
          if (c.z > maxLoc.z)
            maxLoc.z = c.z;
          auto d = std::sqrt(std::pow(c.x - lastPnt.x, 2.0) +
                             std::pow(c.y - lastPnt.y, 2.0) +
                             std::pow(c.z - lastPnt.z, 2.0));
          if (d < minDist)
            minDist = d;
          lastPnt.x = c.x, lastPnt.y = c.y, lastPnt.z = c.z;
        }

        float initStep = minDist < 5 ? minDist * 3.0 : minDist / 2.0;
        // float initStep = minDist;

        //探测范围：从边缘检波器向外拓展距离
        minLoc.x -= hzi::config.probeTo.minX;
        minLoc.y -= hzi::config.probeTo.minY;
        minLoc.z -= hzi::config.probeTo.minZ;
        maxLoc.x += hzi::config.probeTo.maxX;
        maxLoc.y += hzi::config.probeTo.maxY;
        maxLoc.z += hzi::config.probeTo.maxZ;
        if (hzi::config.verbose) {
          minLoc.print("init minLoc");
          maxLoc.print("init maxLoc");
        }
        ms_reg::RegVariables regVars;
        regVars.engMagFormNo = engMagNo_;
        regVars.sensitivity = sensitivity_;

        return regVars.locating(validChnLocs_, validChnPeaks_, minLoc, maxLoc,
                                initStep, regVars);
      })
      .and_then([&](ms_reg::RegVariables rv) {
        regVariables_ = rv;
        return calcEnergy();
      })
      .and_then([&](auto r) {
        evtResult_.loc.x = regVariables_.source.x;
        evtResult_.loc.y = regVariables_.source.y;
        evtResult_.loc.z = regVariables_.source.z;
        evtResult_.energy = regVariables_.E;
        evtResult_.magnitude = regVariables_.magnitude();
        evtResult_.vari = 0;
        if (hzi::config.verbose) {
          regVariables_.print("Regression Result");
          evtResult_.print("Event Result");
        }
        return saveLocation();
      });
}
float MSDataFrame::similarityBySortedDists(const LocF &loc) {
  auto chnsByDists = sortedValidChnsByDists(loc);
  float similarity = 0.0;
  for (int i = 0; i < chnsByDists.size(); i++) {
    similarity += std::abs(i - chnsByEnergy_[chnsByDists[i]]);
  }
  return similarity;
}
```
```cpp
//ms_loacator.hpp
#ifndef MS_LOCATOR_HPP
#define MS_LOCATOR_HPP

#include <string>
#undef TRY
#include "zdbpp.h"

#include "Config.hpp"
#include "DataFrame.hpp"
#include "algorithms/msl/mslUsage.hpp"
#include "tl/expected.hpp"
#include "ProcessingData.hpp"
#include "post_handler.hpp"
bool getMeanValue_miningLocX(uint64_t tmStamp,double & miningLocX);
int getChnNO(uint8_t devAddr, string chnlabel);
void setChnns(vector<MSLCal::STELCalChn>& chnns, uint8_t devAddr);
void ms_locating(int64_t sampTime,
                 uint8_t devAddr,
                 std::unique_ptr<char[]>& pData,
                 std::unique_ptr<char[]>& head,
                 uint16_t channels);
// 按用户选择定位方法计算定位
tl::expected<int, std::string> ms_locating1(DataFrame& df);
void writeFTPFile(int type,bool flag,uint64_t fromTime,uint64_t endTime,bool isAutoUp=false);
void reCheckMsEvt(uint64_t fromsampTime,uint64_t endsampTime);
// void genMsHistoryLocs();
#endif
```
```cpp
//ms_locator.cpp
#include <filesystem>
#include <regex>
#include <string>

#include "Config.hpp"
#include "MSDataFrame.hpp"
#include "common.hpp"
#include "ms_locator.hpp"
#include "web/Data.hpp"
#include "web/commands.hpp"

#include <curl/curl.h>

using std::string;
namespace fs = std::filesystem;
// 剔除偏差过大的通道
void filterAbnormChn(vector<MSLCal::STELCalChn> &chnns, float thrld = 5) {
  int count = 0, sum = 0;
  for (int i = 0; i < chnns.size(); i++) {
    if (chnns[i].tp > -10000) {
      count++;
      sum += chnns[i].tp;
    }
  }
  if (count == 0)
    return;
  auto avg = sum / count;
  for (int i = 0; i < chnns.size(); i++) {
    if (chnns[i].tp > -10000 && abs((chnns[i].tp - avg) / avg) > thrld) {
      chnns[i].tp = -10000;
      filterAbnormChn(chnns, thrld);
    }
  }
  return;
}

void tagInvalidEvt(int64_t sampTime) {
  auto conn = hzi::config.pConnPool->getConnection();
  string sql("update e_data_frm_info set ms_validity=0 where class_id=2 "
             "and "
             "round(unix_timestamp(samp_time), 3) = ");
  sql += std::to_string(sampTime / 1000.0);
  conn.execute(sql.c_str());
  sql = "update e_msevt_rslts set validity=0 where samp_time=";
  sql += std::to_string(sampTime);
  conn.execute(sql.c_str());
  return;
}

// 剔除方差过大的通道
void tagEventByPArrVari(vector<MSLCal::STELCalChn> &chnns, int64_t sampTime,
                        float thrld = 1500) {
  if (chnns.size() == 0) {
    tagInvalidEvt(sampTime);
    return;
  }
  filterAbnormChn(chnns);
  int count = 0, sum = 0, vari = 0;
  for (int i = 0; i < chnns.size(); i++) {
    if (chnns[i].tp > -10000) {
      count++;
      sum += chnns[i].tp;
    }
  }
  if (count <= 3) {
    tagInvalidEvt(sampTime);
    return;
  }
  auto avg = sum / count;
  for (int i = 0; i < chnns.size(); i++) {
    if (chnns[i].tp > -10000) {
      vari += (chnns[i].tp - avg) * (chnns[i].tp - avg);
    }
  }
  // auto sqVari = sqrt(vari / count);
  auto sqVari = vari / count;
  if (sqVari > thrld) {
    tagInvalidEvt(sampTime);
  }
  return;
}
int getChnNO(uint8_t devAddr, string chnlabel) {
  auto devtmp = devAddr;
  std::vector<bool> isGetDataList;
  for (int i = 0; i < 8; i++) // 最多8个基站
  {
    isGetDataList.push_back(false);
  }
  for (int i = 8; i > 0; i--) {
    int m = safePow(2, i - 1);
    int index = devtmp / m;
    if (index > 0) {
      isGetDataList[i - 1] = true;
      devtmp = devtmp % m;
    }
  }
  auto retNum = 0;
  for (int i = 0; i < isGetDataList.size(); i++) {
    bool isGetData = isGetDataList[i];
    if (isGetData) {
      auto chnNum = hzi::config.devicesMap[i + 1].dataChns[2];
      if (chnlabel.substr(0, 2) == "S" + std::to_string(i + 1)) {
        auto chnnostr = chnlabel.substr(chnlabel.length() - 2);
        auto chnno = atoi(chnnostr.c_str());
        return retNum + chnno - 1;
      }
      retNum += chnNum;
    }
  }

  return retNum;
}
void setChnns(vector<MSLCal::STELCalChn> &chnns, uint8_t devAddr) {
  auto devtmp = devAddr;
  std::vector<bool> isGetDataList;
  for (int i = 0; i < 8; i++) // 最多8个基站
  {
    isGetDataList.push_back(false);
  }
  for (int i = 8; i > 0; i--) {
    int m = safePow(2, i - 1);
    int index = devtmp / m;
    if (index > 0) {
      isGetDataList[i - 1] = true;
      devtmp = devtmp % m;
    }
  }

  for (int i = 0; i < isGetDataList.size(); i++) {
    bool isGetData = isGetDataList[i];
    if (isGetData) {
      auto chnNum = hzi::config.devicesMap[i + 1].dataChns[2];
      auto index = 0;
      while (index < chnNum) {
        for (auto &msItr : hzi::msChannelsConfigsMap) {
          string chnlabel = msItr.first;
          auto chnnostr = chnlabel.substr(chnlabel.length() - 2);
          auto chnno = atoi(chnnostr.c_str());

          if (chnlabel.substr(0, 2) == "S" + std::to_string(i + 1) &&
              chnno == index + 1) {
            MSLCal::STELCalChn chn;
            chn.x = msItr.second.locX;
            chn.y = msItr.second.locY;
            chn.z = msItr.second.locZ;
            chn.enb = hzi::msEvtCnf.msThrldsMap[chnlabel].second;
            chn.chnlabel = chnlabel;
            if (msItr.second.stateId != 0) {
              chn.tp = -20000;
              chn.ts = -20000;
            } else if (msItr.second.stateId == 0 && (!chn.enb)) {
              chn.tp = -10000;
              chn.ts = -10000;
            }
            chnns.push_back(chn); // 如何保证数据库数据和实际通道一致性？
            index++;
          }
        }
      }
    }
  }
}
tl::expected<int, std::string> ms_locating1(DataFrame &df) {
  auto conn = hzi::config.pConnPool->getConnection();
  auto dbExp = cmd::queryDb(
      conn, "select loc_algo from e_ms_locating_params where id=1");
  if (!dbExp) {
    return tl::make_unexpected(string("ms_locating1 error:") + dbExp.error());
  }

  zdb::ResultSet &rslt = dbExp.value();
  auto locAlgo = rslt.getInt("loc_algo");
  if (locAlgo == 1) { // 粒子群
    ms_locating(df.sampTime(), df.devMask(), df.upData, df.upHead,
                df.channels());
    return 0;
  } else {
    MSDataFrame msdf(df);
    if (locAlgo == 0) {
      // 最小方差定位
      return msdf.locating();
    } else if (locAlgo == 2) {
      return msdf.locateByEnergy();
    } else if (locAlgo == 3) {
      return msdf.locateByRegression();
    } else {
      return tl::make_unexpected("不支持的微震算法");
    }
  }
}
bool getMeanValue_miningLocX(uint64_t sampTime, double &miningLocX) {
  bool ret = false;
  auto conn = hzi::config.pConnPool->getConnection();
  std::vector<double> miningLocVex;

  for (int i = 0; i < 2; i++) {
    auto rslt =
        conn.executeQuery("SELECT * FROM `e_ms_locInfo` WHERE location = ?  "
                          "and tmstamp < ? ORDER BY tmstamp DESC LIMIT 1",
                          i, (double)sampTime);
    if (rslt.next()) {
      auto mining_loc = rslt.getDouble("mining_loc");
      auto dir = rslt.getInt("mining_dir"); //回采方向(0:沿x向，1:逆x向)
      auto timestamp = rslt.getDouble("tmstamp");
      auto dayStep = rslt.getDouble("day_step");

      int days = floor((sampTime / 1000.0 - timestamp / 1000.0) / 24 / 3600);

      auto locx =
          dir == 0 ? mining_loc + days * dayStep : mining_loc - days * dayStep;
      miningLocVex.push_back(locx);
    }
  }
  if (miningLocVex.size() > 0) {
    ret = true;
    double sum = 0.0;
    for (int i = 0; i < miningLocVex.size(); i++) {
      sum += miningLocVex[i];
    }
    miningLocX = sum / miningLocVex.size();
  }
  return ret;
}
size_t read_callback(void *ptr, size_t size, size_t nmemb, void *stream) {
  std::string *data = static_cast<std::string *>(stream);
  size_t buffer_size = size * nmemb;

  if (data->size() < buffer_size) {
    buffer_size = data->size();
  }

  memcpy(ptr, data->c_str(), buffer_size);
  data->erase(0, buffer_size);

  return buffer_size;
}

//读取原点的大地坐标及变换矩阵
int getMatrix_loc(vector<double> &geodeticOrigin,
                  vector<vector<double>> &rotationMatrix) {
  int retCode = 0;
  auto conn = hzi::config.pConnPool->getConnection();
  auto rslt0 = conn.executeQuery(
      "SELECT * FROM `e_model_matrix` WHERE item = \"origin\" or item "
      "=\"vector_x\" or item = \"vector_y\" or item = \"vector_z\"");
  while (rslt0.next()) {

    string item = rslt0.getString("item");
    auto x = rslt0.getDouble("x");
    auto y = rslt0.getDouble("y");
    auto z = rslt0.getDouble("z");
    if (item.compare("origin") == 0) {
      retCode += 1;
      geodeticOrigin[0] = x;
      geodeticOrigin[1] = y;
      geodeticOrigin[2] = z;
    }
    if (item == "vector_x") {
      retCode += 2;
      vector<double> vector_x(3);
      vector_x[0] = x;
      vector_x[1] = y;
      vector_x[2] = z;
      rotationMatrix[0] = vector_x;
    }
    if (item == "vector_y") {
      retCode += 4;
      vector<double> vector_y(3);
      vector_y[0] = x;
      vector_y[1] = y;
      vector_y[2] = z;
      rotationMatrix[1] = vector_y;
    }
    if (item == "vector_z") {
      retCode += 8;
      vector<double> vector_z(3);
      vector_z[0] = x;
      vector_z[1] = y;
      vector_z[2] = z;
      rotationMatrix[2] = vector_z;
    }
  }
  return retCode;
}
/***微震数据对接 写FTP文件
 * type 0 写基础信息，1 - 写微震数据
 * flag true 上传实际数据 false 上传空数据 只针对type =1时
 */
void writeFTPFile(int type,bool flag,uint64_t fromTime,uint64_t endTime, bool isAutoUp) {
  cout<<" writeFTPFile "<<type<<endl;
  auto conn = hzi::config.pConnPool->getConnection();
  string dataFile = "";
  string fileName = "";
  string headFile = "";
 // cout<<" -- 0 -- "<<type<<endl;
  string date_time =
      timeStr(std::chrono::system_clock::now(),"%Y-%m-%d %H:%M:%S");       // yyyy-MM-dd hh:mm:ss
 // cout<<"date_time = "<<date_time<<endl;
  string fileName_date = convertDateFormat(date_time); // yyyyMMddhhmmss
 // cout<<" -- 1 --"<<fileName_date<<endl;
  bool is_data = false;
  if (type == 0) {

    auto rslt = conn.executeQuery("SELECT * FROM `e_acqui_points`");
    if (rslt.next()) {
      //测点编码 = 煤矿编码 + 系统编码 + 传感器数值类型码 + 传感器类型码 +
      //原系统测点编码
      string code = rslt.getString("code");
      string mine_code = rslt.getString("mine_code");

      string sys_code = rslt.getString("sys_code");
      string data_type = rslt.getString("data_type");
      string sensor_type = rslt.getString("sensor_type");
      string original_code = rslt.getString("original_code");

      string survey_area = rslt.getString("survey_area");
      auto chns = rslt.getInt("chns");
      auto cy_length = rslt.getInt("cy_length");
      auto cy_freq = rslt.getInt("cy_freq");
      string sensor_dir = rslt.getString("sensor_dir");

      string method = rslt.getString("method_install");
      auto sensitivity = rslt.getDouble("sensitivity");
      //+传感器类型
      string location = rslt.getString("location_instal");

      auto coord_x = rslt.getDouble("coord_x");
      auto coord_y = rslt.getDouble("coord_y");
      auto coord_z = rslt.getDouble("coord_z");
      string setup_date = rslt.getString("setup_date");

      string mine_name = rslt.getString("mine_name");

      fileName =
          mine_code + "_WZCDDY_" + fileName_date + ".txt"; // yyyyMMddhhmmss
    //  cout<<" -- 2 --"<<fileName<<endl;
      headFile += mine_code + ";";
      headFile += mine_name + ";";
      headFile += date_time + "~"; // yyyy-MM-dd hh:mm:ss

      dataFile += headFile;
      dataFile += "\n";
      dataFile += code + ";";
      dataFile += survey_area + ";";
      dataFile += std::to_string(chns) + ";";
      dataFile += std::to_string(cy_length) + ";";
      dataFile += std::to_string(cy_freq) + ";";
      dataFile += sensor_dir + ";";
      dataFile += method + ";";
      dataFile += formatDouble(sensitivity, 2) + ";";
      dataFile += sensor_type + ";";
      dataFile += location + ";";
      dataFile += formatDouble(coord_x, 2) + ";";
      dataFile += formatDouble(coord_y, 2) + ";";
      dataFile += formatDouble(coord_z, 2) + ";";
      dataFile += setup_date + "~||";
    //  cout << " -- 3 --" << endl;
      is_data = true;
    }
  }
  else 
  {
    auto rslt = conn.executeQuery("SELECT * FROM `e_acqui_points`");
    string mine_code = "";
    string sys_code = "";
    if (rslt.next()) {
      //测点编码 = 煤矿编码 + 系统编码 + 传感器数值类型码 + 传感器类型码 +
      //原系统测点编码
      mine_code = rslt.getString("mine_code");
      sys_code = rslt.getString("sys_code");
      string mine_name = rslt.getString("mine_name");
      fileName = mine_code + "_WZCDSS_" + fileName_date + ".txt";

      headFile += mine_code + ";";
      headFile += mine_name + ";";
      headFile += date_time + "~";

      dataFile += headFile;
      dataFile += "\n";
    }
    if(flag)
    {
      cout << " headFile = " << headFile << endl;
      //查询上次上传数据时间
      // string sqlStr1 = "SELECT FROM_UNIXTIME(FLOOR(data_time / 1000)) AS ts FROM "
      //                 "`e_last_update` WHERE mine_code = \"" +
      //                 mine_code + "\"";

      // auto rslt_date = conn.executeQuery(sqlStr1.c_str());
      // string data_time = "";
      // cout << " sqlStr1 = " << sqlStr1 << endl;
      // if (rslt_date.next()) {
      //   data_time = rslt_date.getString("ts");
      // }
      // if (data_time.empty()) {
      //   data_time =
      //       timeStr(std::chrono::system_clock::now() - std::chrono::hours(24),"%Y-%m-%d %H:%M:%S");
      // }
      // cout<<" data_time = "<<data_time<<endl;
      //取出大地坐标及转换关系
      vector<double> geodeticOrigin(3); // 大地坐标原点

      vector<vector<double>> rotationMatrix(3, vector<double>(3)); // 变换矩阵
      int ret = getMatrix_loc(geodeticOrigin, rotationMatrix);
      if (ret != 15) {
        //坐标转换表不对
        cout << " 坐标转换表不对 !" << endl;
      }
      string wf_name = "";
      auto rslt_loc = conn.executeQuery("SELECT wf_name FROM `e_info`");
      if (rslt_loc.next()) {
        wf_name = rslt_loc.getString("wf_name");
      }

      int lsCode = 0; //流水号
      string chnsStr = "01&02&03&04";
      // string sqlStr2 = "SELECT *,FROM_UNIXTIME(FLOOR(samp_time / 1000)) AS "
      //                  "data_time FROM `e_msevt_rslts` WHERE samp_time >= "
      //                 + std::to_string(fromTime) + " and  samp_time < "
      //                 + std::to_string(endTime) + " and validity = 1 and energy != 0 " ;
      string sqlStr2;
      if(isAutoUp)
      {
        sqlStr2 = "SELECT *,FROM_UNIXTIME(FLOOR(samp_time / 1000)) AS "
                       "data_time FROM `e_msevt_rslts` WHERE samp_time >= "
                      + std::to_string(fromTime) + " and  samp_time < "
                      + std::to_string(endTime) + " and validity = 1 and energy < 1000.0 ";
      }
      else
      {
        sqlStr2 = "SELECT *,FROM_UNIXTIME(FLOOR(samp_time / 1000)) AS "
                       "data_time FROM `e_msevt_rslts` WHERE samp_time >= "
                      + std::to_string(fromTime) + " and  samp_time < "
                      + std::to_string(endTime) + " and validity = 1 and energy != 0 ";
      }
      

      // string sqlStr2 = "SELECT *, FROM_UNIXTIME(FLOOR(samp_time / 1000)) AS "
      //                 "data_time  FROM `e_msevt_rslts`"
      //                 " WHERE FROM_UNIXTIME(FLOOR(samp_time / 1000)) > \"" +
      //                 data_time + "\"  and validity =1";
      cout << " sqlStr2 : " << sqlStr2 << endl;
      auto rslt1 = conn.executeQuery(sqlStr2.c_str());
      while (rslt1.next()) 
      {
        lsCode++;
        string ms_data_time =
            rslt1.getString("data_time"); // yyyy-MM-dd hh：mm：ss
        string ms_data_time0 = convertDateFormat(ms_data_time); // yyyyMMddhhmmss
        string ms_code = mine_code + sys_code + ms_data_time0 +
                        std::to_string(lsCode); //事件编码
        auto loc_x = rslt1.getDouble("loc_x");
        auto loc_y = rslt1.getDouble("loc_y");
        auto loc_z = rslt1.getDouble("loc_z");
        auto energy = rslt1.getDouble("energy");
        auto magnitude = rslt1.getDouble("magnitude");
        auto mainfreq = rslt1.getDouble("mainfreq");
        auto max_amp = rslt1.getDouble("max_amp");
        auto ave_amp = rslt1.getDouble("ave_amp");
        vector<double> sysPoint(3);
        sysPoint[0] = loc_x;
        sysPoint[1] = loc_y;
        sysPoint[2] = loc_z;
        //  cout<<"loc_x =  "<<loc_x<<" , lsCode = "<<lsCode<<endl;

        string ms_location = rslt1.getString("ms_location");
        ms_location = ms_location == "null" ? wf_name : ms_location;

        string msg = rslt1.getString("msg");
        msg = msg == "null" ? "" : msg;

        
        vector<double> geodeticLoc(3); // 系统坐标转大地坐标
        geodeticLoc = getGeodeticPoint(sysPoint, rotationMatrix, geodeticOrigin);

        //组合数据内容
        if (lsCode > 1)
          dataFile += "\n";
        dataFile += ms_code + ";";
        dataFile += chnsStr + ";";
        dataFile += formatDouble(geodeticLoc[0]) + ";";
        dataFile += formatDouble(geodeticLoc[1]) + ";";
        dataFile += formatDouble(geodeticLoc[2]) + ";";
        dataFile += formatDouble(energy) + ";";
        dataFile += formatDouble(magnitude) + ";";
        dataFile += ms_location + ";";
        dataFile += formatDouble(max_amp) + ";";
        dataFile += formatDouble(ave_amp) + ";";
        dataFile += formatDouble(mainfreq) + ";";
        dataFile += ms_data_time + ";";
        dataFile += msg + "~";
        is_data = true;
      }
      dataFile += "||";
      // auto tmp = nowMS();
      // cout << " date_time = " << date_time << endl;
      // conn.execute("insert into e_last_update "
      //             "(mine_code,data_time)"
      //             "values(?,?) on duplicate key update "
      //             "data_time=values(data_time)",
      //             mine_code, double(tmp));

    }
    else
    {
      is_data = true;
      //dataFile += "||";
      dataFile = "";
      // 从本地文件加载 dataFile
        std::ifstream inFile("/opt/hzisemt/lastdata.txt");
        if (!inFile) {
            std::cerr << "Failed to open lastdata.txt for reading." << std::endl;
            return;
        }
        std::string line;
        while (std::getline(inFile, line)) {
            dataFile += line + "\n";
        }
        inFile.close();
        std::cout << "dataFile loaded from lastdata.txt" << std::endl;
    }
    
  }

  cout<<"is_data="<<(is_data?"true":"false")<<endl;

  if (is_data) {
    if (type == 1 && flag) {
        // 存储 dataFile 到本地文件 (覆盖方式)
        std::ofstream outFile("/opt/hzisemt/lastdata.txt", std::ios::trunc);
        if (!outFile) {
            std::cerr << "Failed to open lastdata.txt for writing." << std::endl;
            return;
        }
        // 假设 dataFile 已经填充了数据
        outFile << dataFile;
        outFile.close();
        std::cout << "dataFile saved to lastdata.txt" << std::endl;
    }
    CURL *curl;
    CURLcode res;

    std::string ftp_url = hzi::config.ftpUrl + fileName;
    std::string username = hzi::config.ftpUserName;
    std::string password = hzi::config.ftpPassWord;

    cout<<"ftp_url :"<<ftp_url<<" , fileName = "<<fileName<<" , dataFile = "<<dataFile<<endl;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if (curl) {
      curl_easy_setopt(curl, CURLOPT_URL, ftp_url.c_str());

      // Specify username and password
      curl_easy_setopt(curl, CURLOPT_USERNAME, username.c_str());
      curl_easy_setopt(curl, CURLOPT_PASSWORD, password.c_str());

      // Enable uploading
      curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);

      // Specify the read callback function
      curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);
      curl_easy_setopt(curl, CURLOPT_READDATA, &dataFile);

      // Perform the request, res will get the return code
      res = curl_easy_perform(curl);

      // Check for errors
      if (res != CURLE_OK) {
        //  fprintf(stderr, "curl_easy_perform() failed: %s\n",
        //  curl_easy_strerror(res));
        std::cout << "curl_easy_perform() failed: %s\n";
      } else {
        std::cout << "File uploaded successfully!" << std::endl;
      }

      // Cleanup
      curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
  }
}
void reCheckMsEvt(uint64_t fromsampTime, uint64_t endsampTime) {
  if (endsampTime <= fromsampTime) {
    cout << "DataFrame::merge error: negative from point" << endl;
    return;
  }

  string logstr = "reCheckMsEvt 开始时间: ";
  logstr += std::to_string(fromsampTime);
  logstr += " 结束时间： ";
  logstr += std::to_string(endsampTime);

  debugLog(logstr);
  auto pnts0 = 0;
  auto chns0 = 0;

  std::vector<string> pathVector;
  auto conn = hzi::config.pConnPool->getConnection();

  double fromtime = double(fromsampTime / 1000);
  double endtime = double(endsampTime / 1000);

  auto rslt = conn.executeQuery(
      "SELECT samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
      " where class_id= 3   AND samp_time >= FROM_UNIXTIME(?) "
      "  AND samp_time <= FROM_UNIXTIME(?)   ORDER BY "
      "samp_time ASC",
      fromtime, endtime);
  while (rslt.next()) {
    pnts0 = rslt.getInt("ch_pnts");
    chns0 = rslt.getInt("channels");
    auto pathstr = rslt.getString("frm_loc");

    pathVector.push_back(pathstr);
  }

  if (pnts0 == 0 || chns0 == 0)
    return;

  string path = Config::dataRoot + "/";
  if (hzi::config.verbose)
    cout << " pathVector.size() = " << pathVector.size() << endl;
  for (int i = 0; i < pathVector.size(); i++) {
    auto filePath = path + pathVector[i];
    if (!fs::exists(filePath))
      return;
    std::ifstream ifs(filePath);
    auto fileSize = fs::file_size(filePath);
    DataFrame fileDF(chns0, pnts0);
    ifs.read(fileDF.upHead.get(), 32);
    // ifs.seekg(0);
    ifs.read(fileDF.upData.get(), fileSize - 32);
    ifs.close();
    reCheckMSEvt_bj(std::move(fileDF));
    // createEngDensity(fileDF);
  }
}

void ms_locating(int64_t sampTime, uint8_t devAddr,
                 std::unique_ptr<char[]> &pData, std::unique_ptr<char[]> &head,
                 uint16_t channels) {
  try {
    vector<MSLCal::STELCalChn> chnns;
    MSLCal::CSpace cSpace;
    MSLCal::STELResult msRslt;
    MSLCal::PSOParm msPSOParm; // 传入参数
    MSLCal::EngParm engParm;

    msPSOParm.PatNum = 100;
    msPSOParm.PatDim = 3;
    msPSOParm.TTFitWay = 0;

    engParm.k_rate = 0.025f;
    engParm.p_rate = 1 * 10000;
    engParm.s_rate = 1 * 10000;
    engParm.a_rate = 0.001f;
    engParm.c_rate = 1;
    engParm.calWay = 0;
    string logstr = " ms_locating 设备地址:" + std::to_string(devAddr);
    debugErr(logstr);
    setChnns(chnns, devAddr);

    string ms_locationStr = "";
    auto conn = hzi::config.pConnPool->getConnection();

    // auto rslt = conn.executeQuery("select  wf_name from e_info");
    // if(rslt.next()){
    //     ms_locationStr = rslt.getString("wf_name");//工作面名称
    // }

    auto limitsRslt = conn.executeQuery(
        "select  wf_name,"
        "mining_locx,evt_forwardx,evt_backwardx,mining_dir,evt_miny,evt_"
        "maxy,evt_minz,evt_maxz,last_date,day_step from "
        "e_daily_sheet_config");
    if (limitsRslt.next()) {
      auto dir = limitsRslt.getInt("mining_dir");
      auto currLocX = limitsRslt.getDouble("mining_locx");
      auto fX = limitsRslt.getDouble("evt_forwardx");
      auto bX = limitsRslt.getDouble("evt_backwardx");

      // 重算回采位置
      auto lastDate = limitsRslt.getString("last_date");
      auto dayStep = limitsRslt.getDouble("day_step");

      ms_locationStr = limitsRslt.getString("wf_name"); //工作面名称

      string s{lastDate};
      s += "T00:00:00.00Z";
      std::tm t{};
      std::istringstream ss(s);
      ss >> std::get_time(&t, "%Y-%m-%dT%H:%M:%S");
      if (ss.fail()) {
        throw std::runtime_error{"failed to parse time string"};
      }
      std::time_t timestamp = mktime(&t);
      int days = floor((sampTime / 1000.0 - timestamp) / 24 / 3600);

      currLocX += days * dayStep;
      getMeanValue_miningLocX(sampTime, currLocX);

      auto minX = dir == 1 ? currLocX - bX : currLocX - fX;
      auto maxX = dir == 1 ? currLocX + fX : currLocX + bX;
      cSpace.m_fMaxX = maxX;
      cSpace.m_fMinX = minX;
      cSpace.m_fMaxY = limitsRslt.getDouble("evt_maxy");
      cSpace.m_fMinY = limitsRslt.getDouble("evt_miny");
      cSpace.m_fMaxZ = limitsRslt.getDouble("evt_maxz");
      cSpace.m_fMinZ = limitsRslt.getDouble("evt_minz");
    }
    // cSpace.m_fMaxX = hzi::viewSpace.xMax;
    // cSpace.m_fMinX = hzi::viewSpace.xMin;
    // cSpace.m_fMaxY = hzi::viewSpace.yMax;
    // cSpace.m_fMinY = hzi::viewSpace.yMin;
    // cSpace.m_fMaxZ = hzi::viewSpace.zMax;
    // cSpace.m_fMinZ = hzi::viewSpace.zMin;
    hzi::getSpeed();
    float vp = hzi::viewSpace.vp;
    float vs = hzi::viewSpace.vs;
    int speed_even = hzi::viewSpace.speed_even;

    auto rsltlocatingParm =
        conn.executeQuery("select * from e_ms_locating_params where id=1");
    if (rsltlocatingParm.next()) {
      msRslt.eng_mag_no =
          rsltlocatingParm.getInt("eng_mag_no"); //能量震级转换公式编号(1或2)
    }

    auto rsltPSO = conn.executeQuery("SELECT * FROM e_msevt_psoparm");
    if (rsltPSO.next()) {
      msPSOParm.PatNum = rsltPSO.getInt("patNum");
      msPSOParm.PatDim = rsltPSO.getInt("patDim");
      msPSOParm.TTFitWay = rsltPSO.getInt("ttFitWay");
    }

    auto rsltengParm = conn.executeQuery("SELECT * FROM e_msevt_engparm");
    if (rsltengParm.next()) {
      engParm.k_rate = rsltengParm.getDouble("k_rate");
      engParm.p_rate = rsltengParm.getDouble("p_rate");
      engParm.s_rate = rsltengParm.getDouble("s_rate");
      engParm.a_rate = rsltengParm.getDouble("a_rate");
      engParm.c_rate = rsltengParm.getDouble("c_rate");
      engParm.calWay = rsltengParm.getInt("calWay");
    }
    auto ret =
        CalEventProperty(pData, head, &chnns[0], channels, &cSpace, vp, vs,
                         speed_even, &hzi::viewSpace.vtispeed_vector[0],
                         hzi::viewSpace.vti_layers, hzi::viewSpace.enablescan,
                         hzi::viewSpace.offset, msRslt, &msPSOParm, &engParm);

    const time_t tt = sampTime / 1000;
    if (ret == MSLCal::MSL_ES_INVALID) {
      string sql("update e_data_frm_info set ms_validity=0 where class_id=2 "
                 "and "
                 "round(unix_timestamp(samp_time), 3) = ");
      sql += std::to_string(sampTime / 1000.0);

      sql += "  and dev_id =";
      sql += std::to_string(devAddr);
      // logInfo(sql);
      conn.execute(sql.c_str());
      return;
    }
    PreparedStatement prp = conn.prepareStatement(
        "INSERT INTO  e_msevt_1st_arrs "
        "(dev_id,samp_time,chn_no,p_time,s_time,chn_label) "
        "values(?,?,?,?,?,?) on duplicate key update "
        "p_time=values(p_time),s_time=values(s_time)");
    conn.beginTransaction();

    for (uint8_t i = 0; i < chnns.size(); i++) {
      auto chnno = getChnNO(devAddr, chnns[i].chnlabel);
      prp.bind(1, (int)devAddr);
      prp.bind(2, (double)sampTime);
      prp.bind(3, chnno);
      prp.bind(4, chnns[i].tp);
      prp.bind(5, chnns[i].ts);
      prp.bind(6, chnns[i].chnlabel);
      prp.execute();
    }
    conn.commit();
    conn.execute(
        "insert into e_msevt_rslts "
        "(dev_id,samp_time,loc_x,loc_y,loc_z,energy,magnitude,evt_time,"
        "speed_p,mainfreq,max_amp,ave_amp,ms_location,msg)values(?,?,?,"
        "?"
        ",?,?"
        ",?,?,?,?,?,?,?,?)",
        (int)devAddr, (double)sampTime, msRslt.fx, msRslt.fy, msRslt.fz,
        msRslt.eng, msRslt.mag, msRslt.ft, vp, msRslt.mainfreq, msRslt.maxAmp,
        msRslt.aveAmp, ms_locationStr, "null");

    tagEventByPArrVari(chnns, sampTime);
  } catch (sql_exception &e) {
    logErr(e.what());
  } catch (std::exception &e) {
    throw(string("ERROR in ms_locator.cpp: ") + e.what());
  }
}

/*
void genMsHistoryLocs() {
    // std::regex reg(".+\\/2\\/\\d{13}$");
    std::regex reg(".+\\/2022\\/\\d+\\/\\d+\\/2\\/\\d{13}$");
    // std::regex reg(".+\\/2021/12/25/2/1640364905237$");
    //  fs::recursive_directory_iterator("/var/frame_data2/2021/12/30/0"))
    //  {
    // std::vector<std::thread> threads;
    for (const auto& itr :
         fs::recursive_directory_iterator(hzi::config.dataRoot)) {
        //  fs::recursive_directory_iterator("/var/frame_data2/2021/12/30/2")) {
        fs::path path(itr);
        if (itr.is_regular_file() && std::regex_match(path.string(), reg)) {
            cout << fs::path(itr).string() << " handling..." << std::flush;
            auto pPath = path.parent_path();
            auto pHead = std::make_unique<char[]>(32);
            auto pData = std::make_unique<char[]>(hzi::config.recvBufsize);

            std::ifstream ifs(path.string(), std::ios::binary);
            ifs.read(pHead.get(), 32);
            ifs.seekg(0);
            ifs.read(pData.get() + 16, hzi::config.recvBufsize - 16);
            ifs.close();

            int64_t samptime = (int64_t) * (double*)(pHead.get());
            auto channels = *(uint16_t*)(pHead.get() + 10);

            ms_locating(samptime, std::move(pData), std::move(pHead), channels);
            cout << "...ok\n";
        }
        if (itr.is_directory()) {
            cout << fs::path(itr).string() << " handled\n";
        }
    }
}
*/
```

## recvData()

| 初始化变量                                    | 数据来源                                                | 说明                                                         |
| --------------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| **recvData()**                                |                                                         | 监测应答帧处理                                               |
| p_samp_intvls                                 |                                                         | (采样间隔id，不同时长的采样间隔时间ms)                       |
| p_time_wins                                   |                                                         | (时窗id，不同时长的时窗时间ms)                               |
| e_e_samp_config                               |                                                         | （电法采样参数配置表）获取电法采样间隔。获取激电电压模式。   |
| e_ms_samp_config                              |                                                         | （微震采样参数配置表）获取微震采样间隔。获取微震背景极值检测时窗。 |
| e_tempr_samp_config                           |                                                         | （温度采样参数配置表）获取温度采样间隔。                     |
| e_coupl_samp_config                           |                                                         | （耦合采样参数配置表）耦合采样间隔。                         |
| hzi::config.devicesMap[devAddr].sampling      | true                                                    | 发送该原始帧的【基站是否正在采集(全局变量)】置为true         |
| hzi::config.devicesMap[devAddr].lastSampTime  | df.sampTime()                                           | 发送该原始帧的【基站最后采集时间(全局变量)】                 |
| hzi::serverStatus.lastSampTimes[df.classId()] | df.sampTime()                                           | 该原始帧代表的【该类型数据帧最后采集时间(全局变量)】         |
| e_data_frm_info                               | DataFrame::saveIntoDataFrmInfo()                        | 数据帧信息（路径）入库表                                     |
| e_data_digest                                 | DataFrame::saveIntoDataDigest()                         |                                                              |
|                                               |                                                         |                                                              |
| **getEngDenityParm()**                        |                                                         |                                                              |
| engParmList                                   | e_tunnel_pickDateTime                                   | 参数：时窗，能量密度有效判定参数等。**页面上【数据提取】处设置。** |
|                                               |                                                         |                                                              |
| **readEngDenity()**                           |                                                         |                                                              |
| e_tunnel_RunningDataInfo                      | 若能量密度文件内1个时窗满足条件，入库该时窗的起止时间。 | 铁建用的。                                                   |
|                                               |                                                         |                                                              |
|                                               |                                                         |                                                              |
| **insertTunnelDataInfo()**                    |                                                         |                                                              |
| e_tunnel_RunningDataInfo                      |                                                         |                                                              |
|                                               |                                                         |                                                              |
| **ms_locating()**                             |                                                         |                                                              |
|                                               | e_daily_sheet_config                                    |                                                              |
|                                               | e_ms_locating_params                                    |                                                              |
|                                               | e_msevt_psoparm                                         |                                                              |
|                                               | e_msevt_engparm                                         |                                                              |
| e_data_frm_info                               |                                                         |                                                              |
| e_msevt_1st_arrs                              |                                                         |                                                              |
| e_msevt_rslts                                 |                                                         |                                                              |

> [!NOTE]
>
> * DataFrame::make()——根据原始帧**构造数据帧**
>
>   > * StartMonitor::getIntvl()——根据原始帧类型获取采样间隔
>   >
>   >   > * StartMonitor::setIntvlsFromDb()
>   >   >
>   >   >   > * queryPntIntvl()——根据原始帧类型id查表获取采样间隔
>
> * is_saveFile()——根据【数据存储策略】判定**是否保存数据帧**
>
> * handleData()——数据帧入库，保存文件。**数据帧按照`df.classId()`分类处理**。
>
>   > * DataFrame::save()——**保存数据帧**
>   >
>   >   > * DataFrame::saveIntoDataFrmInfo()——根据配置文件字段将数据帧信息入库表`e_data_frm_info`
>   >   >
>   >   > * DataFrame::saveIntoDataDigest()——保存摘要（全时微震，温度，伽马，激电数据帧不保存摘要）信息入库表`e_data_digest`
>   >   >
>   >   >   > * DataFrame::chnLabels()——若是拼接数据帧，获取该df中所有基站的（该数据帧类型的）通道label拼接vector
>   >   >   > * DataFrame::isFullTimeFrame()
>   >   >   > * struct Digest——通道的数据的摘要信息（最小值，最小值索引，最大值，最大值索引，，绝对值最大值，绝对值最大值索引，所有点均值）
>   >   >   > * std::map<string, Digest> digests——label相同的通道的摘要信息（可能考虑不同基站有相同label的通道？）
>   >   >
>   >   > * DataFrame::saveFrmToFile()——保存到文件
>   >
>   > * **createEngDensity()**——写死只`classId==3`的数据帧中数据写入【平均能量文件】的内存映射`densityMMaps`
>   >
>   >   > * **setupDensityFile()**——创建摘要文件，**通过mio库映射到变量`densityMMaps`**。
>   >   >
>   >   > * **通过向`densityMMaps`写数据，从而写到能量密度文件digest_256.dat**。
>   >   >
>   >   >   > ***密度文件/能量密度文件格式：***
>   >   >   >
>   >   >   > * 1h分为`div=safePow(2, hzi::config.maxDensity)`个单位时间。
>   >   >   >
>   >   >   > * 根据数据帧采样时间（`DataFrame::sampTime()`）和采样间隔，计算每个点的精确采集时间time，转化为在一天内属于的单位时间的索引du。
>   >   >   >
>   >   >   > * pixelWidth是24小时总共的单位时间个数。
>   >   >   >
>   >   >   > * 写文件：3部分，先写极值，再写数据点数，最后写数据累加和。
>   >   >   >
>   >   >   >   > * 在`densityMMaps`中起始地址分别为：0，channels * pixelWidth * 4，channels * pixelWidth * 4 * 2。
>   >   >   >   >
>   >   >   >   > * 每个部分：各个通道都占24h的pixelWidth个单位时间。
>   >   >   >   >
>   >   >   >   > * 每个单位时间，极值数据占4B，数据点数占4B，数据累加和占8B。
>   >   >   >   >
>   >   >   >   > | 起始地址                      | -              | Δt1  | ...  | ΔtpixelWidth |
>   >   >   >   > | ----------------------------- | -------------- | ---- | ---- | ------------ |
>   >   >   >   > | 0                             | **极值**       |      |      |              |
>   >   >   >   > |                               | chn=0          | 4B   |      | 4B           |
>   >   >   >   > |                               | chn=1          |      |      |              |
>   >   >   >   > |                               | ...            |      |      |              |
>   >   >   >   > |                               | chn=channels   |      |      |              |
>   >   >   >   > | channels * pixelWidth * 4     | **数据点数**   |      |      |              |
>   >   >   >   > |                               | chn=0          | 4B   |      | 4B           |
>   >   >   >   > |                               | chn=1          |      |      |              |
>   >   >   >   > |                               | ...            |      |      |              |
>   >   >   >   > |                               | chn=channels   |      |      |              |
>   >   >   >   > | channels * pixelWidth * 4 * 2 | **数据累加和** |      |      |              |
>   >   >   >   > |                               | chn=0          | 8B   |      | 8B           |
>   >   >   >   > |                               | chn=1          |      |      |              |
>   >   >   >   > |                               | ...            |      |      |              |
>   >   >   >   > |                               | chn=channels   |      |      |              |
>   >   >   >
>   >
>   > * handleTimeStamp()——从df.sampTime()给代表当前分段的起止时间的全局变量`hzi::laststamp`和`hzi::nextstamp`赋值。写死`classId==3`数据帧，只对微震背景数据帧的摘要处理（**能量密度文件**）
>   >
>   >   > * hzi::laststamp——上一个数据帧df的采样时间
>   >   >
>   >  > *  hzi::nextstamp——当前数据帧df的采样时间
>   >   >
>   >  > * **getEngDenityParm(flag)**——从表`e_tunnel_pickDateTime`**读取能量密度计算用的参数**存到`engParmList`。
>   >   >
>   >   >   入参flag，控制时窗engParm.wn是从全局变量`hzi::miningDateLen`（读自表`e_mining_PCOSignalParm`，10min）得到，还是从库表`e_tunnel_pickDateTime`中读取（2min）。
>   >   >   
>   >   >   该函数还有一处接口调用`/handerPickDataTime`，页面【数据提取】手动对给定时间段，读取能量密度文件结合时窗，找有效能量密度并入库`e_tunnel_RunningDataInfo`。
>   >   >   
>   >   >   > * getWnEng()——从`digest_256.dat`文件中**读取时窗内总能量和点数**分别到`sumvalue`和`points`
>   >   >   >
>   >   >   > * **readEngDenity(flag)**——递归调用（递归结束条件：分段时间不够时窗engParm.wn），每次递归从`fromsampTime~endsampTime`时间段内分出来一个时窗长度，从能量密度文件**`digest_256.dat`**中读取1个时窗wn内的数据。
>   >   >   >
>   >   >   >   获取各个通道单位时间du内的极值、点数、能量和（1h分为256份单位时间du），由能量和/点数得到能量密度存于`chnMap`。
>   >   >   >   
>   >   >   >   计算能量密度，若当前时窗wn内所有通道的能量密度均满足条件，则当前时窗起止时间入库表`e_tunnel_RunningDataInfo`。
>   >   >   >   
>   >   >   >   **更新全局变量`hzi::fromToEndMap`，插入能量密度符合条件的时窗的起止时间。**
>   >   >   >   
>   >   >   >   入参flag，控制是否更新全局变量`hzi::laststamp`。
>   >   >   >   
>   >   >   >   > * matchValue()——判定`chnMap`中存的所有通道的有效能量密度个数是否大于阈值rate。（判定参数由表`e_tunnel_pickDateTime`中读取，该表由【数据提取】页面设置。）
>   >   >   >   > * insertTunnelDataInfo()——入库表
>   >
>   > * handleTimeStamp_tunnel()——**铁建随掘数据帧实时处理**（时长10min，起止时间由ConnectServer.cpp-L231赋值）
>   >
>   >   > * mergeMs_tunnel()——铁建随掘拼帧（不同点：起止时间，还受到表`e_tunnel_RunningDataInfo`记录影响）
>   >   > * handleSignalProcess(dfvec, true, 0)——实时处理
>   >
>   > * **createDensity()**——写死只`classId == 0 `或` classId == 3`，自电或微震背景数据帧，数据写入**密度文件**
>   >
>   >   > * **setupDensityFile()**——创建摘要文件，**通过mio库映射到变量`densityMMaps`**
>   >   > * **通过向`densityMMaps`写数据，从而写到能量密度文件digest_256.dat**
>   >
>   > * FrameQueue——数据帧有锁消息队列
>   >
>   > * **digMsEvent()**——`hzi::frameQueues`中取微震全时拼接数据帧，从中**提取微震事件**（通道处于，阈值触发），根据`hzi::config.multiChnTrig`决定调用单通道触发处理还是多通道触发处理。拿到pair，结合微震超前点数，得到**微震事件数据帧（还是DataFrame）**。
>   >
>   >  > * checkMSEvt()——单通道触发：只有一个通道触发，返回数据帧df的(最后一个触发的通道的label，第一个触发点）的pair。
>   >   >
>   >  >   > * checkChn4MSEvt()——检查指定通道中是否有微震事件点（找到微震事件点则返回点索引，否则返回传入的上次微震事件点）返回(触发的通道label，第一个触发点)的pair。
>   >   >   >
>   >  >   >   > * 判定点属于触发点：`abs(pPnts[j]) * hzi::config.voltageCoef >=hzi::msEvtCnf.msThrldsMap[chLabel].first`
>   >   >   >   > * 连续触发点数大于脉宽：`j - i + 1 >= hzi::msEvtCnf.pulsWid`
>   >   >   >   > * **voltageCoef = 3000.0 / 8388607.0——这是什么？**
>   >   >
>   >   > * checkMSEvt1()——多通道触发
>   >
>   > * setTrigChn()——微震数据帧，设置：基站号，发生微震触发的通道号，classId为2
>   >
>   > * evtFrm.save()——保存微震数据帧，**classId=2**
>   >
>   > * **handleMSEvent()——拿到微震数据帧，定位微震事件**
>   >
>   >  > * `MSDataFrame`类
>   >  >
>   >  > * `MSDataFrame::saveLocation()`保存微震事件定位到表`e_msevt_rslts`
>   >  >
>   >  > * MSDataFrame::digEventFromBg()——从微震背景生成事件（//samptime前的10秒内取3个微震背景数据帧），重新生成`MSDataFrame`帧并save()
>   >  >
>   >  > * ms_locating1()——选择微震定位算法处理`MSDataFrame`帧
>   >  >
>   >  >   > * ms_locating()——粒子群定位
>   >  >   >
>   >  >   >   > * getMeanValue_miningLocX()
>   >  >   >   > * STELResult类——微震事件结果
>   >  >   >   > * CalEventProperty()——计算微震结果保存于变量`STELResult msRslt`
>   >  >   >   > * 保存到表`e_msevt_rslts`
>   >  >   >   > * tagEventByPArrVari()
>   >  >   >
>   >  >   > * MSDataFrame::locating()——最小方差定位
>   >  >   >
>   >  >   >   > * 保存到表`e_msevt_rslts`
>   >  >   >
>   >  >   > * MSDataFrame::locateByEnergy
>   >  >   >
>   >  >   >   > * 保存到表`e_msevt_rslts`
>   >  >   >
>   >  >   > * MSDataFrame::locateByRegression
>   >  >   >
>   >  >   >   > * 保存到表`e_msevt_rslts`
>

# 8. syncAllDevices()

---

## （1）时间同步原理

* 假设基站时间不精确，偏移为offset，帧传递时间为D。

* sync1帧（主-->从）：发送sync1帧时刻主机时间t1（当sync1帧到达从的时刻，下面类推，主知道：t1；从知道：t1，t2）

* sync1应答帧（主<--从）：收到sync1帧时刻基站时间t2（主知道：t1，t2；从知道：t1，t2）

* sync2帧（主-->从）：收到sync1应答帧时刻主机时间t3（主知道：t1，t2，t3，从知道：t1，t2，t3）

* sync2应答帧（主<--从）：收到sync2帧时刻基站时间t4（主知道：t1，t2，t3，t4；从知道：t1，t2，t3，t4）

* 当sync2应答帧被主机接收到时刻：t1,t2,t3,t4，主从均知。
  $$
  (t2-offset)-t1=t2-t1=D+offset \cdots① \\
  t3-(t2-offset)=t3-t2=D-offset \cdots②（此时从已知t1,t2,t3,t4；可算出D和offset）\\
  (t4-offset)-t3=t4-t3=D+offset \cdots③（此时主已知t1,t2,t3,t4；可算出D和offset）
  $$

| 初始化变量                                                   | 数据来源                                          | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------- | ------------------------------------------------------------ |
| **writeSendLog()**                                           |                                                   |                                                              |
| e_send_frm_log                                               |                                                   | 原始帧发送日志入库                                           |
|                                                              |                                                   |                                                              |
| 激电供电时间                                                 | p_time_wins                                       |                                                              |
| 激电通道数                                                   | e_chns_config                                     |                                                              |
|                                                              |                                                   |                                                              |
| **cmdId == 4//启动监测，初始化采集参数（采集置参所设置）**   |                                                   |                                                              |
| hzi::msEvtCnf.msThrldsMap                                    | e_chns_config                                     |                                                              |
| hzi::msEvtCnf.pulsWid，hzi::msEvtCnf.ringThrld               | e_ms_samp_config                                  |                                                              |
| hzi::msEvtCnf.msAheadPnt（微震超前点数）                     | p_points                                          |                                                              |
| hzi::msEvtCnf.sampIntvl（采样间隔）                          | e_ms_samp_config，p_samp_intvls                   |                                                              |
| hzi::msEvtCnf.msTrigChns（微震触发通道），hzi::msEvtCnf.msTrigWin（微震触发时窗） | e_ms_trig_params                                  |                                                              |
| hzi::msEvtCnf.validRange                                     | hzi::msEvtCnf.msTrigWin / hzi::msEvtCnf.sampIntvl | 通道间有效触发点差： msTrigWin/sampIntvl                     |
| hzi::densityColors                                           | p_density_colors                                  | 密度图中电压电流超过阈值后显示颜色的rgb。（如微震电压阈值，大于该值使用的颜色） |
| hzi::densityGrays                                            | p_density_grays                                   | 密度图中电压电流超过阈值后显示颜色的灰度。                   |
| hzi::viewSpace                                               | e_space                                           | 空间参数                                                     |
| hzi::viewSpace                                               | e_speed，e_vti_speeds                             | **速度参数(系统实时参数，再提取参数)**：速度模型（0-匀速模型 1-层状模型），p/s/c波速度 |
| hzi::chnState                                                | e_chns_config                                     | 所有通道的(label,state_id)                                   |
|                                                              |                                                   |                                                              |
| **cmdId == 8or9**                                            |                                                   |                                                              |
|                                                              |                                                   |                                                              |
|                                                              |                                                   |                                                              |

> [!NOTE]
>
> 每隔间隔（`hzi::config.timeSyncIntval`），遍历`devicemap`基站，向基站发送sync1帧
>
> * sync1()——向devAddr指定的基站发送sync1帧（帧数据：当前时间ms，cmdId==8）
>
>   > * **sender::sendCmd**(uint8_t addr, uint8_t cmdId, const char *data)——向指定基站以指定命令字的格式下发原始帧数据，data仅为数据区内容。
>   >
>   >   > * writeSendLog()——记录下发命令日志（连接检测帧，对时帧，不记录日志），入库表`e_send_frm_log`，返回最新一条下发命令的cmd_seq（所有已发命令的编号）。
>   >   > * setSendBuf()——将数据区data根据cmdId等拼成完整原始帧存于buf。
>   >   > * sock::write()
>   >   > * relayConfig()——当前主机作为client，连接采集主机（hzi::config.sampler_ip, hzi::config.relayPort），将帧发送给采集主机，并接收回复。
>   >
>
> * sync2()——向devAddr指定的基站发送sync1帧（帧数据：下位机发送的sync1应答帧收到时间ms，cmdId==9）
>

# 9. syncWarningInfo()

---

> [!NOTE]
>
> 微震事件预警信息发送：通过企业微信

# 10. realTimeCal()

---

| 初始化变量          | 数据来源               | 说明                       |
| ------------------- | ---------------------- | -------------------------- |
| hzi::fromToEndMap   |                        | 自动计算，多个分段起止时间 |
| hzi::miningFreq     | e_mining_PCOSignalParm | 监测频度 单位：h           |
| hzi::miningDateLen  |                        | 每段数据时长（min）        |
| hzi::mining_classId |                        | 当前处理数据帧类型（3or6） |
|                     |                        |                            |
|                     |                        |                            |

> [!NOTE]
>
> 提取+偏移实时计算
>
> * hzi::miningDateLen：每段（炮）时长
> * hzi::mining_classId：从库表`e_data_frm_info`中拼帧、处理的数据帧类型（3 or 6)
> * hzi::fromToEndMap：时窗（每段起止时间），这里由`getEngDenityParm()`的flag==true决定，时窗长度来自`e_mining_PCOSignalParm`。
> * threadHanleData()
>
> > * mergeMs(dev_id)
> >
> >   > * 



> [!NOTE]
>
> * handleTimeStamp_tunnel()也会实时计算

# 11. startConnect()

---

> [!NOTE]
>
> 
>
> * startConnectTo()——



# 12. syncUpWSdata()

---

>  [!NOTE]
>
> 微震事件表`e_msevt_rslts`中记录处理一下通过FTP上传
>
> * isSaturdayMorning()——判断给定时间戳是否是10点到12点之间（flag为true时判断是否是周六的10点到12点）
>
> * writeFTPFile()——发送微震数据
>
>   > * getGeodeticPoint()——系统坐标转大地坐标
>   >   $$
>   >   Z=RX+Y\\
>   >   R为旋转变换，Y为平移变换
>   >   $$
>   >
>   >   $$
>   >   \begin{bmatrix}
>   >   z_1\\
>   >   z_2\\
>   >   z_3
>   >   \end{bmatrix}
>   >   =
>   >   \begin{bmatrix}
>   >   r_{00} & r_{01} & r_{02}\\
>   >   r_{10} & r_{11} & r_{12}\\
>   >   r_{20} & r_{21} & r_{22}
>   >   \end{bmatrix}
>   >   \begin{bmatrix}
>   >   x_1\\
>   >   x_2\\
>   >   x_3
>   >   \end{bmatrix}
>   >   +
>   >   \begin{bmatrix}
>   >   y_1\\
>   >   y_2\\
>   >   y_3
>   >   \end{bmatrix}
>   >   $$

| 库表           | 读写变量                       | 读写变量说明           | 表说明                                                       |
| -------------- | ------------------------------ | ---------------------- | ------------------------------------------------------------ |
| e_acqui_points | dataFile                       | 微震基础信息           | 微震数据基础信息表？                                         |
| e_model_matrix | geodeticOrigin，rotationMatrix | 原点大地坐标，变换矩阵 | 存储：原点的大地坐标及变换矩阵（4行，item=origin/vector_x/vector_y/vector_z） |
| e_info         | wf_name                        | 采煤工作面名称         | 工程参数表                                                   |
| e_msevt_rslts  |                                |                        | 微震事件                                                     |

# 13. https服务

---

> [!NOTE]
>
> `start_http_server()`线程
>
> 基于 Pistache 库的 HTTP 服务器配置，在指定端口上，启动http服务器

## （1）创建/启动服务器

```cpp
if (hzi::config.enable_http) {
    cout << "http enabled\n";
    std::thread(start_http_server).join();//在指定端口上启动http服务，函数位置：web/http_server.cpp
} else {
    cout << "http disabled\n";
    // 仅采集时启动中继置参服务
    std::thread(sse::startConfRelayer).detach();
    std::thread(sse::startSSERelayer).join();
}
```

```cpp
//http_server.hpp
#ifndef HTTP_SERVER_HPP
#define HTTP_SERVER_HPP

#include "routes.hpp"

void start_http_server();

#endif
```

```cpp
//http_server.cpp
#include "../Config.hpp"

#include "http_server.hpp"

void start_http_server() {
    RoutesManager app({Ipv4::any(), 9800});
    app.serve();
}
```

```cpp
//routes.hpp
#ifndef ROUTES_HPP
#define ROUTES_HPP

#undef TRY
#include <pistache/endpoint.h>
#include <pistache/router.h>

using namespace Pistache;
using namespace Rest;

class RoutesManager : public Http::Endpoint
{
  Rest::Router router;

public:
  RoutesManager(Address addr);
};

#endif
```

```cpp
//routes.cpp
#include "routes.hpp"
RoutesManager::RoutesManager(Address addr) : Http::Endpoint(addr)
{
    //接口
    Routes::Post(RoutesManager::router, "/upload_doc/:mime/:name",
               Routes::bind(&cmd::uploadDocument));
  	Routes::Get(RoutesManager::router, "/download_doc/:mime/:name",
              Routes::bind(&cmd::downloadDocument));
    ...
    setHandler(router.handler());
}
```

```cpp
//ms_commands.cpp
//存放接口回调函数
namespace cmd 
{
    //上传文件
    void uploadDocument(const Rest::Request &request,
                        Http::ResponseWriter response) {
        response.headers().add<Http::Header::ContentType>(MIME(Text, Plain));
        if (!request.hasParam(":name") || !request.hasParam(":mime")) {
            response.send(Http::Code::Bad_Request, "缺少参数");
            return;
        }
        string filename = request.param(":name").as<string>();
        string fileMime = request.param(":mime").as<string>();

        if (request.body().empty()) {
            response.send(Http::Code::No_Content, "没有传入文件");
            return;
        }

        fs::path filePath("assets/images/");
        filePath /= filename;
        if (!fs::exists(filePath.parent_path())) {
            response.send(Http::Code::Expectation_Failed, "Invalid path");
            return;
        }

        try {
            //根据格式保存文件
            std::ofstream ofs;
            //图片
            if (fileMime == "png" || fileMime == "jpg" || fileMime == "jpeg" ||
                fileMime == "gif" || fileMime == "bmp") {
                ofs.open(filePath, std::ifstream::binary);
            } else if (fileMime == "pdf") {
                ofs.open(filePath, std::ifstream::binary);
            } else if (fileMime == "xlsx") {
                ofs.open(filePath, std::ifstream::binary);
            } else if (fileMime == "csv") {
                ofs.open(filePath);
            } else if (fileMime == "zip") {
                ofs.open(filePath, std::ifstream::binary);
            }

            if (!ofs.is_open()) {
                response.send(Http::Code::Expectation_Failed,
                              "failed to create: " + filename);
                return;
            }
            ofs.write(request.body().data(), request.body().size());
            ofs.close();
            response.send(Http::Code::Ok, filename + " uploaded!");
        } catch (std::exception &e) {
            logErr(e.what());
            response.send(Http::Code::Expectation_Failed,
                          "Failed to upload: " + filename);
            return;
        }
    }
    
    //下载文件
    void downloadDocument(const Rest::Request &request,
                          Http::ResponseWriter response) {
        if (!request.hasParam(":name") || !request.hasParam(":mime")) {
            response.send(Http::Code::Bad_Request, "缺少参数");
            return;
        }

        string filename = request.param(":name").as<string>();
        string fileMime = request.param(":mime").as<string>();

        if (filename == "undefined") {
            response.send(Http::Code::No_Content, "没有指定pdf文件名");
            return;
        }

        fs::path filePath("assets/images/");
        filePath /= filename;
        if (!fs::exists(filePath) || !fs::is_regular_file(filePath)) {
            cout << "file not exists: " << filePath.string() << endl;
            response.send(Http::Code::Expectation_Failed,
                          "file not exists:" + filename);
            return;
        }

        try {
            std::ifstream ifs;
            if (fileMime == "png" || fileMime == "jpg" || fileMime == "jpeg" ||
                fileMime == "gif" || fileMime == "bmp" || fileMime == "pdf" ||
                fileMime == "zip") {
                ifs.open(filePath, std::ifstream::binary);
            } else if (fileMime == "csv" || fileMime == "xlsx") {
                ifs.open(filePath);
            }

            if (!ifs.is_open()) {
                cout << "failed to open file: " << filePath << endl;
                response.send(Http::Code::Expectation_Failed,
                              "failed to open: " + filename);
                return;
            }

            if (fileMime == "png") {
                response.headers().add<Http::Header::ContentType>(MIME(Image, Png));
            } else if (fileMime == "jpg") {
                response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
            } else if (fileMime == "jpeg") {
                response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
            } else if (fileMime == "gif") {
                response.headers().add<Http::Header::ContentType>(MIME(Image, Gif));
            } else if (fileMime == "bmp") {
                response.headers().add<Http::Header::ContentType>(MIME(Image, Bmp));
            } else if (fileMime == "pdf") {
                response.headers().add<Http::Header::ContentType>(
                    "application/pdf; charset=utf-8");
            } else if (fileMime == "csv") {
                response.headers().add<Http::Header::ContentType>(
                    "text/csv; charset=utf-8");
            } else if (fileMime == "xlsx") {
                response.headers().add<Http::Header::ContentType>(
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet; "
                    "charset=utf-8");
            } else if (fileMime == "zip") {
                response.headers().add<Http::Header::ContentType>(
                    MIME3(Application, OctetStream, Zip));
            }

            int64_t fileSize = fs::file_size(filePath);
            unique_ptr<char[]> bufTmp = make_unique<char[]>(fileSize);
            char *bufTmpPtr = static_cast<char *>(bufTmp.get());
            ifs.read(bufTmpPtr, fileSize);
            auto stream = response.stream(Http::Code::Ok);
            while (ifs.gcount() > 0) {
                stream.write(bufTmpPtr, ifs.gcount());
                stream << flush;
                ifs.read(bufTmpPtr, fileSize);
            }
            ifs.close();
            stream << ends;
        } catch (const std::exception &e) {
            cout << "failed to download:" << filename << endl;
            logErr(e.what());
            response.send(Http::Code::Expectation_Failed,
                          "failed to download: " + filename);
            return;
        }
    }
}
```

```cpp
//http_server.hpp
#ifndef HTTP_SERVER_HPP
#define HTTP_SERVER_HPP

#include "routes.hpp"

void start_http_server();

#endif
```

```cpp
//http_server.cpp
#include "../Config.hpp"
#include "../common.hpp"

#undef TRY
#include "http_server.hpp"

void start_http_server() {
    RoutesManager app({Ipv4::any(), hzi::config.httpPort});//Ipv4::any() 在 Pistache 里被解析成 0.0.0.0，监听本机所有 IPv4 网卡，既包括 127.0.0.1（回环），也包括服务器真正的外网/内网 IP。端口号config.httpPort
    logInfo("端口"+std::to_string(hzi::config.httpPort)+"上HTTP服务已启动");
    unsigned int nCores = std::thread::hardware_concurrency();//std::thread::hardware_concurrency() 获取系统支持的硬件线程数
    auto opts = Pistache::Http::Endpoint::options()//创建一个配置对象，用于设置服务器选项
        .maxRequestSize(1024 * 1024 * 5)//设置最大请求数量
        .threads(nCores/2)//设置服务器使用的线程数为系统硬件线程数的一半。
        .flags(Pistache::Tcp::Options::ReuseAddr);//设置套接字选项为 ReuseAddr，允许重新使用本地地址。
    app.init(opts);
    app.useSSL("etc/cert/xxx.pem",
               "etc/cert/xxx.key");//useSSL 方法用于配置服务器的 SSL 证书和密钥文件路径，启用 HTTPS 支持。
    app.serve();//启动http服务器，开始监听客户端请求
```

## （2）sse推送到客户端

Server-Sent Events（SSE）是一种允许服务器向客户端浏览器推送实时更新的技术。它是一种单向通信机制，主要用于从服务器向客户端发送消息，而客户端不需要频繁轮询服务器以获取更新。SSE是HTML5规范的一部分，通常用于实现实时通知、新闻推送、股票行情更新等功能。它基于http长连接。

虽然websocket也可实现服务器推送，但是sse更加轻量，无需引入其他的库。

- SSE主要用于服务器向客户端推送数据，客户端不能通过SSE向服务器发送数据。
- **自动重连**：如果客户端与服务器之间的连接断开，浏览器会自动尝试重新建立连接。
- **简单性**：相比WebSocket，SSE的实现更简单，因为它基于HTTP协议，不需要额外的协议握手

## （3）代码

* **事件格式**：

  **`event:类型`**：声明事件类型，不是必须的，但推荐使用，以便区分不同类型的事件。后面跟一个`\n`结束。

  **`data:数据`**：声明数据内容，必须的，每个事件至少需要一个 `data:` 字段。后面跟着一个`\n`。

  **`每条事件`**以两个换行符`\n\n`结束。

* **客户端处理**：客户端接收到事件后，会触发一个事件处理程序（通常是JS中的`onmessage`事件），并将事件数据传递给处理程序。
* **服务端处理**：

```cpp
//绑定回调
Routes::Get(RoutesManager::router, "/sse_back_status", Routes::bind(&sseBackStatus));

//回调函数
void sseDataChange(const Rest::Request &request, Http::ResponseWriter response) 
{
  response.headers().add<Http::Header::ContentType>("text/event-stream");
  response.headers().add<Http::Header::CacheControl>(Http::CacheDirective::NoCache);

  string streamStr;
  if (hzi::config.linkDevice) 
  {
    streamStr = getSSEDataChngStr();
  } 
  else
  {
    auto exp = getSSEStreamStr(0x2222);
    if (exp) 
    {
      streamStr = exp.value();
    }
  }

  if (streamStr.empty()) 
  {
    streamStr = defaultDataChngStr;
  }
  auto stream = response.stream(Http::Code::Ok);
  stream << streamStr.c_str() << Http::flush << Http::ends;
}

string getSSEDataChngStr() 
{
  string streamStr;
  for (int i = 0; i < 10; i++) 
  {
    //为每个事件生成一个类型标识符，格式为 event:typeX，其中 X 是事件的索引
    streamStr += "event:type";//event字段
    streamStr += std::to_string(i).c_str();
    streamStr += "\n";//event字段结束
    if (true) 
    {
      streamStr += "data:0\n";//data字段
    } 
    else 
    {
      streamStr += "data:1\n";
    }
    streamStr += "\n";//事件结尾2个\n
  }
  return streamStr;
}
```

# ====================代码结构======================

# 14. 数据采集

---

## （0）原理

| 微震采集参数                         | 库表                            | 说明 |
| ------------------------------------ | ------------------------------- | ---- |
| 采样间隔                             | e_ms_samp_config，p_samp_intvls |      |
| 采样点数                             | e_ms_samp_config，p_points      |      |
| 超前点数                             | e_ms_samp_config，p_points      |      |
| 触发方式                             | e_ms_samp_config，p_ms_trigs    |      |
| 触发通道智能剔除                     | e_ms_trig_params                |      |
| 触发通道剔除判断时间（s)             | e_ms_trig_params                |      |
| 微震背景数据类型                     | e_ms_trig_params                |      |
| 触发通道数                           | e_ms_trig_params                |      |
| 触发时窗                             | e_ms_trig_params                |      |
| 微震触发脉宽                         | e_ms_samp_config                |      |
| 背景采样间隔（微震背景极值检测时窗） | e_ms_samp_config，p_time_wins   |      |
| 背景上传时窗（微震背景极值上传时窗） | e_ms_samp_config，p_time_wins   |      |
| 振铃阈值（微震背景振铃检测阈值）     | e_ms_samp_config                |      |

> [!NOTE]
>
> * 传感器将物理信号转成模拟电信号（电压），采集器将模拟电信号转成离散的数字信号，体现为离散的点。
>
> * 通过下发采集置参命令帧告知采集器，进行全时采集还是背景采集。
> * 上位机程序从全时数据帧或背景数据帧中提取微震事件。



## （1）原始帧

### 命令字（cmd_id）

> **决定帧类型**
>
> 不同功能的帧数据区长度不同。

| **命令功能**                  | **命令字** | **字节数****(Byte)** |
| ----------------------------- | ---------- | -------------------- |
| 基站检测                      | **0x01**   | 1                    |
| 时间校准                      | **0x02**   | 1                    |
| 采集置参                      | **0x03**   | 1                    |
| 启动监测                      | **0x04**   | 1                    |
| 停止监测                      | **0x05**   | 1                    |
| IP地址设置                    | **0x06**   | 1                    |
| 连接检测                      | **0x07**   | 1                    |
| 对时（1588，sync1帧和应答帧） | **8**      | 1                    |
| 对时（1588，sync2帧和应答帧） | **9**      | 1                    |

### 原始帧格式

> [!WARNING]
>
> 监测数据应答帧，增加了【参数区】

| 起始位置                           | 长度（字节）     | 功能                                | 说明                   |
| ---------------------------------- | ---------------- | ----------------------------------- | ---------------------- |
| 0                                  | 4                | **帧头**                            | 固定值：**0x68696869** |
| 4                                  | 4                | **后续字节数（不包括帧头+本字段）** | **帧长度-8**           |
| 8                                  | 1                | **校验标志**                        | 固定值：**0x0f**       |
| 9                                  | 1                | **设备标识**                        | 和设备地址什么区别？   |
| 10                                 | 1                | **设备地址**                        | 设备拼接掩码，即dev_id |
| 11                                 | 1                | **命令字**                          |                        |
| 12                                 | 4                | **命令标识**                        |                        |
|                                    |                  |                                     |                        |
| 16（监测数据应答帧才有）           | 32               | **参数区**                          |                        |
|                                    |                  |                                     |                        |
| 16(32，监测数据应答帧因存在参数区) | 视原始帧类型而定 | **数据区**                          |                        |
|                                    |                  |                                     |                        |
|                                    | 4                | **校验区**                          | 校验和                 |
|                                    | 2                | **帧尾**                            | 固定值：**0x1616**     |

### 原始帧数据类型（class_id）

| **类型**       | **通信值**  | **定义**                             |
| -------------- | ----------- | ------------------------------------ |
| 自电数据       | 0x00        | 电法通道实时监测采集信号             |
| 激电数据       | 0x01        | 主动发射引起的激发电场采集信号       |
| 微震触发数据   | 0x02        | 微震通道阈值触发引起的微震采集信号   |
| 微震极值数据   | 0x03        | 微震通道一定时窗内的背景极大值       |
| 温度数据       | 0x04        | 温度通道实时采集的信号               |
| 震电磁耦合数据 | 0x05        | 微震通道耦合阈值引起的全通道采集信号 |
| 微震背景数据   | 0x06        | 微震通道环境背景实时采集信号         |
| 伽玛传感器数据 | 0x0b （11） | 伽马传感器实时采集数据               |

### 监测数据应答帧（下位机--->上位机服务器）参数区

| **字节序号** | **大小（字节）** | **功能**                         | **参数说明**                                                 |
| ------------ | ---------------- | -------------------------------- | ------------------------------------------------------------ |
| D0~D7        | 8                | 采集时间                         | 采集时间8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00 UTC |
| D8           | 1                | 原始帧类型classId                | **类型**            **属性**            **说明**                  0x00            自电数据            自然电位信号                  0x01            激电数据            发射电法采集信号                  0x02            微震触发数据            微震触发信号                  0x03            微震极值数据            微震时窗极值信号                  0x04            温度数据            实时温度信号                  0x05            震电磁耦合数据            震电磁‘耦合’信号                  0x06            背景数据            实时采集的背景信号 |
| D9           | 1                | 是否包含电流通道                 | 0x0：否 0x1:是                                               |
| D10~D11      | 2                | 包含通道数                       | 数据量包含数据通道数                                         |
| D12~D15      | 4                | 每通道包含点数                   | 每通道数据点数                                               |
| D16          | 1                | 发射帧序号                       | 电法发射帧序号                                               |
| D17~D18      | 2                | 信号触发通道号                   | 用于微震的信号触发时值最大的通道                             |
| D19          | 1                | 激电发射电压                     | **发射电压**            **说明**                  24V            参考通信值约定中的电压**类型**。                  48V                  72V                  96V |
| D20          | 1                | 该帧数据采集时刻激电是否正在采集 | 0x00:否 0x01:是                                              |
| D21          | 1                | 对时模块网络状态                 | 0x00:失联  0x01:正常                                         |
| D22~D29      | 8                | 对时模块时间信息                 | 8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00  UTC |
| D30          | 1                | 激励电法发射模式                 | 0x00:单正 0x01:正负正 0x02:M序列                             |
| D31          | 1                | 触发通道数                       |                                                              |

### 监测数据应答帧数据区

* 数据区：电流数据+电压数据
* 电流数据：4字节表示一个电流值，第一个字节最高位为符号位!  总点数为每通道包含点
* 电压数据：4字节表示一个电压值，第一个字节最高位为符号位! 总点数为电法发射采集模式：（包含通道数-1）×每通道包含点数；
* 其余模式：包含通道数*每通道包含点
* 温度数据：2字节表示一个温度值

## （2）数据帧DataFrame

### 数据类型（构建数据帧的原始帧类型）

![image-20250411173017037](D:\notes\笔记Img\image-20250411173017037.png)

| DataFrame类型id：df.classId() | 类型                             | 说明                                                         |
| ----------------------------- | -------------------------------- | ------------------------------------------------------------ |
| 2                             | 原始帧：微震事件                 |                                                              |
| 3                             | 原始帧：微震背景                 | 采样间隔2ms，5s一个文件，每个通道2500点，存储的是极值（摘要文件digest_.dat中单位时间内的极大值或极小值） |
| 6                             | 原始帧：微震全时                 | 采样间隔0.5ms，2.5s一个文件，一个文件内5000个采样点          |
|                               |                                  |                                                              |
| 9                             | 数据帧：干涉提取数据文件         |                                                              |
| 99                            | 数据帧：随掘互干涉信号处理后文件 | 9文件经过信号处理流程后的再提取数据文件。注意：该文件classid=9，而不是99 |
| 10                            | 数据帧：偏移图数据文件           |                                                              |
|                               |                                  |                                                              |
| 11                            | 原始帧：伽马射线                 | DataFrame格式同1/3/6，只第19字节采样间隔写死为1s。           |
| 12                            | 原始帧：电磁数据                 | DataFrame格式同1/3/6/11。                                    |
| 13                            | 数据帧：随掘自干涉提取文件       |                                                              |
|                               |                                  |                                                              |
| 14~17                         | 未使用                           |                                                              |
| 30                            | 电法数据文件                     | 下分为1~6六种类型。                                          |
| 101                           | y分量偏移图数据文件              | 10为x分量的偏移图数据文件。格式同10。                        |
| 102                           | z分量偏移图数据文件              | 10为x分量的偏移图数据文件。格式同10。                        |

| 数据帧头   |            |                                                              |          |                                                              |
| ---------- | ---------- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| 位置(字节) | 大小(字节) | 定义                                                         | 数据类型 | 说明                                                         |
| 0          | 8          | 采样时间(ms)                                                 | double   | **数据帧内第一个采样数据点的时间戳**。（每个时间点的精确采样时间戳可由`该值+i*采样间隔`计算） |
| 8          | 1          | 采样数据类型id                                               | uint8_t  | 原始帧类型                                                   |
| 9          | 1          | 是否包含电流通道                                             | uint8_t  | 1:包含； 0:不包含                                            |
| 10         | 2          | 该数据帧包含的通道数（不论通道state_id是否==0，即不论是否坏道） | uint16_t | DataFrame::setChannels                                       |
| 12         | 4          | 每通道数据点数                                               | uint32_t | DataFrame::setPoints                                         |
| 16         | 1          | 激电发射帧序号或**微震触发通道号（用于微震的信号触发时值最大的通道）** | uint8_t  |                                                              |
| 17         | 1          | 激电发射或**微震触发基站ID号**,主要用于多基站                | uint8_t  |                                                              |
| 18         | 1          | 保留                                                         |          |                                                              |
| 19         | 4          | 采样间隔                                                     | float    | 毫秒                                                         |
| 23         | 1          | 激电激发类型id                                               | uint8_t  | 按协议定义                                                   |
| 24         | 1          | 激电发射电压id                                               | uint8_t  |                                                              |
| 25         | 1          | 该帧数据采集时刻激电是否正在采集                             | uint8_t  | 0x00:否，0x01:是                                             |
| 26         | 1          | 设备拼接掩码                                                 | uint8_t  | 对应拼接设备ID                                               |
| ***27***   | ***1***    | ***是否为拼接帧***                                           | uint8_t  | 若是则为1                                                    |
| 28         | 1          | 激电电压模式                                                 | uint8_t  | 0:固定；1:智能                                               |
| 29         | 4          | 保留                                                         |          |                                                              |

| 数据区     |                          |                                      |          |                                |
| ---------- | ------------------------ | ------------------------------------ | -------- | ------------------------------ |
| 位置(字节) | 大小(字节)               | 定义                                 | 数据类型 | 说明                           |
| 32         | 通道数x 每通道数据点数x4 | 原始采样数据值按通道、数据点顺序存放 | int      | 含电流通道时，第一道为电流数据 |

* 字节序：小字节序（高位在后，低位在前）
* 协议：指本公司《微震电法并行物理场监测系统采集通信约定》 
* 数据值： int类型的采样原始数据，未乘系数 
* 从系统页面下载数据文件名约定： yyyy_mm_dd_采集数据类型 id_采样时间戳.semt.bin 

## （3）多基站拼帧

* dev_id表示基站数量：dev_id采用mask表示拼接的基站号，uint8_t，从右往左每个bit表示一个基站，只有1号时dev_id=1, 只有2号时dev_id=2，都有时dev_id=3。

* 拼帧（原始帧拼接为数据帧）是采集时后端实时完成：

  只有双基站同时段都有数据帧时才能拼接，此时`dev_id=3`

  只有一个基站有数据时就不拼了，直接保存，`dev_id=1 or 2`

* 若基站1有16个通道，基站2有16个通道，那么双基站时，拼出的数据帧的通道数将为32

## （4）采集参数置参与数据采集

* 下发采集参数，并入库：接口`/cmds/:cmd_id/:dev_id?`，详见页面-采集置参。
* 应答帧处理并入库：详见`startReceiver()`

# 15. 历史处理：干涉提取信号+信号处理+偏移（旧代码）

---

> [!CAUTION]
>
> * 拼帧`mergeMS()`根据`hzi::mining_classId`选择原始数据类型。根据`samp_time>fromtime`而不是`>=`挑选原始数据的时间戳。使得拼得到的数据帧的`sampTime()`获取的时间`+2.5s`或`+5s`。从而解决全时/背景提取数据都写入表`e_mining_signaldata_frm_info`中主键`samp_time`冲突的问题。
>
> * 原始数据帧中不考虑通道的`state_id`，即使页面上标的是损坏或耦合不佳的坏道，原始帧中也会有其数据。
>
> * 拼帧也不考虑通道`state_id`，即使坏道的数据也会拼帧。
>
> * 相关计算时考虑通道`state_id`，干涉道或因子道则该干涉道的相关计算返回。这会导致最终的相关结果中，该道数据全0。
>
> * 若全部道的数据均为0，考虑是因子道为坏道。实时计算：干涉源提取+再提取+偏移成图。
>
> * 历史计算：干涉源提取+偏移成图。再提取需要手动点执行。
>
> * 所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
>
> * 9文件时间戳处理：
>
>   若用【背景】原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。（读表到类型变量`hzi::mining_classId`）
>
>   若用【全时】原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。
>
>   原始数据的samp_time字段，全时两个文件的时间戳之差为2.5s，背景为5s。
>
>   通过`mergeMS()`中的sql查询语句实现的：
>
>   ```cpp
>   //因为samp_time是>fromtime，而不是>=fromtime
>   auto rslt0 = conn.executeQuery(
>       "select channels,count(1) as number from e_data_frm_info  "
>       " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
>       "  AND samp_time < FROM_UNIXTIME(?) and dev_id = ? GROUP BY channels ORDER BY "
>       "count(1) desc limit 1",
>       hzi::mining_classId, fromtime, endtime, devId);
>   ```

### 取参数

| -                    | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| `getPCO_parm(true)`  | 读取实时计算参数表`e_mining_PCOSignalParm`到`pcoParm`        |
| `setPCOLocParm()`    | 读取参数到`pcoLocParm`，根据日进尺计算回采位置仅用于计算，不入库 |
| `setPCOCalChn()`     | 读取参数到`pcoCalChnParms`                                   |
| `setSignalChnInfo()` | 读取参数到`pcoExtractChnParms`。自相关/互相关。              |

### 库表

| 表名                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | **9类型数据**。提取图数据                                    |
| e_mining_pcodata_frm_info      | **10类型数据。**偏移图数据                                   |
|                                |                                                              |
| e_mining_PCOSignalParm         | **信号处理参数（实时），信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **信号处理参数（历史），信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。`Notch_jobs`是陷波滤波类型，0-奇偶倍，1-奇数倍，2-偶数倍，3-一倍。`notchF`是陷波频率，目前实时计算时陷波频率还是写死50hz。 |
| e_space                        | **观测空间参数。**                                           |
| e_mining_PCOLocParm            | **网格模型参数。**掘进方向，前探距离，网格长度等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | **掘进信息。**回采位置历史，时间戳，日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | **通道类型映射**                                             |
| e_chns_config                  | 通道实时坐标。通道从属的基站id，通道编号，通道类型，**通道状态**，**通道坐标。** |
| e_chns_config_history          | **通道历史坐标。**                                           |

## （1）实时流程

> [!IMPORTANT]
>
> 实时：自动进行【提取+再提取+偏移】，保存提取文件9，保存偏移文件10，但不保存文件99（只历史重算保存99）。
>
> `main.cpp--realTimeCal()`开个detach线程。
>
> `ConnectServer.cpp--realTimeCal()`线程执行函数`while(1)`循环。
>
> > * threadHanleData()
> >
> >   > * hzi::fromToEndMap——存放多个起止时间pair
> >   >
> >   > * mergeMs()——读取起止时间内的原始帧文件拼为数据帧`dfvec`。
> >   >
> >   > * handleSignalProcess(dfvec, true)——信号提取+信号处理。flag==true，信号处理；flag==false，不处理。
> >   >
> >   >   > * 取干涉提取，信号处理参数
> >   >   >
> >   >   > * PureCommonOperation::handleDataFrameVec_signal()
> >   >   >
> >   >   >   > * ParallelCorrelation(dfvec)——相关计算提取信号。信号处理。
> >   >   >   >
> >   >   >   >   【预处理】、【信号加窗】、【相关计算】、【滑动时窗】、【一维频域滤波】、【反褶积】、【一维频域滤波】、【道内均衡】（AGC、指数增益）、【道间均衡】、【反射波提取】。
> >   >   >   >
> >   >   >   >   结果存于`pOutSignal`。
> >   >   >   >
> >   >   >   > * `pOutSignal`写9类型文件，入库表`e_mining_signaldata_frm_info`
> >   >   >   >
> >   >   >   > * `PureCommonOperation::CalMigration(pOutSignal)`——偏移计算
> >   >   >   >
> >   >   >   >   结果存于`pOut_tmp`
> >   >   >   >
> >   >   >   > * `saveResult(true)`——`pOut_tmp`写偏移图文件，入库表`e_mining_pcodata_frm_info`。
> >   >   >   >
> >   >   >   >   传入`true`表示进行异常提取。

### ※拼帧

> [!NOTE]
>
> * `ms_mining.cpp`中`mergeMs()`。
> * `MergeMs`是把指定时间段内的（若干次采样）若干个6/3原始数据文件的数据拼成1个帧。
> * 每个6/3原始数据文件，只包含1次采样时间内的数据。
> * 每个6/3原始数据文件都包含了所有通道1次采样的数据。

```cpp
if (dev_id == 0)
{
    int devId = hzi::sysDevMask;
    //按channels分组，按各组条数降序排列。取1条记录，即channels条数最多。
    auto rslt0 = conn.executeQuery(
        "select channels,count(1) as number from e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?) and dev_id = ? GROUP BY channels ORDER BY "
        "count(1) desc limit 1",
        hzi::mining_classId, fromtime, endtime, devId);
    if (rslt0.next())
    {
        chns0 = rslt0.getInt("channels");   //获取通道数
    }

    auto rslt = conn.executeQuery(
        "SELECT samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?)  AND channels = ?  and dev_id = ? ORDER BY "
        "samp_time ASC",
        hzi::mining_classId, fromtime, endtime, chns0, devId);

    while (rslt.next())
    {
        pnts0 = rslt.getInt("ch_pnts");		//获取1次采样的点个数
        auto pathstr = rslt.getString("frm_loc");	//数据文件路径
        pnts += pnts0;  //[fromtime,endtime]时间段内一个通道的所有点数之和
        pathVector.push_back(pathstr);  //每个数据文件的路径
    }
    if (pnts0 == 0 || pnts == 0 || chns0 == 0)
        return tl::make_unexpected("DataFrame::merge: The data for that time period is empty");
   
    DataFrame newDF(chns0, pnts); // 所有通道在时间段内的所有点，拼一个大的帧，帧数据大小chns0*pnts*4B
    string path = Config::dataRoot + "/";
    for (int i = 0; i < pathVector.size(); i++)
    {
        auto filePath = path + pathVector[i];	//原始数据文件路径
        if (!fs::exists(filePath))
            return tl::make_unexpected("DataFrame::merge: file Path error");
        std::ifstream ifs(filePath);
        auto fileSize = fs::file_size(filePath);
        DataFrame fileDF(chns0, pnts0);	//保存一个数据文件的小帧
        ifs.read(fileDF.upHead.get(), 32); //从数据文件读数据头到fileDF帧
        // ifs.seekg(0);
        ifs.read(fileDF.upData.get(), fileSize - 32);   //从数据文件读数据体到fileDF帧
        ifs.close();
        
        //把fileDF帧中数据拷贝到大的数据帧里
        if (i == 0)	//第一次拷贝时，需要把小帧的头拷贝到大帧的头，改下点数为大帧存的点数
        {
            memcpy(newDF.upHead.get(), fileDF.upHead.get(), 32); 
            newDF.setPoints(pnts); // fileDF在memcpy时把newDF原本的pnts改成了pnts0，这里重新设置回来
        }

        //把每次采样的数据文件中的数据，遍历通道，拷贝到newDF中（外面i循环是数据文件数，ch循环对每个数据文件的通道数）
        for (int ch = 0; ch < chns0; ch++)
        {
            memcpy(newDF.upData.get() + ch * pnts * 4 + i * pnts0 * 4,
                   fileDF.upData.get() + ch * pnts0 * 4, pnts0 * 4);
        }
    }

    //返回拼好的大的数据帧
    return std::move(newDF);
```

### ※提取+信号处理

> [!NOTE]
>
> * 函数`handleSignalProcess(dfvec, true)`，传入false只进行提取。传入true时，才会提取+再提取。`dfvec`中存储多炮的数据，即多个拼帧得到的大帧。
>
> * 读表获取参数
>
>   | -                    | 说明                                                  |
>   | -------------------- | ----------------------------------------------------- |
>   | `getPCO_parm(true)`  | 读取实时计算参数表`e_mining_PCOSignalParm`到`pcoParm` |
>   | `setPCOLocParm()`    | 读取参数到`pcoLocParm`                                |
>   | `setPCOCalChn()`     | 读取参数到`pcoCalChnParms`                            |
>   | `setSignalChnInfo()` | 读取参数到`pcoExtractChnParms`。自相关/互相关。       |
>
> * `pOutSignal`用于保存并行计算处理结果。
> * `PureCommonOperation::handleDataFrameVec_signal`并行计算，对每一炮数据开个线程异步计算，依次执行：【加窗，预处理】，【信号加窗】，【滑动时窗】，【相关计算】，【一维滤波】，【反褶积】，【一维滤波】，【道内均衡】，【道间均衡】，【反射波提取】。
> * `pOut_tmp`用于保存偏移计算结果。

```cpp
/*
* 多炮数据处理
* 实时计算（flag=true）：
* 历史重算（flag=false）：只进行干涉源提取，不进行其他计算
*/
string handleSignalProcess(std::vector<DataFrame *> dfVec, bool flag, int dev_id)
{
    auto deltT = dfVec[0]->sampIntvl();//采样间隔
    auto tmStmp = dfVec[0]->sampTime();//采样时间（跟踪一下拼帧后的帧的采样时间是什么含义）
    auto devId = dfVec[0]->devMask();
    float speed_p, speed_s = 0;
    bool is_evenSpeed = 0;
    auto pntss = dfVec[0]->points();
    int useVType = 0; // 默认使用P波偏移，偏移类型（0-P波 ，1-S波 2-PS波)

    PureCommonOperation::PCOLocParm pcoLocParm;
    PureCommonOperation::PCOSignalParm pcoParm;
    bool outType = 0;
    int outSurLineId = 0; // 随采输出测线id 使用测线数量
    int isUseCSP = 0;
    bool ret = getPCO_parm(pcoParm, pcoLocParm, deltT, flag, outType, outSurLineId, isUseCSP, useVType, is_evenSpeed, speed_p, speed_s);

    auto conn = hzi::config.pConnPool->getConnection();

    double dateTime = (double)tmStmp / 1000.0;
    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(tmStmp, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    if (!hzi::config.ms_tunnel_listen)
    {
        hzi::tunnel_mining_loc = pcoLocParm.m_locx;
    }

    if (hzi::config.verbose)
        cout << " 回采位置：" << pcoLocParm.m_locx << endl;

    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }
    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }

    pcoParm.ms_components = hzi::config.ms_components;
    pcoLocParm.out_type = 1;

    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);

    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    // 先找出所有通道，进行分量和测线配置，然后删除不需要的通道  devId
    setPCOCalChn(pcoCalChnParms, hzi::sysDevMask, tmStmp, flag);

    for (int i = 0; i < 3; i++)
    {
        pcoParm.dataChnNO[i] = pcoParm.chnno;
    }

    if (pcoParm.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            auto chn_no = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            auto is_out = rslt_comp.getInt("is_out");
            if (is_out)
                pcoLocParm.out_type = id;
            if (flag)
            {
                // 实时计算
                pcoParm.dataChnNO[id - 1] = chn_no;
            }
            else
            {
                // 历史计算
                pcoParm.dataChnNO[id - 1] = chn_no_history;
            }
            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                    //  cout<<" 通道号："<<num<<" 分量："<<id<<" enb = "<<pcoCalChnParms[num-1].enb <<endl;
                }
            }
        }
    }

    // auto surveyLineCount = 1;//测线数量 1-机载式，2-双巷式，3-混合式
    // systemeType = 0 系统类型：0-双巷式，1-机载式，2-组合式'
    int lineArry[3] = {0};
    //  int mining_singalCount = 0;
    if (hzi::config.ms_mining_type == 1)
    {
        auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
        while (rslt_surveyLine.next())
        {
            auto id = rslt_surveyLine.getInt("id");
            // surveyLineCount = (id > surveyLineCount) ? id : surveyLineCount;
            auto chnsList = rslt_surveyLine.getString("chnsList");

            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            lineArry[id - 1] = chns_List.size();
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].id = id; //测线id
                    // cout<<" 通道号："<<num<<" 测线："<<id<<endl;
                }
            }
        }
        // mining_singalCount = getSignalChnCount(pcoParm.systemeType ,pcoParm.ImageType,lineArry[0],lineArry[1],lineArry[2],hzi::config.ms_components);

        for (int i = 0; i < 3; i++)
        {
            if (dev_id != 0)
            {
                if (lineArry[i] != 0 && dev_id == i + 1)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
            else
            {
                if (lineArry[i] != 0)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
        }
    }

    //随掘
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        //  pcoLocParm.is_exclude_directWaves = true;
        if (pcoParm.ms_components > 1)
        {
            auto chnno_tmp = pcoParm.dataChnNO[0];
            pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
        }
        else
        {
            pcoLocParm.fx = pcoCalChnParms[pcoParm.chnno - 1].x;
            pcoLocParm.fy = pcoCalChnParms[pcoParm.chnno - 1].y;
            pcoLocParm.fz = pcoCalChnParms[pcoParm.chnno - 1].z;
        }
    }

    if (dev_id != 0)
    {
        // 指定测线数据处理 取对应基站的坐标 默认基站号与测线号对应
        pcoCalChnParms.erase(
            std::remove_if(
                pcoCalChnParms.begin(),
                pcoCalChnParms.end(),
                [dev_id](const PureCommonOperation::PCOCalChn &elem)
                {
                    return elem.id != dev_id;
                }),
            pcoCalChnParms.end());
    }
    // 在此区分随掘和随采的信号提取通道数量 随采根据测线来决定

    int vecSize = dfVec.size();//炮数
    auto chns = dfVec[0]->channels();//

    PureCommonOperation::PCOExtractChn pcoExtractChnParms;
    setSignalChnInfo(pcoExtractChnParms, pcoCalChnParms, pcoParm, chns);
    // cout<<" count = "<<pcoExtractChnParms.count
    //     <<" , chnno = "<<pcoExtractChnParms.chnNoVec.size()
    //     <<" , coechnno = "<<pcoExtractChnParms.coeChnNoVec.size()<<",chns = "<<chns<<endl;

    auto valChnns = pcoExtractChnParms.count;
    // auto valChnns =(hzi::config.ms_mining_type == 1) ? mining_singalCount : chns;
    auto valNum = valChnns * vecSize;//通道数*炮数
    // cout<<" valNum = "<<valNum<<endl;
    auto iGrdNum =
        pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    pcoParm.mining_fx = pcoLocParm.fx;
    pcoParm.mining_fy = pcoLocParm.fy;
    pcoParm.mining_fz = pcoLocParm.fz;
    pcoParm.chns_Count = valChnns;
    pcoParm.chns = chns;
    // // 历史重算 只进行干涉源提取
    // if (!flag)
    // {
    //     pcoParm.isCut = 0;
    //     pcoParm.isCalRandon = false;
    //     pcoParm.isSpikeDeconvolution = false;
    //     pcoParm.deAGCtype = 0;
    //     isUseCSP = 0;
    //     pcoParm.interChnAmpEqual_type = 0;
    // }
    // 采煤机定位 随采采煤机定位
    int sumCount_jh = 170;
    float dis = 1.75;
    if (hzi::config.ms_mining_type == 1 && hzi::start_jh != 0 && hzi::end_jh != 0)
    {
        //  float dis_y = (pcoLocParm.m_dYMax - pcoLocParm.m_dYMin)/100;
        float y = pcoLocParm.m_dYMin + hzi::start_jh * dis;
        float dis_y = (hzi::end_jh - hzi::start_jh) * dis / vecSize;

        pcoLocParm.fx = pcoLocParm.m_locx;
        pcoLocParm.fy = y;
        pcoLocParm.fz = pcoLocParm.fz;
        pcoLocParm.dis_y = dis_y;
    }
    // cout<<"size = "<<dfVec.size()<<" , 通道："<<dfVec[0]->channels()<<", 时间戳"<<std::to_string(dfVec[0]->sampTime())
    //     <<"震源位置："<<pcoLocParm.fx<<" ,"<<pcoLocParm.fy<<", 间隔："<<pcoLocParm.dis_y<<endl;;


    /*
    * 对每炮数据进行处理：加窗，预处理，滑动时窗，相关，一维滤波，反褶积，道内均衡，道间均衡，反射波提取
    */
    float **pOutSignal = new float *[valChnns * vecSize];
    for (int dex = 0; dex < vecSize; dex++)
    {
        for (int ch = 0; ch < valChnns; ++ch)
        {
            pOutSignal[ch + dex * valChnns] = new float[pcoParm.outLen];
            memset(pOutSignal[ch + dex * valChnns], 0,
                   sizeof(float) * pcoParm.outLen);
        }
    }

    if (!flag)// 历史重算 只进行干涉源提取
    {
        pcoParm.isCut = 0;//无滤波
        pcoParm.isCalRandon = false;//无反射波提取
        pcoParm.isSpikeDeconvolution = false;//无反褶积
        pcoParm.deAGCtype = 0;//无道内均衡
        isUseCSP = 0;// 无CSP道集提取
        pcoParm.interChnAmpEqual_type = 0;//无道间均衡
    }
    PureCommonOperation::handleDataFrameVec_signal(
        std::move(dfVec), pcoParm, &pcoCalChnParms[0], pOutSignal, pcoExtractChnParms);
    logInfo(" handleDataFrameVec_signal  endl ");
    //上面：结果存于pOutSignal：实时--提取+再提取，历史--提取


    bool isSavePianyi = true;
    // CSP道集提取 已经生成了偏移图，不用进行偏移了
    if (isUseCSP != 0)
    {
        // 随采 散射 CSP道集提取
        isSavePianyi = false;
        if (hzi::config.ms_mining_type == 1 && pcoParm.ImageType == 0)
        {
            PureCommonOperation::CSPTraceParm cspParm;
            cspParm.nComponentCount = hzi::config.ms_components;
            cspParm.iCalTraces = pcoExtractChnParms.count;
            cspParm.nSamplePoints = pcoParm.outLen - pcoParm.coefBegPt;
            cspParm.fSampleInterval = deltT;
            cspParm.nAdvanPoints = 0;
            cspParm.fPV = speed_p;
            cspParm.fSV = speed_s;
            int surLineNum = (pcoParm.systemeType == 0) ? 2 : ((pcoParm.systemeType == 1) ? 1 : 3);

            float **pSignal = new float *[valChnns * vecSize];
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < valChnns; ++ch)
                {
                    // pSignal[ch + dex * valChnns] = new float[cspParm.nSamplePoints];
                    pSignal[ch + dex * valChnns] = new float[static_cast<int>(cspParm.nSamplePoints)];
                    for (int i = 0; i < cspParm.nSamplePoints; i++)
                    {
                        pSignal[ch + dex * valChnns][i] = pOutSignal[ch + dex * valChnns][i + pcoParm.coefBegPt];
                    }
                }
            }

            getCSPTrace(tmStmp, pSignal, pcoCalChnParms, cspParm, pcoLocParm,
                        pcoExtractChnParms, surLineNum);
        }
    }
    else
    {
        // 三分量需要叠加时使用
        //  float* pOut = new float[iGrdNum];
        //  memset(pOut, 0, sizeof(float) * iGrdNum);
        // 多分量分别设置
        for (int com = 0; com < pcoParm.ms_components; com++)
        {

            auto pretime = pcoParm.coefBegPt;

            pcoLocParm.is_evenspeed = is_evenSpeed;

            float *pOut_tmp = new float[iGrdNum];
            memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

            if (useVType < 2)//P波偏移或S波偏移
            {
                // float* pOut_tmp = new float[iGrdNum];
                // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

                float *pSpeedBtr = new float[iGrdNum];
                memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                for (int i = 0; i < iGrdNum; i++)
                {
                    if (useVType == 0)
                    {
                        pSpeedBtr[i] = speed_p;
                    }
                    else
                    {
                        pSpeedBtr[i] = speed_s;
                    }
                }
                getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                             coal_z, layer_from, is_evenSpeed);

                auto pretime2 = pretime * deltT;
                if (hzi::config.ms_mining_type == 1)//随采
                {
                    if (pcoParm.ImageType == 2)
                    {
                        PureCommonOperation::CalMigration_mining(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                            com + 1, pcoExtractChnParms, outSurLineId);
                    }
                    else
                    {
                        isSavePianyi = false;
                    }
                }
                else//随掘
                {
                    PureCommonOperation::CalMigration(
                        pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                        com + 1);
                }

                if (hzi::config.verbose)
                {
                    cout << " CalMigration endl " << endl;
                }
            }
            else if (useVType == 2)//PS波偏移
            {
                for (int type = 0; type < useVType; type++)
                {
                    // float* pOut_tmp = new float[iGrdNum];
                    // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);
                    float *pSpeedBtr = new float[iGrdNum];
                    memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                    for (int i = 0; i < iGrdNum; i++)
                    {
                        if (type == 0)
                        {
                            pSpeedBtr[i] = speed_p;
                        }
                        else
                        {
                            pSpeedBtr[i] = speed_s;
                        }
                    }

                    getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                                 coal_z, layer_from, is_evenSpeed);
                    auto pretime2 = pretime * deltT;
                    if (hzi::config.ms_mining_type == 1)
                    {
                        if (pcoParm.ImageType == 2)
                        {
                            PureCommonOperation::CalMigration_mining(
                                pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                                pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                                pcoParm.ampType, com + 1, pcoExtractChnParms, outSurLineId);
                        }
                        else
                        {
                            isSavePianyi = false;
                        }
                    }
                    else
                    {
                        //随掘
                        PureCommonOperation::CalMigration(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                            pcoParm.ampType, com + 1);
                    }
                }
            }
            //上面：pOutSignal中结果经过偏移计算，结果存于pOut_tmp

            //保存偏移图，pOut_tmp
            bool is_save = true;//true表示进行异常提取，false表示不进行异常提取
            if (isSavePianyi)
                bool ret = saveResult(tmStmp, devId, iGrdNum, pcoLocParm, pOut_tmp, com, is_save, outType);
        }
    }

    // 写9类型文件
    if (hzi::config.ms_miningSignal)
    {
        // auto pretime = 0;
        unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
        char *pHead2 = pHeadData2.get();
        *(double *)(pHead2) = (double)tmStmp;
        // 19 代表随采，9是随掘
        auto classId2 = 9;
        // auto classId2 = (hzi::config.ms_mining_type == 1) ? 19 : 9;
        *(uint8_t *)(pHead2 + 8) = classId2;
        *(float *)(pHead2 + 9) = deltT;
        *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
        *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
        *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
        *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
        *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
        if (hzi::config.ms_mining_type == 1)
        {
            *(uint8_t *)(pHead2 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
            *(uint8_t *)(pHead2 + 29) = pcoParm.ImageType;   //'随采成像方式:0-散射，1-透射，2-爆炸成像'
        }
        auto conn21 = hzi::config.pConnPool->getConnection();
        conn21.execute(
            "INSERT INTO "
            "e_mining_signaldata_frm_info "
            "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
            "loc,fx,fy,fz,dis)"
            "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
            " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
            "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
            (uint8_t)devId,  // dev_id
            tmStmp / 1000.0, // samp_time
            classId2,        // class_id
            deltT,           // curt_ch
            valNum,          // channels
            vecSize,
            pcoParm.outLen, // ch_pnts
            (relLocFromTime(tmStmp) / std::to_string(classId2) /
             std::to_string(tmStmp))
            .c_str(), // frm_loc
            pcoLocParm.fx,
            pcoLocParm.fy,
            pcoLocParm.fz,
            pcoLocParm.dis_y);

        fs::path outSignalfileName(hzi::config.dataRoot);

        outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
            std::to_string(tmStmp);
        try
        {
            auto dir = outSignalfileName.parent_path();
            if (!fs::exists(dir))
            {
                fs::create_directories(dir);
            }
            std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
            ofs_Signal.write(pHead2, 32);
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < valChnns; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOutSignal[ch + dex * valChnns];
                    // if (!pcoCalChnParms[ch].enb)
                    //     continue;
                    ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
                }
            }
            ofs_Signal.close();
        }
        catch (std::exception &e)
        {
            string msg("error while writing to file:");
            msg += outSignalfileName.string();
            msg += ":";
            msg += e.what();
            if (hzi::config.verbose)
                cout << "msg = " << msg << endl;
            debugErr(msg);
            return "error";
        };
    }

    return std::to_string(tmStmp);
}
```

#### ① 加窗+预处理

* 加窗

* 预处理

#### ② 相关计算

对1炮数据：

* 取通道号，以及该通道号对应的因子道号，将因子道数据暂存到`coefData`。

  index遍历所有因子道（遍历通道号更好吧？），同一个index对应的某个通道号和其使用的因子道号。


##### 滑动时窗

若`pcoParm.isUseSlideWn==true`，则进行滑动时窗后，再相关计算。

否则直接相关计算。

`pcoParm.outLen`为输出点数。

**这1通道的相关计算结果在`tmpResult`中。**

再拷贝到到`tmpOut`中暂存供后续计算，`tmpOut`为记录了所有炮数的所有通道的计算结果。

##### 相关

#### ③ 一维滤波

![image-20250429143704862](D:\notes\笔记Img\image-20250429143704862611)

遍历通道。

`pcoParm.isCut`为0-不滤波，1-时域滤波，2-频域滤波。

对`tmp_out`中暂存相关结果进行计算，`tmp_out[ch+dex*chns_Count]`中`ch+dex*chns_Count`为当前炮数的当前通道。

`Filter1dFD`进行频域滤波，`pcoParm.isStop`：false带通滤波，true带阻滤波。

`pcoParm.isNotchCut`是否进行陷波，调用`NotchFilter1dFD`陷波滤波。

* 频域滤波

  

* 带通滤波/带阻滤波

#### ④ 陷波

* `getPCO_parm`从库表取参数时，`pcoParm.notchF`为陷波频率，从表`e_mining_PCOSignalParm`和`e_mining_PCOSignalParm_history`中读取。**`ms_mining.cpp-2066行`和`ms_mining.cpp-3215行`**，对于陷波频率的处理修改了，之前库表里存的是【50n】字符串，现在改为该字段直接存数值。至于50可以做奇偶倍，125不做奇偶倍只做一倍，由用户自己决定。

* 测试方法：只保留陷波，陷波带宽设定20。频域滤波，低截频：1，高截频：500；道内均衡：无；反褶积：无；反射波提取：无。点击执行。

  ![image-20250520163105526](D:\notes\笔记Img\image-20250520163105526.png)

```cpp
/*
	* 陷波
	* Notch_jobs ：陷波时剔除50hz的奇偶倍数：0-50hz的整数倍，0-奇偶倍（整数倍）1-奇数倍 2-偶数倍 3-一倍
	* NotchWn ：陷波时剔除范围宽度（陷波带宽）
	* int NotchType :（陷波修正方法）处理类型，0-剔除赋值0，1-线性差值
	*/
void NotchFilter1dFD(float* pData, int dataLen, float deltT, int Notch_jobs, float NotchWn, int NotchType, int NotchFreq) 
{
    if (pData == nullptr || dataLen < 1) {
        return;
    }

    float smpFreq_cy = 1000.0f / deltT;  // 采样频率
    int transPt = GetNextPower2(dataLen);
    float smpFreq = smpFreq_cy / transPt;
    // int NotchFreq = 50;  // 初始陷波频率
    int notchEdgePt = static_cast<int>(NotchWn / smpFreq);

    std::unique_ptr<float[]> pRe(new float[transPt]());
    std::unique_ptr<float[]> pIm(new float[transPt]());

    std::copy(pData, pData + dataLen, pRe.get());
    DataFFT(pRe.get(), pIm.get(), transPt, true);

    std::vector<float> pCoef_notch(2 * notchEdgePt + 1);
    GenWindowSeries(pCoef_notch.data(), pCoef_notch.size(), WFF_HAMMING);

    for (int multiplier = 1; NotchFreq * multiplier < smpFreq_cy / 2; ++multiplier) {
        bool applyNotch = (Notch_jobs == 0) ||
            (Notch_jobs == 1 && multiplier % 2 == 1) || 
            (Notch_jobs == 2 && multiplier % 2 == 0) ||
            (Notch_jobs == 3 && multiplier == 1);
        if (!applyNotch) continue;

        int notchIdx = static_cast<int>(NotchFreq * multiplier / smpFreq);
        for (int pt = -notchEdgePt; pt <= notchEdgePt; ++pt) {
            int idx = std::clamp(notchIdx + pt, 0, transPt / 2);
            if (NotchType == 0) {  // 删除频率成分
                pRe[idx] = 0;
                pIm[idx] = 0;
            } else if (NotchType == 1) {  // 插值
                pRe[idx] *= pCoef_notch[notchEdgePt + pt];
                pIm[idx] *= pCoef_notch[notchEdgePt + pt];
            }
        }
    }

    for (int ipt = transPt / 2 + 1; ipt < transPt; ++ipt) {
        pRe[ipt] = pRe[transPt - ipt];
        pIm[ipt] = -pIm[transPt - ipt];
    }

    DataFFT(pRe.get(), pIm.get(), transPt, false);
    std::copy(pRe.get(), pRe.get() + dataLen, pData);
}
```



#### ⑤ 反褶积

![image-20250429155438319](D:\notes\笔记Img\image-2025042915543831971)

若启用滤波，则反褶积后，会再次进行滤波，且写死为带通滤波。

#### ⑥ 道内均衡

代码中所有保存道内均衡参数的类型：

```cpp
//PCOSignalProcess.hpp
struct PCOSignalParm
    
//ms_mining.hpp
struct PCODeAGC
```

| 道内均衡 | 用到的地方                                                   | 函数功能                                                    | 上层调用                                                     |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
|          | `ms_mining.cpp--getPCO_parm()`                               | 从库表读参数                                                |                                                              |
|          | `PCOSignalProcess.cpp--L241`，并行计算函数`ParallelCorrelation::operator()` | 实时计算                                                    | `ms_mining.cpp--handleSignalProcess()`                       |
|          |                                                              |                                                             |                                                              |
|          | `ms_mining.cpp--handleExtSignalData_pianyi()`                | 读取指定时间段内的提取文件（9），生成偏移文件（10）         | 被接口`/handerExtSignalPianYi/:from_time/:to_time`调用。     |
|          | `ms_mining.cpp--parseDeAGC()`                                | `parseDeAGC()`从`methods`中解析json格式的算法参数参与计算。 | 被接口`/handerExtSignal/:samp_time/:typeId`调用。调用`processMethods()`进行再提取计算，写文件到99。`processMethods()`中调用`parseDeAGC()` |
|          | `PCOSignalProcess.cpp--PureCommonOperation::handleSignalData` | ` PureCommonOperation::handleSignalData`执行再提取算法。    | 被接口`/handerExtSignalParm/:samp_time/:typeId`调用。`handerExtSignalParm`，调用`handleExtSignalData`，调用`PureCommonOperation::handleSignalData` |
|          |                                                              |                                                             |                                                              |
|          | `PCOSignalProcess.cpp--L3232，handleDataFrameVec_test()`     | 测试用                                                      | `ms_mining.cpp--handleSignalProcess_test()`                  |
|          |                                                              |                                                             |                                                              |
|          |                                                              |                                                             |                                                              |

* 指数增益：

  ![image-20250520163549425](D:\notes\笔记Img\image-20250520163549425.png)

  测试方法：选取提取图某个时间点（横坐标），查看所有通道的幅值，记录增益前的幅值。然后执行增益，再增益后的图中，相同时间点查看所有通道的幅值。比较点的幅值增大是不是符合`pData[i] *= expf(alpha * (i - ptBegId) * deltT_s)`关系。

  ![image-20250520164943164](D:\notes\笔记Img\image-20250520164943164.png)

  ![image-20250520165008364](D:\notes\笔记Img\image-20250520165008364.png)

#### ⑦ 道间均衡

![image-20250429155753889](D:\notes\笔记Img\image-2025042915575388981)

#### ⑧ 反射波提取

![image-20250429155950576](D:\notes\笔记Img\image-2025042915595057691)

计算结果存在`vtOutPut`中，`pcoParm.bNegtiveV`为提取类型：正速度/负速度。

![image-20250429164256173](D:\notes\笔记Img\image-202504291642561731)

把计算结果从`vtOutPut`拷贝到`tmp_out`（按照通道）

#### ⑨ 自相关谱图

* 原理：


```cpp
cout<<"11111"<<endl;
        /*
        *   自相关谱图：时域+自相关+正fft
        */
        bool generateSelfCorrSpectrum = true;//是否生成自相关谱图
        const int pOutSignalSize = valChnns * vecSize;
        auto myDeleter = [pOutSignalSize](float** ptr)
        {
            for(int chIndex=0;chIndex<pOutSignalSize;chIndex++)
            {
                delete[] ptr[chIndex];
            }
            delete[] ptr;
        };
        unique_ptr<float*[], decltype(myDeleter)> pOutSelfCorrSpectrum(new float*[pOutSignalSize], myDeleter);
        for(int chIndex=0;chIndex<pOutSignalSize;chIndex++)
        {
            pOutSelfCorrSpectrum[chIndex] = new float[pcoParm.outLen];
            memset(pOutSelfCorrSpectrum[chIndex], 0, sizeof(float)*pcoParm.outLen);
        }

       
        // if(generateSelfCorrSpectrum && pcoParm.extractMethod == 0 && pcoParm.CorrType == 0) //时域+自相关：干涉谱图，11类型
        if(false)
        {
            cout<<"22222"<<endl;
            //对时域自相关信号执行fft
            unique_ptr<float[]> pChDataR = make_unique<float[]>(pcoParm.outLen);//暂存一个通道的数据
            unique_ptr<float[]> pChDataI = make_unique<float[]>(pcoParm.outLen);

            for(int dex=0;dex<vecSize;dex++)
            {
                cout<<"vecsize="<<dex<<endl;

                for(int ch=0;ch<valChnns;ch++)
                {
                    cout<<"ch="<<ch<<endl;

                    memset(pChDataR.get(), 0, sizeof(float)*pcoParm.outLen);
                    memset(pChDataI.get(), 0, sizeof(float)*pcoParm.outLen);
                    memcpy(pChDataR.get(), pOutSignal[ch + dex*valChnns], sizeof(float)*pcoParm.outLen);
                    PureCommonOperation::DataFFT(pChDataR.get(), pChDataI.get(), pcoParm.outLen, true);
                    for(int pt=0;pt<pcoParm.outLen;pt++)
                    {
                        // float frequencyPt = pt / deltT * pcoParm.outLen;  //横轴-频率：k*采样频率/采样点数
                        float AmplitudePt = sqrt(safePow(pChDataR[pt], 2) + safePow(pChDataI[pt], 2));//纵轴-幅值:实部虚部平方和的平方根
                        pOutSelfCorrSpectrum[ch+dex*valChnns][pt] = AmplitudePt;
                    }
                }
            }

            
            // 保存自相关谱图
            //  构造11文件头
            classId2 = 11;
            *(uint8_t*)(pHead2 + 8) = classId2;    //同类型9相比，文件头除了classId不同其他均相同

            auto conn21 = hzi::config.pConnPool->getConnection();
            conn21.execute(
                "INSERT INTO "
                "e_mining_selfcorrdata_frm_info "
                "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
                "loc,fx,fy,fz,dis)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
                "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
                (uint8_t)devId,  // dev_id
                tmStmp / 1000.0, // samp_time
                classId2,        // class_id
                deltT,           // curt_ch
                valNum,          // channels
                vecSize,
                pcoParm.outLen, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp)).c_str(), // frm_loc
                pcoLocParm.fx,
                pcoLocParm.fy,
                pcoLocParm.fz,
                pcoLocParm.dis_y);

            cout<<"33333"<<endl;

            fs::path outClassId11FileName(hzi::config.dataRoot);
            outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                                 std::to_string(tmStmp);
            try
            {
                auto dir = outClassId11FileName.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(outClassId11FileName, std::ofstream::binary);
                ofs_Signal.write(pHead2, 32);
                for (int dex = 0; dex < vecSize; dex++)
                {
                    for (int ch = 0; ch < valChnns; ++ch)
                    {
                        // if (!pcoCalChnParms[ch].enb)
                        //     continue;

                        int32_t* p32SelfCorrSpectrumEachChn = reinterpret_cast<int32_t*>(pOutSelfCorrSpectrum[ch+dex*valChnns]);
                        ofs_Signal.write((char*)p32SelfCorrSpectrumEachChn, pcoParm.outLen * 4);
                    }
                }
                ofs_Signal.close();
                cout<<"44444"<<endl;
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += outClassId11FileName.string();
                msg += ":";
                msg += e.what();
                if (hzi::config.verbose)
                    cout << "msg = " << msg << endl;
                debugErr(msg);
                return "error";
            };
        }
```

### ※写9类型数据文件

>  [!NOTE]
>
> 没有函数，而是下面这段代码。
>
> `pOutSignal`中保存提取+再提取数据，写入到文件。
>
> 调用`ofstream::write()`写入数据，默认的打开模式是 `std::ios::out`，它会清空文件内容并从头开始写入。
>
> > - 如果文件 `fileName` 已经存在，文件的内容会被清空。
> > - 如果文件不存在，会创建一个新文件。

```cpp
// 写9类型文件
if (hzi::config.ms_miningSignal)//配置文件中字段
{
    // auto pretime = 0;
    
    //文件头pHead2
    unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
    char *pHead2 = pHeadData2.get();
    *(double *)(pHead2) = (double)tmStmp;	//第一炮数据的第一个数据文件的采样时间
    
    auto classId2 = 9;	// 19 代表随采，9是随掘
    // auto classId2 = (hzi::config.ms_mining_type == 1) ? 19 : 9;
    *(uint8_t *)(pHead2 + 8) = classId2;
    *(float *)(pHead2 + 9) = deltT;
    *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
    *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
    *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
    *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
    *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
    if (hzi::config.ms_mining_type == 1)	//随采
    {
        *(uint8_t *)(pHead2 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
        *(uint8_t *)(pHead2 + 29) = pcoParm.ImageType;   //'随采成像方式:0-散射，1-透射，2-爆炸成像'
    }
    
    //9文件路径入库表e_mining_signaldata_frm_info
    auto conn21 = hzi::config.pConnPool->getConnection();
    conn21.execute(
        "INSERT INTO "
        "e_mining_signaldata_frm_info "
        "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
        "loc,fx,fy,fz,dis)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
        "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
        (uint8_t)devId,  // dev_id
        tmStmp / 1000.0, // samp_time
        classId2,        // class_id
        deltT,           // curt_ch
        valNum,          // channels
        vecSize,
        pcoParm.outLen, // ch_pnts
        (relLocFromTime(tmStmp) / std::to_string(classId2) /
         std::to_string(tmStmp))
        .c_str(), // frm_loc
        pcoLocParm.fx,
        pcoLocParm.fy,
        pcoLocParm.fz,
        pcoLocParm.dis_y);

    //写文件
    fs::path outSignalfileName(hzi::config.dataRoot);
    outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp);
    try
    {
        auto dir = outSignalfileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
        //写文件头到文件
        ofs_Signal.write(pHead2, 32);	
        //写数据到文件
        for (int dex = 0; dex < vecSize; dex++)//vecSize为炮数
        {
            for (int ch = 0; ch < valChnns; ++ch)//valChnns为通道数，在setSignalChnInfo里赋值的
            {
                //数据体p32Signal
                int32_t *p32Signal = (int32_t *)pOutSignal[ch + dex * valChnns];
                // if (!pcoCalChnParms[ch].enb)
                //     continue;
                ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
            }
        }
        ofs_Signal.close();
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += outSignalfileName.string();
        msg += ":";
        msg += e.what();
        if (hzi::config.verbose)
            cout << "msg = " << msg << endl;
        debugErr(msg);
        return "error";
    };
}
```

### ※计算偏移图数据

>  [!NOTE]
>
> * `PureCommonOperation::CalMigration()`

### ※保存偏移图文件

> [!NOTE]
>
> * 函数`saveResult()`中保存
>
> * 10的数据存在`pOut`。
>
>   为了`outType`可指定【偏移图】或【反射界面输出】，调用`PureCommonOperation::ReflactPlane`，进行反射提取。`pOut`中数据经过反射波提取，数据存于`pOut_2`。
>
> * 异常提取：通过fg判断是否进行异常提取。调用函数`saveLine()`
>
> * 截取偏移图数据，将`pOut`数据处理后存于`pOut_0`
>
> * 插入库表，保存偏移图数据文件路径
>
> * 调用`ofstream::write()`写入数据，默认的打开模式是 `std::ios::out`，它会清空文件内容并从头开始写入。
>
>   > - 如果文件 `fileName` 已经存在，文件的内容会被清空。
>   > - 如果文件不存在，会创建一个新文件。
>
> * 调用`writeSvg(pOut_0)`保存svg文件（配置文件）

```cpp
/*
* 保存偏移图的10类型数据文件
* fg：是否是实时计算，历史计算异常不提取结果。从偏移数据，提取异常调用函数saveLine()
* typeId：用于分量类型 0-X 1-Y 2-Z
* outType：输出类型，0-偏移图 1-反射界面输出
*/
bool saveResult(uint64_t tmStmp,
                int devId,
                int iGrdNum,
                PureCommonOperation::PCOLocParm pcoLocParm,
                float *&pOut,
                int typeId,
                bool fg, bool outType)
{
    bool flag = false;

    auto conn = hzi::config.pConnPool->getConnection();

    if (hzi::config.ms_mining_type == 2)
    { 
        // hzi::config.ms_mining_type == 2
        // 异常提取

        std::unique_ptr<float[]> pOut_2(new float[iGrdNum]);
        memset(pOut_2.get(), 0, sizeof(float) * iGrdNum);

        std::vector<PureCommonOperation::ELINE> lineVec;
        int flNum = 1;
        PureCommonOperation::EXTRACTPARA m_extractPara;
        m_extractPara.Reset();

        auto rslt_ext = conn.executeQuery(
            "SELECT * FROM e_tunnel_extractPara WHERE is_init = 0");
        if (!rslt_ext)
        {
            std::cerr << "Query returned no results." << std::endl;
            //  return;
        }
        if (rslt_ext.next())
        {
            m_extractPara.fAmpleScale = rslt_ext.getDouble("fAmpleScale");
            m_extractPara.fOverlapScale = rslt_ext.getDouble("fOverlapScale");
            m_extractPara.iMaxPlanes = rslt_ext.getInt("iMaxPlanes");
            m_extractPara.bExtAmple = rslt_ext.getInt("bExtAmple");
            m_extractPara.bExtNum = rslt_ext.getInt("bExtNum");
            m_extractPara.iAmpExtType = rslt_ext.getInt("iAmpExtType");
            m_extractPara.iNumExtType = rslt_ext.getInt("iNumExtType");
            m_extractPara.inputMaxEng = rslt_ext.getDouble("inputMaxEng");
        }

        //pOut中数据经过反射波提取，数据存于pOut_2
        PureCommonOperation::ReflactPlane(pOut, pOut_2.get(), flNum, &pcoLocParm,
                                          m_extractPara, &lineVec);

        //若成图：反射界面图，则把pOut_2拷贝到pOut。
        //若成图：偏移图，不拷贝，直接用pOut中数据进行后续写文件操作。
        if (outType)
        {
            memcpy(pOut, pOut_2.get(), sizeof(float) * iGrdNum);
        }

        float gLen = (pcoLocParm.m_dYGrdLen > pcoLocParm.m_dZGrdLen)
                         ? pcoLocParm.m_dYGrdLen
                         : pcoLocParm.m_dZGrdLen;
        if (hzi::config.verbose)
        {
            cout << "当前回采位置： " << pcoLocParm.m_locx
                 << " Y/Z 精度：" << gLen << ";异常提取结果：" << endl;
            for (int i = 0; i < lineVec.size(); i++)
            {
                // 先按照X Y 面计算

                cout << "   第 " << i + 1 << "个：起点坐标：(" << lineVec[i].fBeginTime << ","
                     << lineVec[i].nBeginTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fBeginTime << " ; " << lineVec[i].fXPos << " ; "
                     << "终点坐标:(" << lineVec[i].fEndTime << ","
                     << lineVec[i].nEndTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fEndTime << "; " << lineVec[i].fEndTime << endl;
            }
        }

        //异常提取
        if (fg)
        {
            saveLine(tmStmp, lineVec, pcoLocParm, fg);
        }
    }

    int XGrdNum =
        int(pcoLocParm.mark_len / pcoLocParm.m_dXGrdLen);
    int YGrdNum = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_iZGrdNum : pcoLocParm.m_iYGrdNum;

    auto iGrdNum_out =
        XGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    std::unique_ptr<float[]> pOut_0(new float[iGrdNum_out]);
    memset(pOut_0.get(), 0, sizeof(float) * iGrdNum_out);
    cout << "pcoLocParm.m_dir = " << pcoLocParm.m_dir << ",XGrdNum = " << XGrdNum << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
         << ",YGrdNum = " << YGrdNum << endl;
    // 截取偏移图数据
    for (int j = 0; j < YGrdNum; ++j)
    {
        for (int k = 0; k < pcoLocParm.m_iXGrdNum; ++k)
        {
            if (pcoLocParm.m_dir == 0)
            {
                // 取后面的数据
                if (k >= pcoLocParm.m_iXGrdNum - XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k - pcoLocParm.m_iXGrdNum + XGrdNum;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
            else
            {
                if (k < XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
        }
    }
    float minpOut = *std::min_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    float maxpOut = *std::max_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    // 有异常的位置拉起来能量
    cout << " XGrdNum = " << XGrdNum << " m_iYGrdNum = " << pcoLocParm.m_iYGrdNum << " pcoLocParm.m_iZGrdNum = " << pcoLocParm.m_iZGrdNum << endl;

    float dX = pcoLocParm.m_dXGrdLen;
    float dY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZGrdLen : pcoLocParm.m_dYGrdLen;
    float minY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZMin : pcoLocParm.m_dYMin;
    //  cout<<"dX =  "<<dX<<",dy= "<<dY<<",minY = "<<minY<<endl;

    int32_t *p32 = (int32_t *)pOut_0.get();
    unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
    char *pHead = pHeadData.get();
    *(double *)(pHead) = (double)tmStmp;
    auto classId = *(uint8_t *)(pHead + 8) = 10;//classid置10，偏移图
    *(uint8_t *)(pHead + 9) = devId;
    *(uint16_t *)(pHead + 10) = XGrdNum;
    // *(uint16_t*)(pHead + 10) = pcoLocParm.m_iXGrdNum;
    *(uint16_t *)(pHead + 12) = pcoLocParm.m_iYGrdNum;
    *(uint16_t *)(pHead + 14) = pcoLocParm.m_iZGrdNum;
    *(int32_t *)(pHead + 16) = *((int32_t *)&minpOut);
    *(int32_t *)(pHead + 20) = *((int32_t *)&maxpOut);
    *(int32_t *)(pHead + 24) = *((int32_t *)&dX);

    // auto conn3 = hzi::config.pConnPool->getConnection();
    
    
    /*
    * 插入库表，保存偏移图数据文件路径
    */
    conn.execute(
        "INSERT INTO "
        "e_mining_pcodata_frm_info "
        "(dev_id,samp_time,class_id,XGrdNum,YGrdNum,ZGrdNum,frm_loc)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE XGrdNum= values(XGrdNum),YGrdNum= "
        "values(YGrdNum)",
        (uint8_t)devId,        // dev_id
        tmStmp / 1000.0,       // samp_time
        classId,               // class_id
        XGrdNum,               // curt_ch  pcoLocParm.m_iXGrdNum XGrdNum
        pcoLocParm.m_iYGrdNum, // channels
        pcoLocParm.m_iZGrdNum, // ch_pnts
        (relLocFromTime(tmStmp) / std::to_string(classId) /
         std::to_string(tmStmp))
            .c_str() // frm_loc
    );

    
    /*
    * 写到文件
    */
    auto classId2 = (typeId == 0) ? 10 : (100 + typeId);//单分量文件名类型写10，多分量写100+typeId

    //10类型文件文件名
    fs::path fileName(hzi::config.dataRoot);
    fileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                std::to_string(tmStmp);

    //写10类型文件
    try
    {
        auto dir = fileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs(fileName, std::ofstream::binary);
        ofs.write(pHead, 32);
        ofs.write((char *)p32, iGrdNum_out * 4);
        //  ofs.write((char*)p32, iGrdNum * 4);
        ofs.close();
        flag = true;
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += fileName.string();
        msg += ":";
        msg += e.what();
        debugErr(msg);
        cout << msg << endl;
        return flag;
    };

    //配置文件中读取字段，是否保存偏移图svg文件到目录下
    if (hzi::config.ms_rslt_to_image)
    {
        //   cout<<" writeSvg "<<minpOut<<" , "<<maxpOut<<endl;
        string path = fileName.string() + ".svg";

        if (std::filesystem::exists(path))
        {
            fs::remove(path);
        }
        writeSvg(path, pOut_0.get(), XGrdNum, YGrdNum, dX, dY, pcoLocParm.m_dXMin, minY);
        //  cout<<" end writeSvg "<<path <<endl;
    }
    return flag;
}
```

### ※异常提取



## （2）历史重算代码流程

> [!IMPORTANT]
>
> 重算所得文件名（时间戳）入库表`e_mining_pcodata_frm_info`。
>
> | 用到的接口                                           | 功能                                                         |
> | ---------------------------------------------------- | ------------------------------------------------------------ |
> | `/handerSignal/:from_time/:to_time/:time_len/:devId` | 只提取+偏移，写文件9和10                                     |
> | `/handerExtSignalParm/:samp_time/:typeId`            | 读9文件，执行再提取算法流程，写99文件。进行偏移计算，写10文件。 |
> 
>* 调用链：
> 
>  ```cpp
>   handerSignalProcess<--/handerSignal/:from_time/:to_time/:time_len/:devId
>   
>                                                                                           setPCOLocParm,setPCOCalChn,setSignalChnInfo,<--processMethods<--handerExtSignal<-- /handerExtSignal/:samp_time/:typeId
>   
>                                                                                             getPCO_parm,setPCOLocParm,setPCOCalChn,setSignalChnInfo,handleSignalData<--handleExtSignalData
>       <--/handerExtSignalParm/:samp_time/:typeId,/handerExtSignalPianYi/:from_time/:to_time
>  ```
> 

### 点击【干涉源提取】

只做提取，这一步**只显示【提取图+偏移图】（只做提取基础上的偏移图）**

使用左侧页面【干涉源提取】条目下的参数，提取信号。

依次调用接口：

```cpp
//handerSignal/1743789660000/1743789720000/1/0
/handerSignal/:from_time/:to_time/:time_len/:devId
ms_commands.cpp
    
handerSignalProcess()
    
调用`mergeMs`拼帧
调用`handleSignalProcess(false)`只提取+偏移，写文件9和10，返回的时间戳作为response

//table/e_mining_pcodata_frm_info/frm_loc:str/class_id=10 order by samp_time
/table/:tblName/:cols/:where?


//data_file/2025/4/5/9/1743789665000
/data_file/:year/:month/:day/:type/:timestamp
获取9文件


//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id = 0
type_id前有个/没找到这个接口

//data_file/2025/4/5/99/1743789665000
/data_file/:year/:month/:day/:type/:timestamp  
获取99文件（注意：如果该99文件存在的话，也就是这个时间已经点击过执行做过再提取的话，就会有99。若是第一次进行历史重算就没有，会返回204 No Content）


//getLocInfo/1743789665000/mark_XLen,mining_locx,mining_dir,dXGrdLen,dYGrdLen
/getLocInfo/:timestamp/:cols


//data_file/2025/4/5/10/1743789665000
/data_file/:year/:month/:day/:type/:timestamp
获取10文件
```

### 点击【保存】

```cpp
//POST：config/e_mining_PCOSignalParm_history

//POST：update_columns/e_mining_PCOLocParm/1=1

//POST：config/e_tunnel_extractPara
```

### 点击【执行】

> [!IMPORTANT]
>
> * 偏移图不显示：配置文件`ms_mining_type`没有或为0，导致接口`/ms_mining`返回false，从而不渲染偏移图。
> * 

会先执行【保存】。

使用左侧设定参数，在提取文件的基础上，进行再提取。显示【提取图+再提取图+偏移图（提取+再提取上的偏移图）】

根据设定好的计算参数对当前选中时间戳的提取数据，进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`，并在再提取数据和再提取波形图的基础上，得到新的偏移图（提取+再提取的偏移图）。

会调用接口：

```cpp
//POST：config/e_mining_PCOSignalParm_history
//payload为页面左侧设定的参数值
//写参数到库表
/config/:tblName
    
//POST：update_columns/e_mining_PCOLocParm/1=1
//payload为e_mining_PCOLocParm中要更新的参数
/update_columns/:tblName/:condition

//POST：config/e_tunnel_extractPara
//payload为e_tunnel_extractPara中更新参数
/config/:tblName

//POST：/handerExtSignalParm/1747152060100/9
/handerExtSignalParm/:samp_time/:typeId

handerExtSignalParm()
    
调用`handleExtSignalData()`，typeId传文件类型9，读取9类型文件。

调用`PureCommonOperation::handleSignalData()`进行信号处理
    
读9文件数据保存到pData。
调用`PureCommonOperation::handleSignalData(pData, pOutSignal)`，pData数据经过处理得到再提取数据存于pOutSignal。
调用`PureCommonOperation::CalMigration()`把pOutSignal数据进行偏移计算，存于pOut_tmp。
调用`saveResult(pOut_tmp)`保存偏移图文件10。
pOutSignal中数据写文件到99。



//data_file/2025/5/14/99/1747152060100
获取99文件。

//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//getLocInfo/1747152060100/mark_XLen%2Cmining_locx%2Cmining_dir%2CdXGrdLen%2CdYGrdLen

//data_file/2025/5/14/10/1747152060100
获取10文件。

//table/e_tunnel_imgSetting/ampScale,scaleRatio

//data_file/2025/5/14/101/1747152060100
获取101文件？

//data_file/2025/5/14/102/1747152060100
获取102文件？
```

### ※保存99数据类型

* 接口：`/handerExtSignalParm`（点击【执行】）
* 接口：`/handerExtSignal`（没遇到过）

```cpp
auto classId2 = 99;
```

### 点击【同步】

将表`e_mining_PCOSignalParm`参数覆盖到表`e_mining_PCOSignalParm_history`。

```cpp
//POST：config/e_mining_PCOSignalParm_history

//POST：update_columns/e_mining_PCOLocParm/1=1

//POST：config/e_tunnel_extractPara

//POST：config/e_mining_PCOSignalParm
```

### 点击【树形图】

```cpp
//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//data_file/2025/5/14/99/1747152060100
获取99文件

//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//getLocInfo/1747152060100/mark_XLen%2Cmining_locx%2Cmining_dir%2CdXGrdLen%2CdYGrdLen

//data_file/2025/5/14/10/1747152060100
获取10文件

//table/e_tunnel_imgSetting/ampScale,scaleRatio

//data_file/2025/5/14/101/1747152060100

//data_file/2025/5/14/102/1747152060100
```

# 16. 信号处理算法

---

## （1）相关计算

```cpp
//swt_extract_interfere.hpp

#ifndef MS_TUNNEL_EXTRACT_INTERFERE_SIGNAL_HPP
#define MS_TUNNEL_EXTRACT_INTERFERE_SIGNAL_HPP
//随掘干涉源信号提取

#include <iostream>
#include <string>
#include "DataFrame.hpp"
#include "ms_tracemanager.hpp"
using namespace std;

namespace ms_swt
{
    string ExtractInterfeSingal(MSTraceMgr& xcorrData, MSTraceMgr&acorrData, uint64_t fromTimeMs, uint64_t toTimeMs,int lineId = 1,bool isRealtimeExt=false);
    string ExtractInterfeSingal(MSTraceMgr& xcorrData, uint64_t fromTimeMs, uint64_t toTimeMs,int lineId = 1,bool isRealtimeExt=false);
    string ExtractInterfeSingal(uint64_t fromTimeMs, uint64_t toTimeMs,int lineId = 1,bool isRealtimeExt=false);

};//namespace

#endif//MS_TUNNEL_EXTRACT_INTERFERE_SIGNAL_HPP
```

```cpp
//swt_extract_interfere.cpp

#include "swt_extract_interfere.hpp"
#include "common.hpp"
#include "Config.hpp"
#include "tl/expected.hpp"
#include "swt_common.hpp"
#include "algorithms/msl/PCOSignalProcess.hpp"
#include "swt_signal_merge.hpp"
#include "QfxFileHead.hpp"
#include <syncstream>

namespace ms_swt
{
    //干涉提取计算参数
    struct InterfeCalParam
    {
        bool doCorrBoth = true; //同时提取自相关和互相关
        float minTimeLen = 30;  //s

        int dcType = 0; //源数据预处理方式:零漂,1B,归一
        bool isShaping = false;     //是否塑形
        float shapingRato = 0.15;   //塑型比例
        int coefChnId = 0;  //因子通道号
        int coefPoint = 0;  //因子点数(由时长反算)
        int outPoint = 0;   //相关结果输出点数
        int coefBegPt = 0;  //相关结果超前点数,即因子超前起始位置
        int biasedType = 0; //偏置类型 （有 无）参考BiasType
        int corrType = 0;   //相关类型,自相关或互相关
        int corrCalWay = 0; //时域还是频域
        float coefTimeLen = 120;    //因子时长s
    };
    struct ChnInfo
    {
        int devId = 0;
        int chnId = 0;
        int trcId = 0;
        float x;
        float y;
        float z;
        bool enb = true;
    };
    std::vector<ChnInfo> vtChnInfo;

    string GetInterfeParam(InterfeCalParam& param,uint64_t datTimestmp,bool isRealtime)
    {
        string ret = "";
        auto conn = hzi::config.pConnPool->getConnection();
        string sqlstr;
        if (isRealtime)
        {
            sqlstr = "SELECT * FROM `e_mining_PCOSignalParm`";
        }
        else
        {
            sqlstr = "SELECT * FROM `e_mining_PCOSignalParm_history`";
        }

        auto rslt = conn.executeQuery(sqlstr.c_str());
        if (rslt.next())
        {
            param.dcType = rslt.getInt("dcType");
            param.isShaping = rslt.getInt("isShaping");
            param.shapingRato = rslt.getDouble("shapingRato");
            param.coefChnId = rslt.getInt("chn_no");
            param.coefTimeLen = rslt.getInt("coeLen")*60;
            param.outPoint = rslt.getInt("outLen");
            param.coefBegPt = rslt.getInt("coefBegPt");
            param.biasedType = rslt.getInt("biased");
            param.corrType = rslt.getInt("extractMethod");
            param.corrCalWay = rslt.getInt("CorrType");
        }
        else
        {
            ret = "提取参数为空";
        }

        //..通道坐标
        if (datTimestmp>0)
        {
            sqlstr = "WITH RankedUpdates AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY chn_no ORDER BY updatetime DESC) AS rn FROM e_chns_config_history "
                "WHERE updatetime < FROM_UNIXTIME(?) AND type_id=(?)) SELECT * FROM RankedUpdates WHERE rn = 1";
            auto rslt1 = conn.executeQuery(sqlstr.c_str(), (double)datTimestmp/1000.0, 0);
            vtChnInfo.clear();
            while(rslt1.next())
            {
                ChnInfo ci;
                ci.devId = rslt1.getInt("dev_id");
                ci.chnId = rslt1.getInt("chn_no");
                ci.enb = (rslt1.getInt("state_id")==0);
                ci.x = rslt1.getDouble("loc_x");
                ci.y = rslt1.getDouble("loc_y");
                ci.z = rslt1.getDouble("loc_z");
                vtChnInfo.push_back(ci);
            }
        }

        if(vtChnInfo.size()==0)
            ret="时间段内无历史通道信息";
        return ret;
    }

    string SaveXcorrData(DataFrame& df)
    {
        string msg = "";
        uint64_t tmStmp = df.sampTime();
        int chns = ms_swt::GetChannels(df);
        int points = ms_swt::GetPoints(df);
        int devId = *(uint8_t*)(df.upHead.get()+27);
        int classId = df.classId();
        float deltT = ms_swt::GetDataDeltT(df);
        auto conn = hzi::config.pConnPool->getConnection();
        fs::path outClassId11FileName(hzi::config.dataRoot);

        try
        {
            conn.execute(
                "INSERT INTO "
                "e_mining_signaldata_frm_info "
                "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_loc,"
                "fx,fy,fz,dis)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
                "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
                devId,  // dev_id
                tmStmp / 1000.0, // samp_time
                classId,        // class_id
                deltT,
                chns,          // channels
                1,
                points, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId) / std::to_string(tmStmp)).c_str(), // frm_loc
                0,
                0,
                0,
                0);
            outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId) / std::to_string(tmStmp);
            auto dir = outClassId11FileName.parent_path();
            if (!fs::exists(dir))
            {
                fs::create_directories(dir);
            }
            std::ofstream ofs_Signal(outClassId11FileName, std::ofstream::binary);
            ofs_Signal.write(df.upHead.get(), 32);
            ofs_Signal.write(df.upData.get(),chns*points*4);
            ofs_Signal.close();
        }
        catch (std::exception &e)
        {
            msg = "保存互相关结果文件失败";
            string errmsg = msg + outClassId11FileName.string() + ":"+e.what();
            if (hzi::config.verbose)
                cout << "errmsg = " << errmsg << endl;
            logErr(errmsg);
        }

        return msg;
    }

    /**
     * @brief 一个通道数据的相关计算
     * @param p32DataOneChn 待计算相关的通道数据
     * @param p32CoefOneChn 因子道数据
     */
    bool CorrOneChn(int32_t* p32DataOneChn, int32_t* p32CoefOneChn, DataFrame& dfIntfe, InterfeCalParam& calPara, int points, int ch)
    {
        try
        {
            thread_local int32_t *p32 = nullptr;
            thread_local std::unique_ptr<float[]> pCoef = std::make_unique<float[]>(points);
            thread_local std::unique_ptr<float[]> pTmpData = std::make_unique<float[]>(points);
            thread_local std::unique_ptr<float[]> pCorrData = std::make_unique<float[]>(calPara.outPoint);

            //因子道数据
            p32 = p32CoefOneChn;
            for (int i = 0; i < points; i++)
            {
                pCoef[i] = (p32[i] * hzi::config.voltageCoef);
            }
            PureCommonOperation::DataCorrect(pCoef.get(), points, calPara.dcType);

            //待相关通道数据
            p32 = p32DataOneChn;
            for (int i = 0; i < points; i++)
            {
                pTmpData[i] = (p32[i] * hzi::config.voltageCoef);
            }
            PureCommonOperation::DataCorrect(pTmpData.get(), points, calPara.dcType);
            if (calPara.corrCalWay == 0)
            {
                PureCommonOperation::CorrTD(pTmpData.get(), points, pCoef.get(), points, pCorrData.get(), calPara.outPoint, calPara.coefBegPt, calPara.biasedType);
            }
            else
            {
                PureCommonOperation::CorrFD(pTmpData.get(), points, pCoef.get(), points, pCorrData.get(), calPara.outPoint, calPara.coefBegPt, calPara.biasedType);
            }
            memcpy(dfIntfe.upData.get() + ch * calPara.outPoint * 4, (char *)(pCorrData.get()), calPara.outPoint * 4);

            return true;
        }
        catch(const std::exception& e)
        {
            logErr(string("xcorrOneChn:")+e.what());
            return false;
        }
    }

    /**
     * @brief 互相关
     */
    tl::expected<DataFrame, string> ProcDataXcorr(InterfeCalParam& calPara, DataFrame& dfRaw)
    {
        int chns = dfRaw.channels();
        int points = dfRaw.points();
        float deltT = dfRaw.sampIntvl();
        //基于互相关计算干涉信号
        DataFrame dfIntfe(chns,calPara.outPoint);
        dfIntfe.setHeadValue<double>(0,(double)dfRaw.sampTime());
        dfIntfe.setHeadValue<uint8_t>(8,SwtDataFrameType::CorrItfe);//class_id
        dfIntfe.setHeadValue<float>(9,deltT);
        dfIntfe.setHeadValue<int>(13,chns);         //通道总数
        dfIntfe.setHeadValue<short>(17,1);          //组数
        dfIntfe.setHeadValue<int32_t>(19,calPara.outPoint);
        dfIntfe.setHeadValue<int>(23,calPara.coefBegPt);
        dfIntfe.setHeadValue<uint8_t>(27,0x01);      //devId

        int32_t* p32 = nullptr;
        std::unique_ptr<float[]> pCoef = std::make_unique<float[]>(points);
        std::unique_ptr<float[]> pTmpData = std::make_unique<float[]>(points);
        std::unique_ptr<float[]> pCorrData = std::make_unique<float[]>(calPara.outPoint);

        // ..因子数据
        // p32 = dfRaw.pChnData(calPara.coefChnId-1);
        // for (int i = 0; i < points; i++)
        // {
        //     pCoef[i] = (p32[i]*hzi::config.voltageCoef);
        // }
        // PureCommonOperation::DataCorrect(pCoef.get(),points,calPara.dcType);

        // // ..计算互相关
        // for (int ch = 0; ch < chns; ch++)
        // {
        //     p32 = dfRaw.pChnData(ch);
        //     for (int i = 0; i < points; i++)
        //     {
        //         pTmpData[i] = (p32[i]*hzi::config.voltageCoef);
        //     }
        //     PureCommonOperation::DataCorrect(pTmpData.get(),points,calPara.dcType);
        //     if (calPara.corrCalWay == 0) {
        //         PureCommonOperation:: CorrTD(pTmpData.get(), points, pCoef.get(), points, pCorrData.get(), calPara.outPoint, calPara.coefBegPt, calPara.biasedType);
        //     }
        //     else {
        //         PureCommonOperation:: CorrFD(pTmpData.get(), points, pCoef.get(), points, pCorrData.get(), calPara.outPoint, calPara.coefBegPt, calPara.biasedType);
        //     }
        //     memcpy(dfIntfe.upData.get() + ch * calPara.outPoint * 4, (char*)(pCorrData.get()), calPara.outPoint * 4);
        // }


        std::vector<std::jthread> ths;
        std::vector<std::future<bool>> futs;
        std::atomic<float> sumProgress = 0.0;
        int32_t*  p32CoefOneChn = dfRaw.pChnData(calPara.coefChnId - 1);//因子道
        for(int ch = 0; ch < chns; ++ch)
        {
            std::packaged_task<decltype(CorrOneChn)> xcorrOneChnTask(CorrOneChn);            
            auto fut = xcorrOneChnTask.get_future();
            futs.push_back(std::move(fut));
            int32_t*  p32DataOneChn = dfRaw.pChnData(ch);
            ths.emplace_back(std::move(xcorrOneChnTask), p32DataOneChn, p32CoefOneChn, std::ref(dfIntfe), std::ref(calPara), points, ch);
        }
        for(auto& fut:futs)
        {
            if(!fut.get())
            {
                return tl::make_unexpected("互相关计算失败");
            }
        }


        //保存互相关结果到文件
        string msg = SaveXcorrData(dfIntfe);
        if (!msg.empty())
        {
            return tl::make_unexpected(msg);
        }
        return dfIntfe;
    }

    /**
     * @ 保存自相关结果到文件11
     */
    string SaveAcorrData(DataFrame& df)
    {
        string msg = "";
        uint64_t tmStmp = df.sampTime();
        int chns = ms_swt::GetChannels(df);
        int points = ms_swt::GetPoints(df);
        int devId = *(uint8_t*)(df.upHead.get()+27);
        int classId = df.classId();
        float deltT = ms_swt::GetDataDeltT(df);
        auto conn = hzi::config.pConnPool->getConnection();
        fs::path outClassId11FileName(hzi::config.dataRoot);
        try
        {
            conn.execute(
                "INSERT INTO "
                "e_mining_selfcorrdata_frm_info "
                "(dev_id,samp_time,class_id,frequency_resolution,valNum,vecSize,outLen,frm_loc,"
                "fx,fy,fz,dis)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE frequency_resolution= values(frequency_resolution),valNum= "
                "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
                devId,  // dev_id
                tmStmp / 1000.0, // samp_time
                classId,        // class_id
                deltT,
                chns,          // channels
                1,
                points, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId) / std::to_string(tmStmp)).c_str(), // frm_loc
                0,
                0,
                0,
                0);
            outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId) / std::to_string(tmStmp);
            auto dir = outClassId11FileName.parent_path();
            if (!fs::exists(dir))
            {
                fs::create_directories(dir);
            }
            std::ofstream ofs_Signal(outClassId11FileName, std::ofstream::binary);
            ofs_Signal.write(df.upHead.get(), 32);
            ofs_Signal.write(df.upData.get(),chns*points*4);
            ofs_Signal.close();
        }
        catch (std::exception &e)
        {
            msg = "保存自相关文件失败";
            string errmsg = msg + outClassId11FileName.string() + ":" + e.what();
            if (hzi::config.verbose)
                cout << "errmsg = " << errmsg << endl;
            logErr(errmsg);
        }

        return msg;
    }

    /**
     * @brief 自相关
     */
    tl::expected<DataFrame, string> ProcDataAcorr(InterfeCalParam& calPara, DataFrame& dfRaw)
    {
        int chns = dfRaw.channels();
        int points = dfRaw.points();
        float deltT = dfRaw.sampIntvl();
        DataFrame dfIntfe(chns,calPara.outPoint);
        dfIntfe.setHeadValue<double>(0,(double)dfRaw.sampTime());
        dfIntfe.setHeadValue<uint8_t>(8,SwtDataFrameType::AcorrItfe);
        dfIntfe.setHeadValue<float>(9,deltT);
        dfIntfe.setHeadValue<int>(13,chns);
        dfIntfe.setHeadValue<short>(17,1);
        dfIntfe.setHeadValue<int32_t>(19,calPara.outPoint);
        dfIntfe.setHeadValue<int>(23,calPara.coefBegPt);
        dfIntfe.setHeadValue<uint8_t>(27,0x01);

        int32_t* p32 = nullptr;
        std::unique_ptr<float[]> pCoef = std::make_unique<float[]>(points);
        std::unique_ptr<float[]> pCorrData = std::make_unique<float[]>(calPara.outPoint);


        // for (int ch = 0; ch < chns; ch++)
        // {
        //     p32 = dfRaw.pChnData(ch);
        //     for (int i = 0; i < points; i++)
        //     {
        //         pCoef[i] = (p32[i]*hzi::config.voltageCoef);
        //     }
        //     PureCommonOperation::DataCorrect(pCoef.get(),points,calPara.dcType);
        //     if (calPara.corrCalWay == 0) {
        //         PureCommonOperation:: CorrTD(pCoef.get(), points, pCoef.get(), points, pCorrData.get(), calPara.outPoint, calPara.coefBegPt, calPara.biasedType);
        //     }
        //     else {
        //         PureCommonOperation:: CorrFD(pCoef.get(), points, pCoef.get(), points, pCorrData.get(), calPara.outPoint, calPara.coefBegPt, calPara.biasedType);
        //     }
        //     memcpy(dfIntfe.upData.get() + ch * calPara.outPoint * 4, (char*)(pCorrData.get()), calPara.outPoint * 4);
        // }


        std::vector<std::jthread> ths;
        std::vector<std::future<bool>> futs;
        std::atomic<float> sumProgress = 0.0;
        for (int ch = 0; ch < chns; ++ch)
        {
            std::packaged_task<decltype(CorrOneChn)> xcorrOneChnTask(CorrOneChn);
            auto fut = xcorrOneChnTask.get_future();
            futs.push_back(std::move(fut));
            int32_t *p32DataOneChn = dfRaw.pChnData(ch);
            int32_t *p32CoefOneChn = p32DataOneChn;//因子道
            ths.emplace_back(std::move(xcorrOneChnTask), p32DataOneChn, p32CoefOneChn, std::ref(dfIntfe), std::ref(calPara), points, ch);
        }
        for (auto& fut : futs)
        {
            if(!fut.get())
            {
                return tl::make_unexpected("自相关计算失败");
            }
        }


        string msg = SaveAcorrData(dfIntfe);
        if (!msg.empty())
        {
            return tl::make_unexpected(msg);
        }
        return dfIntfe;
    }

    string ExtractInterfeSingal(uint64_t fromTimeMs, uint64_t toTimeMs, int lineId,bool isRealtimeExt)
    {
        string errmsg;
        if (toTimeMs <= fromTimeMs)
        {
            logErr(string("swt_extract_interfere: time is illegal!"));
            return "时间段非法";
        }
        DataFrame dfRaw;
        auto dmRlt = ms_swt::DataMerge(fromTimeMs,toTimeMs,lineId);//默认单基站随掘
        if (dmRlt) {
            dfRaw = std::move(dmRlt.value());
        } else {
            return dmRlt.error();
        }
        int chns = dfRaw.channels();
        int points = dfRaw.points();
        float deltT = dfRaw.sampIntvl();
        InterfeCalParam param;
        errmsg = GetInterfeParam(param,dfRaw.sampTime(),isRealtimeExt);
        if(!errmsg.empty())
        {
            return errmsg;
        }
        if (points*deltT<param.minTimeLen*1000)
        {
            logErr(string("swt_extract_interfere: insufficient data duration!"));
            return "数据时间段小于30s";
        }
        param.coefPoint = int(param.coefTimeLen * 1000 / deltT);

        // 时间戳区分类型
        // 若保存的是全时数据的提取数据，则时间戳加60ms。若保存的是背景数据的提取数据，则时间戳加30ms
        // 实时计算加1ms，历史计算加2ms
        if (dfRaw.classId() == SwtDataFrameType::FullTime)
        {
            dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + 60));
        }
        else if (dfRaw.classId() == SwtDataFrameType::BakgdExtrm)
        {
            dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + 30));
        }
        dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + isRealtimeExt?1:2));

        //互相关计算
        ProcDataXcorr(param,dfRaw);
        if (param.doCorrBoth)
        {
            ProcDataAcorr(param,dfRaw);
        }
        return "";
    }

    string ExtractInterfeSingal(MSTraceMgr& xcorrData, uint64_t fromTimeMs, uint64_t toTimeMs, int lineId,bool isRealtimeExt)
    {
        string errmsg;
        if (toTimeMs <= fromTimeMs)
        {
            logErr(string("swt_extract_interfere: time is illegal!"));
            return "时间段非法";
        }
        DataFrame dfRaw;
        auto dmRlt = ms_swt::DataMerge(fromTimeMs,toTimeMs,lineId);//默认单基站随掘
        if (dmRlt) {
            dfRaw = std::move(dmRlt.value());
        } else {
            return dmRlt.error();
        }
        int chns = dfRaw.channels();
        int points = dfRaw.points();
        float deltT = dfRaw.sampIntvl();
        InterfeCalParam param;
        errmsg = GetInterfeParam(param,dfRaw.sampTime(),isRealtimeExt);
        if(!errmsg.empty())
        {
            return errmsg;
        }
        if (points*deltT<param.minTimeLen*1000)
        {
            logErr(string("swt_extract_interfere: insufficient data duration!"));
            return ("数据时间段小于30s");
        }
        param.coefPoint = int(param.coefTimeLen * 1000 / deltT);

        if (dfRaw.classId() == SwtDataFrameType::FullTime)
        {
            dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + 60));
        }
        else if (dfRaw.classId() == SwtDataFrameType::BakgdExtrm)
        {
            dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + 30));
        }
        dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + isRealtimeExt?1:2));

        //互相关计算
        dmRlt = ProcDataXcorr(param,dfRaw);
        if (!dmRlt) {
            std::cout<<dmRlt.error()<<endl;
            return dmRlt.error();
        }
        DataFrame dfxCorr = std::move(dmRlt.value());
        ms_swt::ConvertDataFrameToMSTraceMgr(dfxCorr,xcorrData);
        vector<MSDataTrace*>& vtTrc = xcorrData.GetTraces();
        if (vtChnInfo.size() == vtTrc.size())
        {
            for (int i = 0; i < vtTrc.size(); i++) {
                vtTrc[i]->SetShotRecvCoor(vtChnInfo[param.coefChnId-1].x,vtChnInfo[param.coefChnId-1].y,vtChnInfo[param.coefChnId-1].z,vtChnInfo[i].x,vtChnInfo[i].y,vtChnInfo[i].z);
                vtTrc[i]->Head().status = vtChnInfo[i].enb;
            }
            xcorrData.Head().setObsv = true;
        }
        return "";
    }
    string ExtractInterfeSingal(MSTraceMgr& xcorrData, MSTraceMgr& acorrData, uint64_t fromTimeMs, uint64_t toTimeMs, int lineId,bool isRealtimeExt)
    {
        string errmsg;
        if (toTimeMs <= fromTimeMs)
        {
            logErr(string("swt_extract_interfere: time is illegal!"));
            return "时间段非法";
        }
        DataFrame dfRaw;
        auto dmRlt = ms_swt::DataMerge(fromTimeMs,toTimeMs,lineId);//默认单基站随掘
        if (dmRlt) {
            dfRaw = std::move(dmRlt.value());
        } else {
            return dmRlt.error();
        }
        int chns = dfRaw.channels();
        int points = dfRaw.points();
        float deltT = dfRaw.sampIntvl();
        InterfeCalParam param;
        errmsg = GetInterfeParam(param,dfRaw.sampTime(),isRealtimeExt);
        if(!errmsg.empty())
        {
            return errmsg;
        }
        if (points*deltT<param.minTimeLen*1000)
        {
            logErr(string("swt_extract_interfere: insufficient data duration!"));
            return "数据时间段小于30s";
        }
        param.coefPoint = int(param.coefTimeLen * 1000 / deltT);

        if (dfRaw.classId() == SwtDataFrameType::FullTime)
        {
            dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + 60));
        }
        else if (dfRaw.classId() == SwtDataFrameType::BakgdExtrm)
        {
            dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + 30));
        }
        dfRaw.setHeadValue<double>(0, (double)(dfRaw.sampTime() + isRealtimeExt?1:2));

        //互相关计算
        dmRlt = ProcDataXcorr(param,dfRaw);
        if (!dmRlt) {
            std::cout<<dmRlt.error()<<endl;
            return dmRlt.error();
        }
        DataFrame dfxCorr = std::move(dmRlt.value());
        ms_swt::ConvertDataFrameToMSTraceMgr(dfxCorr,xcorrData);
        vector<MSDataTrace*>& vtTrc = xcorrData.GetTraces();
        if (vtChnInfo.size() == vtTrc.size())
        {
            for (int i = 0; i < vtTrc.size(); i++)
            {
                vtTrc[i]->SetShotRecvCoor(vtChnInfo[param.coefChnId-1].x,vtChnInfo[param.coefChnId-1].y,vtChnInfo[param.coefChnId-1].z,vtChnInfo[i].x,vtChnInfo[i].y,vtChnInfo[i].z);
                vtTrc[i]->Head().status = vtChnInfo[i].enb;
            }
            xcorrData.Head().setObsv = true;
        }
        if (param.doCorrBoth)
        {
            auto dmRlt2 = ProcDataAcorr(param,dfRaw);
            if (!dmRlt2) 
            {
                logErr(dmRlt2.error());
                return dmRlt2.error();
            }
            DataFrame dfacorr = std::move(dmRlt2.value());
            ms_swt::ConvertDataFrameToMSTraceMgr(dfacorr, acorrData);
            vector<MSDataTrace *> &vtTrc = acorrData.GetTraces();
            if (vtChnInfo.size() == vtTrc.size())
            {
                for (int i = 0; i < vtTrc.size(); i++)
                {
                    vtTrc[i]->SetShotRecvCoor(vtChnInfo[i].x, vtChnInfo[i].y, vtChnInfo[i].z, vtChnInfo[i].x, vtChnInfo[i].y, vtChnInfo[i].z);
                    vtTrc[i]->Head().status = vtChnInfo[i].enb;
                }
                acorrData.Head().setObsv = true;
            }
        }

        return "";
    }

}//namespace
```





# 17. 历史处理：干涉提取信号+信号处理+偏移（新代码）

## （1）拼帧

* `GetFileOfTimeSpan()`查询原始数据帧的sql中，改为

  ```mysql
  samp_time >= FROM_UNIXTIME(?) 
  ```

  这样会比写`>`多取一个原始数据文件，但会导致提取同一时间的实时or背景，提取文件的时间戳一样。

  **所以按照下面方法，在拼后的数据帧的采样时间基础上按原始数据帧类型增加6 or 3ms。**

* `DataMerge()`函数增加判断类型，在采样时间的基础上增加一定时间避免在同一个时间戳分别提取全时or背景后的9文件名一样，插入表`e_mining_signaldata_frm_info`时主键冲突。

  ```cpp
  // 若保存的是来自全时原始数据帧的提取数据，则拼帧时间戳加60ms
  // 若保存的是来自背景原始数据帧的提取数据，则拼帧时间戳加30ms
  if(dfMerge.classId() == SwtDataFrameType::FullTime)
  {
      dfMerge.setHeadValue<double>(0, (double)(dfMerge.sampTime() + 6));
  }
  else if(dfMerge.classId() == SwtDataFrameType::BakgdExtrm)
  {
      dfMerge.setHeadValue<double>(0, (double)(dfMerge.sampTime() + 3));
  }
  ```


# 18. 实时处理（新代码）

---

> [!NOTE]
>
> * 配置参数：`hzi::config.ms_mining_type == 2`，`hzi::config.ms_tunnel_listen==false`
>
> * handleTimestamp tunnel()——铁建的实时处理
>
> * realTimeCal()——实时处理代码
>
> * 实时计算时间段的起止时间从`hzi::fromToEndMap`中取得，该变量在`readEngDenity()`处被赋值。
>
>   读背景摘要文件，`matchValue()`根据【数据提取】中参数，判定数据是否有效，若有效将时间段insert到`hzi::fromToEndMap`，作为实时处理的时间段。

```cpp
void realTimeCal() 
{
    int32_t count = 0;
    while (1) 
    {
        // cout<<"realTimeCal: "<<count++<<endl;
        logInfo("realTimeCal: " + to_string(count++));

        std::this_thread::sleep_for(std::chrono::seconds(10));
        auto it = hzi::fromToEndMap.begin();
        if (it != hzi::fromToEndMap.end()) 
        {
            auto fromStamp = it->first;
            auto endStamp = it->second;

            auto diff = endStamp - fromStamp;
            if (diff <= 0)
            {
                logInfo(to_string(fromStamp) + " <= " + to_string(endStamp) + ", return..");
                return;
            }

            logInfo("[" + timestampToString(fromStamp) + "-" + timestampToString(endStamp) + "]" + ":" + "realtime process start..");

            //查表读取参数
            auto conn = hzi::config.pConnPool->getConnection();
            auto rslt0 = conn.executeQuery(
                "SELECT dataFreq,dataLen,class_Id FROM `e_mining_PCOSignalParm`");
            if (rslt0.next()) 
            {
                hzi::miningFreq = rslt0.getInt("dataFreq");//数据频度（单位时间 h)
                hzi::miningDateLen = rslt0.getInt("dataLen");//数据时长（单位时间min)
                hzi::mining_classId = rslt0.getInt("class_Id");//拼接数据类型（6 微震全时 3-微震背景）
                std::cout<<"realtime process data class_id="<<hzi::mining_classId<<std::endl;
            }

            auto dataLen = hzi::miningDateLen * 60 * 1000;
            int datasize = (int)diff / dataLen;
            datasize += 1;

            auto endLoc = (fromStamp + (uint64_t)dataLen) > endStamp ? endStamp : (fromStamp + (uint64_t)dataLen);
            for (int i = 0; i < datasize; i++)
            {
                // 干涉提取（互），保存文件9
                ms_swt::MSTraceMgr xcorrData;
                string retmsg = ms_swt::ExtractInterfeSingal(xcorrData, fromStamp, endLoc, true);
                if (!retmsg.empty())
                {
                    logErr("[" + timestampToString(fromStamp) + "-" + timestampToString(endLoc) + "]" + ":" + retmsg);
                    continue;
                }
                logInfo("[" + timestampToString(fromStamp) + "-" + timestampToString(endLoc) + "]" + ":" + "ExtractInterfeSingal finished..");

                // 信号处理，偏移计算，保存文件99，10，界面提取
                retmsg = ms_swt::AdvancedDetectionProcess(xcorrData, true);
                if (!retmsg.empty())
                {
                    logErr("[" + timestampToString(fromStamp) + "-" + timestampToString(endLoc) + "]" + ":" + retmsg);
                    continue;
                }

                fromStamp += (uint64_t)dataLen;
                endLoc = (fromStamp + (uint64_t)dataLen) > endStamp ? endStamp : (fromStamp + (uint64_t)dataLen);
            }
            logInfo("[" + timestampToString(fromStamp) + ", " + timestampToString(endStamp) + "]" + ":" + "realtime process finished..");

            //  threadHanleData(fromStamp, endStamp, hzi::miningDateLen * 60 * 1000, 0);
            //  cout<<"fromStamp = "<<std::to_string(fromStamp)<<" , endStamp =
            //  "<<std::to_string(endStamp)<<endl;
            // std::thread handerSignalthread(threadHanleData,
            // fromStamp,endStamp,hzi::miningDateLen * 60 * 1000);
            // handerSignalthread.detach();
            // 删除第一个元素
            hzi::fromToEndMap.erase(it);
        }
    }
}
```









# 13. 数据帧文件类型及格式

---

数据文件在内存中都以`DataFrame`形式存在。 

> [!IMPORTANT]
>
> | classid | 类型                         | 说明                                                         |
> | ------- | ---------------------------- | ------------------------------------------------------------ |
> | 2       | 原始帧：微震事件             |                                                              |
> | 3       | 原始帧：微震背景             | 采样间隔2ms，5s一个文件，一个文件内2500个采样点              |
> | 6       | 原始帧：微震全时             | 采样间隔0.5ms，2.5s一个文件，一个文件内5000个采样点          |
> |         |                              |                                                              |
> | 9       | 数据帧：干涉提取数据文件     |                                                              |
> | 99      | 数据帧：随掘互干涉再提取文件 | 9文件经过信号处理流程后的再提取数据文件。注意：该文件classid=9，而不是99 |
> | 10      | 数据帧：偏移图数据文件       |                                                              |
> |         |                              |                                                              |
> | 11      | 原始帧：伽马射线             | DataFrame格式同1/3/6，只第19字节采样间隔写死为1s。           |
> | 12      | 原始帧：电磁数据             | DataFrame格式同1/3/6/11。                                    |
> | 13      | 数据帧：随掘自干涉提取文件   |                                                              |
> |         |                              |                                                              |
> | 14~17   | 未使用                       |                                                              |
> | 30      | 电法数据文件                 | 下分为1~6六种类型。                                          |
> | 101     | y分量偏移图数据文件          | 10为x分量的偏移图数据文件。格式同10。                        |
> | 102     | z分量偏移图数据文件          | 10为x分量的偏移图数据文件。格式同10。                        |

## （1）9文件头格式

> [!WARNING]
>
> 数据文件的头格式和`DataFrame`不同。

| 总长32B | 长度（单位bit） | 说明                                                    |
| ------- | --------------- | ------------------------------------------------------- |
| 0       | 8               | tmStmp。*(double *)(pHead2) = (double)tmStmp            |
| 8       | 8               | classId=9，文件类型                                     |
| 9       | 32              | deltT，采样间隔（单位ms）                               |
| 13      | 32              | valNum，可用通道总数                                    |
| 17      | 16              | vecSize，数据分组数（这个文件里有几组数据，也就是炮数） |
| 19      | 32              | outLen，数据长度（点数）                                |
| 23      | 32              | coefBegPt，超前点数                                     |
| 27      | 8               | devId，基站ID                                           |
| 28      | 8               | systemeType（系统类型：0-双巷式，1-机载式，2-组合式'）  |
| 29      | 8               | ImageType（'随采成像方式:0-散射，1-透射，2-爆炸成像'）  |

## （2）99文件头格式

| 总长32B | 长度（单位B） | 说明                                         |
| ------- | ------------- | -------------------------------------------- |
| 0       | 8             | 时间戳。*(double *)(pHead2) = (double)tmStmp |
| 8       | 1             | classid=9                                    |
| 9       | 4             | deltT。*(float *)(pHead2 + 9) = deltT;       |
| 13      | 4             | valNum                                       |
| 17      | 2             | vecSize                                      |
| 19      | 4             | outLen                                       |
| 23      | 4             | coefBegPt                                    |
| 27      | 1             | devId                                        |

## （3）11文件头格式

文件格式：帧头（32B）+数据区（通道数×数据长度×4B）

| 总长32B | 长度(B) | 类型         | 说明                                                         |
| ------- | ------- | ------------ | ------------------------------------------------------------ |
| 0       | 1       | uint8_t      | 时间戳。*(double *)(pHead2) = (double)tmStmp                 |
| 8       | 1       | uint8_t      | classId11=11                                                 |
| **9**   | 4       | **float**    | **频率分辨率frequencyResolution：1000.0 / (deltT*pcoParm.outLen);**<br/>deltT，采样间隔（单位ms） |
|         |         |              |                                                              |
| 13      | 4       | uint32_t     | 可用通道总数                                                 |
| 17      | 2       | uint16_t     | 数据分组数                                                   |
| 19      | 4       | uint32_t     | 数据长度outLen                                               |
| **23**  | 4       | **uint32_t** | **0**                                                        |
| 27      | 1       | uint8_t      | 基站IDdevId                                                  |

## （4）10文件头格式

| 总长32B | 长度（单位bit） | 说明                                         |
| ------- | --------------- | -------------------------------------------- |
| 0       | 8               | tmStmp。*(double *)(pHead) = (double)tmStmp; |
| 8       | 8               | classid=10                                   |
| **9**   | **8**           | **devId**                                    |
| 10      | 16              | XGrdNum                                      |
| 12      | 16              | pcoLocParm.m_iYGrdNum                        |
| 14      | 16              | pcoLocParm.m_iZGrdNum                        |
| 16      | 32              | minpOut                                      |
| 20      | 32              | maxpOut                                      |
| 24      | 32              | dX                                           |

## （5）30电法数据文件格式

<table>
    <tr>
        <th colspan="5"style="text-align: center;">电法数据文件：30</th>
    </tr>
    <tr>
        <td>位置</td>
        <td>大小(B)</td>
        <td>类型</td>
        <td>定义</td>
        <td>说明</td>
    </tr>
    <tr>
        <td colspan="5">30-1/2，帧头：64B</td>
    </tr>
    <tr>
        <td>0</td>
        <td>8</td>
        <td>long</td>
        <td>时间戳</td>
        <td>13位毫秒时间戳</td>
    </tr>
    <tr>
        <td>2</td>
        <td>2</td>
        <td>int</td>
        <td>通道字计数</td>
        <td>所有通道信息所有字节数</td>
    </tr>
    <tr>
        <td>10</td>
        <td>1</td>
        <td>int</td>
        <td>系统类型</td>
        <td>0-微震电法，1-随采2-随掘</td>
    </tr>
    <tr>
        <td>11</td>
        <td>4</td>
        <td>float</td>
        <td>回采位置</td>
        <td>当前时间回采位置</td>
    </tr>
    <tr>
        <td>15</td>
        <td>1</td>
        <td>int</td>
        <td>回采方向</td>
        <td>0-沿X方向，1-逆X方向</td>
    </tr>
    <tr>
        <td>16</td>
        <td>1</td>
        <td>int</td>
        <td>单通道字节数</td>
        <td>单个通道信息所有字节数</td>
    </tr>
    <tr>
        <td>17</td>
        <td>2</td>
        <td>int</td>
        <td>单数据字节数</td>
        <td>单个数据字节数</td>
    </tr>
    <tr>
        <td>19</td>
        <td>4</td>
        <td>float</td>
        <td>深度系数</td>
        <td>深度系数，数据中的r均是已乘深度系数</td>
    </tr>
    <tr>
        <td colspan="5">30-3/4，帧头：64B</td>
    </tr>
    <tr>
        <td>0</td>
        <td>8</td>
        <td>long</td>
        <td>时间戳</td>
        <td>13位毫秒时间戳</td>
    </tr>
    <tr>
        <td>8</td>
        <td>2</td>
        <td>int</td>
        <td>单数据字计数</td>
        <td>单个数据所有字节数</td>
    </tr>
       <tr>
        <td colspan="5">30-5，帧头：32B</td>
    </tr>
    <tr>
        <td>0</td>
        <td>8</td>
        <td>long</td>
        <td>时间戳</td>
        <td>13位毫秒时间戳</td>
    </tr>
    <tr>
        <td>8</td>
        <td>1</td>
        <td>int</td>
        <td>单数据字计数</td>
        <td>单个数据所有字节数</td>
    </tr>
    <tr>
        <td>9</td>
        <td>1</td>
        <td>int</td>
        <td>测线数</td>
        <td>接收电极测线号</td>
    </tr>
    </tr>
       <tr>
        <td colspan="5">30-6，帧头：32B</td>
    </tr>
    <tr>
        <td>0</td>
        <td>8</td>
        <td>long</td>
        <td>时间戳</td>
        <td>13位毫秒时间戳</td>
    </tr>
    <tr>
        <td>8</td>
        <td>2</td>
        <td>int</td>
        <td>单数据字计数</td>
        <td>单个数据所有字节数</td>
    </tr>
    <tr>
        <td>10</td>
        <td>4</td>
        <td>int</td>
        <td>记录总数</td>
        <td>记录条数</td>
    </tr>
</table>

### ① 对应相邻MN组合的视电阻率文件-类型1

###      对应所有MN组合的视电阻率文件-类型2

* 文件格式：帧头 + 通道信息 + 视电阻率信息

* 帧头格式：64B

  | 位置 | 大小（B） | 类型  | 定义         | 说明                                |
  | ---- | --------- | ----- | ------------ | ----------------------------------- |
  | 0    | 8         | long  | 时间戳       | 13位毫秒时间戳                      |
  | 2    | 2         | int   | 通道字计数   | 所有通道信息所有字节数              |
  | 10   | 1         | int   | 系统类型     | 0-微震电法，1-随采2-随掘            |
  | 11   | 4         | float | 回采位置     | 当前时间回采位置                    |
  | 15   | 1         | int   | 回采方向     | 0-沿X方向，1-逆X方向                |
  | 16   | 1         | int   | 单通道字节数 | 单个通道信息所有字节数              |
  | 17   | 2         | int   | 单数据字节数 | 单个数据字节数                      |
  | 19   | 4         | float | 深度系数     | 深度系数，数据中的r均是已乘深度系数 |

* 通道信息：14B

  格式：ID，X，Y，Z

  | 位置 | 大小（B） | 类型 | 定义 | 说明 |
  | ---- | --------- | ---- | ---- | ---- |
  | 0    | 2         |      | ID   |      |
  | 2    | 4         |      | X    |      |
  | 6    | 4         |      | Y    |      |
  | 10   | 4         |      | Z    |      |

* 数据格式：29B

  格式：A，B，M，N，V/I，V，I，p，r

  | 位置 | 大小（B） | 类型 | 定义 | 说明      |
  | ---- | --------- | ---- | ---- | --------- |
  | 0    | 2         |      | A    | 通道序号  |
  | 2    | 2         |      | B    | 通道序号  |
  | 4    | 2         |      | M    | 通道序号  |
  | 6    | 2         |      | N    | 通道序号  |
  | 8    | 4         |      | V/I  | 电压/电流 |
  | 12   | 4         |      | V    | 电压      |
  | 16   | 4         |      | I    | 电流值    |
  | 20   | 4         |      | p    | 电阻率值  |
  | 24   | 4         |      | r    | 半径      |
  | 28   | 1         |      | flag | 左右标志  |

### ② 输出的超前探三维体视电阻率文件-类型3

###      输出的测深三维体视电阻率文件-类型4

* 文件格式：帧头+数据

* 帧头：64B

  | 位置 | 大小（B） | 类型 | 定义         | 说明               |
  | ---- | --------- | ---- | ------------ | ------------------ |
  | 0    | 8         | long | 时间戳       | 13位毫秒时间戳     |
  | 8    | 2         | int  | 单数据字计数 | 单个数据所有字节数 |

* 数据：16B

  格式：x，y，z，p

  | 位置 | 大小（B） | 类型 | 定义     | 说明 |
  | ---- | --------- | ---- | -------- | ---- |
  | 0    | 4         |      | 坐标     |      |
  | 4    | 4         |      | 坐标     |      |
  | 8    | 4         |      | 坐标     |      |
  | 12   | 4         |      | 电阻率值 |      |

### ③ 电压处理文件-类型5

* 文件格式：帧头+数据

* 帧头：32B

  | 位置 | 大小（B） | 类型 | 定义         | 说明               |
  | ---- | --------- | ---- | ------------ | ------------------ |
  | 0    | 8         | long | 时间戳       | 13位毫秒时间戳     |
  | 8    | 1         | int  | 单数据字计数 | 单个数据所有字节数 |
  | 9    | 1         | int  | 测线数       | 接收电极测线号     |

* 数据：22B

  格式：发射电极，接收电极，接收电极序号，原电压值，修正后电压值，测线号

  | 位置 | 大小（B） | 类型  | 定义         | 说明    |
  | ---- | --------- | ----- | ------------ | ------- |
  | 0    | 6         | char  | 发射电极     | 6个字符 |
  | 6    | 6         | char  | 接收电极     | 6个字符 |
  | 12   | 1         | int   | 接收电极序号 |         |
  | 13   | 4         | float | 原电压值     |         |
  | 17   | 4         | float | 修正后电压值 |         |
  | 21   | 1         | int   | 测线号       |         |

### ④ 电流处理文件-类型6

* 文件格式：帧头+数据

* 帧头：32B

  | 位置 | 大小（B） | 类型 | 定义         | 说明               |
  | ---- | --------- | ---- | ------------ | ------------------ |
  | 0    | 8         | long | 时间戳       | 单个数据所有字节数 |
  | 8    | 2         | int  | 单数据字计数 | 单个数据所有字节数 |
  | 10   | 4         | int  | 记录总数     | 记录条数           |

* 数据：19B

  格式：发射电极，原电流值，是否有效，测线号

  | 位置 | 大小（B） | 类型  | 定义     | 说明    |
  | ---- | --------- | ----- | -------- | ------- |
  | 0    | 6         | char  | 发射电极 | 6个字符 |
  | 6    | 8         | long  | 发射时间 |         |
  | 14   | 4         | float | 原电流值 |         |
  | 18   | 1         | int   | 是否有效 |         |

## （6）MSTraceMgr写文件

```cpp
bool SaveProcessedSignal(uint64_t tmStamp, MSTraceMgr& trcMgr)
{
    char *pHead = new char[32];
    *(double *)(pHead) = (double)tmStamp;
    *(uint8_t *)(pHead + 8) = SwtDataFrameType::CorrItfe;
    *(float *)(pHead + 9) = trcMgr.Head().deltT;
    *(uint32_t *)(pHead + 13) = trcMgr.Head().traceCount;
    *(uint16_t *)(pHead + 17) = trcMgr.Head().shotCount;
    *(uint32_t *)(pHead + 19) = trcMgr.Head().samplePoint;
    *(uint32_t *)(pHead + 23) = trcMgr.Head().advanPoint;
    *(uint8_t *)(pHead + 27) = 1;

    int classId2 = 99;  
    fs::path filepath(hzi::config.dataRoot);
    filepath /= relLocFromTime(tmStamp) / std::to_string(classId2) / std::to_string(tmStamp);
    try
    {
        auto dir = filepath.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs(filepath, std::ofstream::binary);
        ofs.write(pHead, 32);
        vector<MSDataTrace*>&vtTrc = trcMgr.GetTraces();
        for (int ch = 0; ch < trcMgr.Head().traceCount; ++ch)
        {
            ofs.write((char *)(vtTrc[ch]->GetData()), trcMgr.Head().samplePoint * sizeof(float));
        }
        ofs.close();
    }
    catch (std::exception &e)
    {
    }

    delete[] pHead;pHead=nullptr;
    return true;
}
```

## （7）数据文件读到MSTraceMgr

```cpp
namespace ms_swt
{
    //地震道数据管理
    #pragma pack(push, enter_mstracedatamanager)
    #pragma pack(1)

    //道头128
    typedef struct _stMSDataTraceHead
    {
        unsigned char ver;
        unsigned char status;
        int lineNum;
        int	shotNum;
        int	recvNum;
        int	traceNum;
        int	componetNum;
        float srDst;
        float shotX;
        float shotY;
        float shotZ;
        float recvX;
        float recvY;
        float recvZ;
        float ampleMax;
        float ampleMin;
        float cmpntAzimuth;
        float cmpntDip;
        int gatherNum;
        float gatherX;
        float gatherY;
        float gatherZ;	
        unsigned char aBak[46];

        _stMSDataTraceHead()
        {
            Reset();
        }

        void Reset()
        {
            memset(this, 0, sizeof(_stMSDataTraceHead));
        }

    }MsTraceHead;

    //数据体头64
    typedef struct _stMSDataHead
    {
        unsigned char ver;
        unsigned char setObsv;
        uint64_t sampleTime;
        int lineCount;
        int samplePoint;
        int advanPoint;
        int shotCount;
        int recvCount;
        int traceCount;
        int componentCount;
        float deltT;
        unsigned char aBak[22];

        _stMSDataHead()
        {
            Reset();
        }

        void Reset()
        {
            memset(this, 0, sizeof(_stMSDataHead));
        }

    }MsHead;

    #pragma pack(pop, enter_mstracedatamanager)

    //地震道
    class MSDataTrace
    {
        public:
        MSDataTrace(){}
        MSDataTrace(const MsTraceHead& stHead,const float* pdata, int points);
        MSDataTrace(const MSDataTrace&)=delete;
        MSDataTrace& operator=(const MSDataTrace&)=delete;
        virtual ~MSDataTrace(void);
        void SetData(const float * pData, int n);
        void SetHead(const MsTraceHead & stHead) { m_td = stHead; }
        const float * GetData() const { return m_pData; }
        float * GetData() { return m_pData; }
        inline const MsTraceHead & Head(void) const { return m_td; }
        inline MsTraceHead & Head(void) { return m_td; }
        void SetShotRecvCoor(float sx,float sy,float sz,float rx,float ry,float rz);

        protected:
        MsTraceHead m_td;
        float * m_pData = nullptr;

    };//MSDataTrace


    class MSTraceMgr
    {
        public:
        MSTraceMgr();
        ~MSTraceMgr();
        MSTraceMgr(const MSTraceMgr&)=delete;
        MSTraceMgr& operator=(const MSTraceMgr&)=delete;
        int SamplePoint() const { return m_head.samplePoint; }
        int TraceCount() const { return m_traces.size(); }
        float DeltaT()const { return m_head.deltT; }
        bool AddTrace(const MsTraceHead & stHead, const float * pBuffer, int n);
        const vector<MSDataTrace*>& GetTraces() const { return m_traces; }
        vector<MSDataTrace*>& GetTraces() { return m_traces; }
        void SetFileHead( const MsHead& fileHead) { m_head = fileHead;}
        inline MsHead & Head(void) { return m_head; }
        inline const MsHead & Head(void)const { return m_head; }
        const MsHead * HeadPtr(void) const { return &m_head; }
        bool IsValid() const { return (m_head.samplePoint>0 && !m_traces.empty()); }
        void Reset();


        private:
        void ClearTraces();

        MsHead m_head;
        vector<MSDataTrace*> m_traces;

    };	
}
```

```cpp
bool GetDataBasicInfoFromDataFrameHead(const char* pHead,int& chns, float& deltT,int& points,int& advPoints,int& shots)
{
    bool retOk = true;
    int classId = *((uint8_t *)(pHead + 8));
    if (classId == SwtDataFrameType::BakgdExtrm || classId==SwtDataFrameType::FullTime)
    {
        chns = *(uint16_t *)(pHead + 10);
        deltT = *(float *)(pHead + 19);
        points = *(uint32_t *)(pHead + 12);
        advPoints=0;
        shots = 1;
    }
    else if (SwtDataFrameType::CorrItfe==classId || SwtDataFrameType::AcorrItfe==classId)
    {
        deltT = *((float*)(pHead + 9));
        chns = *((uint32_t*)(pHead + 13));
        shots = *((uint16_t*)(pHead + 17));
        points = *((uint32_t*)(pHead + 19));
        advPoints = *((uint32_t*)(pHead + 23));
    }
    else if (SwtDataFrameType::MigrImage==classId)
    {
        points = *((uint16_t*)(pHead + 10));
        chns = *((uint32_t*)(pHead + 14));
        deltT = *((float*)(pHead + 24));
        advPoints = 0;
        shots = 1;
    }
    else
    {
        retOk = false;
    }

    return retOk;
}
```

```cpp
bool ReadFromDataFrameFile(const string& filepath, ms_swt::MSTraceMgr& trcMgr)
{
    char* pHead = nullptr;
    float* pData = nullptr;
    int32_t* pSrc = nullptr;
    try
    {
        trcMgr.Reset();
        pHead = new char[32];
        std::ifstream ifs(filepath);
        ifs.read(pHead, 32);
        int classId = *(uint8_t*)(pHead+8);
        int points ,shotNum;
        GetDataBasicInfoFromDataFrameHead(pHead,trcMgr.Head().traceCount,trcMgr.Head().deltT,points,trcMgr.Head().advanPoint,shotNum);
        trcMgr.Head().sampleTime =  *((double *)pHead);
        trcMgr.Head().samplePoint = points;
        trcMgr.Head().shotCount = shotNum;
        int chns = trcMgr.Head().traceCount / shotNum;
        pSrc = (classId==3||classId==6) ? (new int32_t[points]) : nullptr;
        pData = new float[points];
        ms_swt::MsTraceHead trcHead;
        for (int is = 0; is < shotNum; is++)
        {
            for (int ic = 0; ic < chns; ic++)
            {
                if (pSrc != nullptr) {
                    ifs.read((char*)pSrc,sizeof(int32_t)*points);
                    for (int i = 0; i < points; i++){
                        pData[i] = pSrc[i]*hzi::config.voltageCoef;
                    }
                }
                else {
                    ifs.read((char*)pData,sizeof(float)*points); 
                }
                trcHead.shotNum = is+1;
                trcHead.traceNum++;
                trcHead.recvNum = ic+1;
                trcMgr.AddTrace(trcHead,pData,points);
            }
        }
        ifs.close();
    }
    catch(const std::exception& e)
    {
        trcMgr.Reset();   
    }
    DELBFRS(pHead)
        DELBFRS(pSrc)
        DELBFRS(pData)

        return trcMgr.IsValid();
}
```

## （8）DataFrame写数据文件

```cpp
string SaveDataFrameToFile(const string& filepath, const DataFrame& df)
{
    string ret = "";
    try
    {
        int chns = GetChannels(df);
        int points = GetPoints(df);
        std::ofstream ofs(filepath, std::ofstream::binary);
        ofs.write(df.upHead.get(), 32);
        ofs.write(df.upData.get(),chns*points*4);
        ofs.close();
    }
    catch (std::exception &e)
    {
        ret = e.what();
    }
    return ret;
}
```

## （9）DataFrame转MSTraceMgr

```cpp
string ConvertDataFrameToMSTraceMgr(const DataFrame& df, ms_swt::MSTraceMgr& trcMgr)
{
    int classId = df.classId();
    if(classId<CorrItfe)
    {
        return "not support classId";
    }

    float* pData = nullptr;
    try
    {
        trcMgr.Reset();
        int points,chns,advPoint,shotNum;
        float deltT; 
        ms_swt::GetDataBasicInfoFromDataFrameHead(df.upHead.get(),chns,deltT,points,advPoint,shotNum);
        trcMgr.Head().sampleTime =  *((double *)df.upHead.get());
        trcMgr.Head().samplePoint = points;
        trcMgr.Head().shotCount = shotNum;
        trcMgr.Head().traceCount = chns;
        trcMgr.Head().deltT = deltT;
        trcMgr.Head().advanPoint = advPoint;

        ms_swt::MsTraceHead trcHead;
        pData = new float[points];
        for (int ic = 0; ic < chns; ic++)
        {
            memcpy(pData,((float*)(df.upData.get()))+ic*points,sizeof(float)*points);
            trcHead.shotNum = 1;
            trcHead.recvNum = trcHead.traceNum = ic+1;
            trcMgr.AddTrace(trcHead,pData,points);
        }
    }
    catch(const std::exception& e)
    {
        trcMgr.Reset();   
    }
    DELBFRS(pData)

        return "";
}
```

## （10）DataFrame代码

```cpp
//DataFrame.hpp
#ifndef DATAFRAME_HPP
#define DATAFRAME_HPP

#include <cmath>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <vector>

#include "tl/expected.hpp"
#include "web/Data.hpp"

// #include "Config.hpp"

using std::cout;
using std::shared_ptr;
using std::string;
using std::unique_ptr;
namespace fs = std::filesystem;

class DataFrame {
    public:
    DataFrame(){};
    ~DataFrame() {
        if (upHead)
            upHead.reset();
        if (upData)
            upData.reset();
    };

    DataFrame(int chns, int points) {
        if (chns <= 0 || points <= 0) {
            std::stringstream ss;
            ss << "DataFrame(int chns,int points) error:invalid chns(" << chns
                << ")or points(" << points << ")";
            throw std::runtime_error(ss.str());
        }
        upHead = std::make_unique<char[]>(32);
        upData = std::make_unique<char[]>(chns * points * 4);
        pHead_ = upHead.get();
        pData_ = upData.get();
        std::memset(pData_, 0, chns * points * 4);
        setChannels(chns);
        setPoints(points);
    }
    DataFrame(DataFrame &&df)
        : upHead(std::move(df.upHead)), upData(std::move(df.upData)) {
            pHead_ = upHead.get();
            pData_ = upData.get();
            cmdSeq_ = df.cmdSeq_;
        }
    DataFrame &operator=(DataFrame &df) {
        if (this != &df) {
            upHead = std::move(df.upHead);
            upData = std::move(df.upData);
            pHead_ = upHead.get();
            pData_ = upData.get();
            cmdSeq_ = df.cmdSeq_;
        }
        return *this;
    }

    // DataFrame &operator=(DataFrame &df) {
    //   upHead.reset(df.upHead.release());
    //   upData.reset(df.upData.release());
    //   pHead_ = upHead.get();
    //   pData_ = upData.get();
    //   cmdSeq_ = df.cmdSeq_;
    //   return *this;
    // }

    DataFrame &operator=(DataFrame &&df) {
        upHead = std::move(df.upHead);
        upData = std::move(df.upData);
        pHead_ = upHead.get();
        pData_ = upData.get();
        cmdSeq_ = df.cmdSeq_;
        return *this;
    }

    tl::expected<DataFrame, string> clone();

    // 从数据文件构造数据帧
    static tl::expected<DataFrame, string>
        loadFrmFromFile(uint8_t classId, const fs::path &fileName);

    static tl::expected<DataFrame, string> make(uint32_t cmdSeq,
                                                unique_ptr<char[]> upData);

    // 是否包含基站devId
    bool devInFrame(int devId) const;

    // 该基站号前的累计通道数 
    int chansBefore(int devId) const;

    void print(string prefix = "") const;
    void writeToFile(string filePath) const;

    tl::expected<DataFrame, string> shift(const DataFrame &df, int points);

    // tl::expected<DataFrame, string> merge(
    //     const DataFrame df);  //完全合并，自电、微震背景、全时微震
    tl::expected<DataFrame, string>
        merge(float timeDif,
              const DataFrame df); // 错位合并，df去头到fromPnt，本身去尾
    tl::expected<DataFrame, string>
        merge(int fromPnt, // 第一帧开始处, 按激电帧长度确定最后一帧结束位置
              std::vector<DataFrame *> dfs); // 多并一，自电并到激电

    // tl::expected<DataFrame, string> merge(
    //     int64_t fromsampTime,  //同一个基站该时间内的多个文件合并
    //     int64_t endsampTime);  //
    tl::expected<int, string> save() const;
    tl::expected<int, string> remove() const;

    // 预处理
    tl::expected<int, string> preprocess();

    template <typename T> void setHeadValue(size_t offset, T val) {
        *(T *)(pHead_ + offset) = val;
    }
    inline int64_t sampTime() const { return *(double *)pHead_; };
    inline void setSampTime(double newTime) const {
        *(double *)pHead_ = newTime;
    };
    inline uint8_t devMask() const { return *(uint8_t *)(pHead_ + 26); }
    inline void addDevMask(uint8_t devId) const {
        *(uint8_t *)(pHead_ + 26) |= (uint8_t)safePow(2, devId - 1);
    }
    inline void setDevMask() const {
        *(uint8_t *)(pHead_ + 26) = (uint8_t)safePow(2, devMask() - 1);
    }
    inline uint8_t classId() const { return *(uint8_t *)(pHead_ + 8); }
    inline void setClassId(uint8_t newId) { *(uint8_t *)(pHead_ + 8) = newId; }
    inline uint16_t channels() const { return *(uint16_t *)(pHead_ + 10); }
    inline void setChannels(uint16_t newVal) {
        *(uint16_t *)(pHead_ + 10) = newVal;
    }
    inline int32_t points() const { return *(uint32_t *)(pHead_ + 12); }
    inline void setPoints(uint32_t newVal) {
        *(uint32_t *)(pHead_ + 12) = newVal;
    }
    inline uint8_t msTrigChn() const { return *(uint8_t *)(pHead_ + 16); }
    inline uint8_t emitDevId() const { return *(uint8_t *)(pHead_ + 17); }
    inline uint8_t emitFrm() const { return *(uint8_t *)(pHead_ + 16); }
    inline uint8_t msTrigDev() const { return *(uint8_t *)(pHead_ + 17); }
    inline uint8_t emitTypeId() const { return *(uint8_t *)(pHead_ + 23); }
    inline uint8_t emitVoltageId() const { return *(uint8_t *)(pHead_ + 24); }
    inline uint8_t emitVoltageSchm() const { return *(uint8_t *)(pHead_ + 28); }
    inline float sampIntvl() const { return *(float *)(pHead_ + 19); }
    inline bool emitting() const { return *(uint8_t *)(pHead_ + 25) == 1; }
    inline bool timeSynced() const { return *(uint8_t *)(pHead_ + 21) == 1; }
    inline bool isMerged() const { return *(uint8_t *)(pHead_ + 27) == 1; }
    inline void setMerged() { *(uint8_t *)(pHead_ + 27) = 1; }
    inline void setEmitting() { *(uint8_t *)(pHead_ + 25) = 1; }

    inline double endTime() const {
        return (double)sampTime() + sampIntvl() * points();
    }

    inline int dataBytes() const { return channels() * points() * 4; }

    inline bool isFullTimeFrame() const {
        return classId() == 0 || classId() == 3 || classId() == 6;
    }

    // chn:通道号，0起
    inline int32_t *pChnData(int chn) {
        return (int32_t *)pData_ + chn * points();
    }

    std::vector<string> chnLabels() const;

    // 去零漂
    int32_t *chnData(size_t chn) const;

    // tl::expected<std::shared_ptr<char[]>, string> sharedFrame();
    friend bool operator>(DataFrame const &d1, DataFrame const &d2);
    friend bool operator<(DataFrame const &d1, DataFrame const &d2);
    friend bool operator==(DataFrame const &d1, DataFrame const &d2);
    friend bool operator!=(DataFrame const &d1, DataFrame const &d2);

    unique_ptr<char[]> upHead;
    // unique_ptr<int32_t[]> upData;
    unique_ptr<char[]> upData;

    static constexpr uint8_t ORDERS = 4;      // 最大工频谐波阶数
    static constexpr uint8_t INIT_STEPS = 10; // 相位初始搜索步长
    private:
    tl::expected<int, string> saveIntoDataFrmInfo() const;
    tl::expected<int, string> saveIntoDataDigest() const;
    tl::expected<int, string> saveFrmToFile() const;

    /*
      double DataFrame::sumOfSums(int chn,
                                  int phaseIndex,
                                  uint8_t order,
                                  uint8_t num,
                                  float amp);
      float meanAmplitude(int chn);
      std::pair<int, float> initMinIndex(int chn,
                                         uint8_t order,
                                         uint8_t num,
                                         float amp);
      std::pair<int, float> searchMinIndex(int chn,
                                           uint8_t order,
                                           uint8_t num,
                                           float amp);

      void filterZeroDrift(int chn);
      // 工频正弦波取样, 0相位，其他相位循环平移得到
      std::vector<float> sampleSin(float freq, uint8_t order = 1);
      std::vector<std::vector<float>>
          sinSamples[ORDERS];  // 正弦波样本, 从49到51Hz，间隔0.1
      void initSamples(float fromFreq, float toFreq);
      void filterPowFreqs(int chn);
      void filterPowFreq(float amp, int chn, uint8_t order, uint8_t num);
      */

    char *pHead_;
    char *pData_;
    uint32_t cmdSeq_ = 0;
    std::mutex mtx_;
    int safePow(int base, unsigned int power) const {
        if (power == 0) {
            return 1;
        }
        int p = 1;
        for (int i = 0; i < power; i++) {
            p *= base;
        }
        return p;
    }
};

#endif
```

```cpp
//DataFrame.cpp
#include "DataFrame.hpp"
#include "Config.hpp"
#include "common.hpp"

#include <algorithm>
#include <bits/stdc++.h>
#include <chrono>
#include <execution>
#include <fstream>
#include <iostream>
#include <map>
#include <mutex>
#include <numbers>
#include <numeric>

namespace {
    struct Digest {
        int init_value;
        int min;
        int max;
        int mxmn;
        int num;
        int64_t avgSum;
        int xPnt;
        int nPnt;
        int xnPnt;
    };
    std::map<string, Digest> digests; // key is chnLabel
    std::map<uint8_t, double> lastDigestTime = {
        {0, 0}, {3, 0}
        // {6, 0}
    }; // 对应数据类型 0,3,6的最后采样时间
    std::mutex spMtx;
    float chnScale = 1.0E-4;
    float lowerFreq = 47.0;
    float upperFreq = 53.0;

    float sumWithSamples(const int32_t *pCData, int pnts,
                         const vector<float> &samples, float amp, int fromIndex) {
        return std::reduce(pCData, pCData + pnts, 0.0,
                           [&, n = fromIndex](double acc, double x) mutable {
                               return acc + std::fabs(x * chnScale +
                                                      amp * samples[n++ % pnts]);
                           }) /
            pnts;
    }

    void filterPowFreq1(int numInPeriod, int32_t *pCData, int pnts,
                        const vector<float> &samples, float amp) {
        for (int i = 0; i < numInPeriod; i++) {
            auto sum = sumWithSamples(pCData, pnts, samples, amp, i);
            if (sum > amp)
                continue;

            auto ampStep = 0.1;
            auto newSum = sumWithSamples(pCData, pnts, samples, amp + ampStep, i);
            if (newSum > sum) {
                ampStep = -ampStep;
                newSum = sumWithSamples(pCData, pnts, samples, amp + ampStep, i);
            }
            while (newSum < sum) {
                amp += 2 * ampStep;
                sum = newSum;
                newSum = sumWithSamples(pCData, pnts, samples, amp, i);
            }

            for (int j = 0, k = i + j; j < pnts; j++) {
                pCData[j] += (int32_t)(amp * samples[k % pnts] / chnScale);
            }
        }
        return;
    }

}; // namespace

tl::expected<DataFrame, string> DataFrame::clone() {
    try {
        DataFrame df(channels(), points());
        memcpy(df.pHead_, pHead_, 32);
        memcpy((char *)df.pData_, (char *)pData_, dataBytes());
        df.cmdSeq_ = cmdSeq_;
        return std::move(df);
    } catch (std::exception &e) {
        return tl::make_unexpected(string("DataFrame::clone error:") + e.what());
    }
}
using std::cout;
bool operator>(DataFrame const &d1, DataFrame const &d2) {
    // return *(double*)d1.pHead_ > *(double*)d2.pHead_;
    return d1.sampTime() > d2.sampTime();
}
bool operator<(DataFrame const &d1, DataFrame const &d2) {
    // return *(double*)d1.pHead_ < *(double*)d2.pHead_;
    return d1.sampTime() < d2.sampTime();
}
bool operator==(DataFrame const &d1, DataFrame const &d2) {
    // return *(double*)d1.pHead_ == *(double*)d2.pHead_;
    return d1.sampTime() == d2.sampTime();
}
bool operator!=(DataFrame const &d1, DataFrame const &d2) {
    // return *(double*)d1.pHead_ != *(double*)d2.pHead_;
    return d1.sampTime() != d2.sampTime();
}

void DataFrame::print(string prefix) const {
    std::stringstream ss, msg;
    if (classId() == 1) {
        if (isMerged()) {
            ss << ",发射基站号:" << (unsigned)emitDevId();
        }
        ss << ",发射帧序号:" << (unsigned)emitFrm();
    }
    if (classId() == 2) {
        ss << ",触发基站号:" << (unsigned)msTrigDev();
        ss << ",触发通道序号:" << (unsigned)msTrigChn();
    }
    msg << "数据类型:" << std::dec << (unsigned)classId()
        << ",设备地址(掩码):" << (unsigned)devMask() << ss.str()
        << ",采样时间:" << std::fixed
        << sampTime()
        //  << ",是否采用对时模块:" << std::boolalpha << timeSynced()
        << ",采样间隔:" << std::setprecision(2) << sampIntvl()
        << ",结束时间:" << std::setprecision(0) << endTime()
        << "(ms),通道数:" << channels() << ",每通道数据点数:" << points()
        << ",发射中:" << std::boolalpha << emitting() << ",合并否:" << isMerged()
        << std::endl;
    std::unique_lock<std::mutex> lck(hzi::globalMtx);
    namespace ch = std::chrono;
    cout << "\n";
    cout << timeStr(ch::system_clock::now()) << " ";
    cout << prefix << ":" << msg.str();
}

void DataFrame::writeToFile(string filePath) const {
    std::ofstream ofs(filePath.c_str(),
                      std::ofstream::binary | std::ofstream::app);
    ofs.write(pHead_, 32);
    ofs.write(pData_, dataBytes());
    ofs.close();
}
// 是否包含基站devId
bool DataFrame::devInFrame(int devId) const {
    return isMerged() ? (devMask() & (int)safePow(2, devId - 1)) > 0
        : devMask() == devId;
}

// 该基站号前的累计通道数 
int DataFrame::chansBefore(int devId) const {
    if (!isMerged()) {
        return 0;
    }
    int c = 0;
    for (int i = 1; i < devId; i++) {
        if (devInFrame(i)) {
            c += hzi::config.devicesMap[i].dataChns[classId()];
        }
    }
    return c;
}

tl::expected<int, string> DataFrame::saveIntoDataFrmInfo() const {
    try {
        if (classId() == 6 && !hzi::config.saveFullMsData) {
            return 0;
        }
        if (classId() == 2 && !hzi::config.ms_trigger) {
            return 0;
        }
        fs::path relLoc = relLocFromTime(sampTime()) / std::to_string(classId()) /
            std::to_string((long)sampTime());

        auto conn = hzi::config.pConnPool->getConnection();
        conn.execute(
            "INSERT INTO "
            "e_data_frm_info "
            "(dev_id,cmd_seq,samp_time,samp_"
            "intvl,class_id,curt_ch,"
            "channels,ch_pnts,"
            "emit_frm_no,flag,"
            "frm_loc,excit_type_id)"
            "values(?,?,FROM_"
            "UNIXTIME(?),?,?,?,?,?"
            ",?,?,?,?)",
            (int)devMask(),                // dev_id
            0,                             // cmd_seq
            sampTime() / 1000.0,           // samp_time
            sampIntvl(),                   // samp_intvl
            classId(),                     // class_id
            (int)*(uint8_t *)(pHead_ + 9), // curt_ch
            channels(),                    // channels
            points(),                      // ch_pnts
            // emitFrm(),                      // emit_frm_no
            (int)*(uint8_t *)(pHead_ + 16), // 激电发射帧号或微震触发通道号
            (int)*(uint8_t *)(pHead_ + 17), // 激电发射设备号或微震触发设备号
            relLoc.c_str(),                 // frm_loc
            (int)emitTypeId()               // excit_type_id
        );
        return 0;
    } catch (sql_exception &e) {
        tl::make_unexpected(string("DataFrame::saveIntoDataFrmInfo:") + e.what());
    }
}
tl::expected<int, string> DataFrame::saveIntoDataDigest() const {
    try {
        if ((hzi::config.ms_mining_type > 0) || classId() == 6 || classId() == 4 ||
            classId() == 11 || classId() == 1)
            return 0;
        int32_t *p32 = (int32_t *)this->pData_;
        vector<string> cLabels = chnLabels();

        auto conn = hzi::config.pConnPool->getConnection();
        // prepareStatement特别提醒：如果某字段不存在会导致segmentation fault!
        auto pps = conn.prepareStatement(
            "INSERT INTO e_data_digest "
            "(samp_time,class_id,chn_label,max_min,max,min,delta,"
            "delta_mx,delta_mn,avg,emitting,dev_id,channel,init_value) "
            "values (?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
        conn.beginTransaction();
        bool inDigestDruation = isFullTimeFrame()
            ? (sampTime() - lastDigestTime[classId()]) <
            hzi::config.digestDuration * 60000
            : false;

        for (int i = 0; i < channels(); i++) {
            // if (classId() == 1) {
            //     if (i > 0 && hzi::chnState[cLabels[i - 1]] != 0)
            //         continue;
            // } else
            if (i > cLabels.size() - 1) {
                print("in saveIntoDataDigest问题帧");
                break;
            }
            if (hzi::chnState[cLabels[i]] != 0) {
                continue;
            }

            auto label = cLabels[i];
            int64_t sum = 0;
            int init_value = *(p32 + i * points());
            int mxmn, max = std::numeric_limits<int32_t>::min(),
            min = std::numeric_limits<int32_t>::max();
            int xnPnt, xPnt, nPnt;
            for (int j = 0; j < points(); j++) {
                auto k = i * points() + j;
                if (p32[k] > max) {
                    max = p32[k];
                    xPnt = j;
                }
                if (p32[k] < min) {
                    min = p32[k];
                    nPnt = j;
                }
                sum += p32[k];
            }
            double avg = sum / points();
            if (abs(max) > abs(min)) {
                mxmn = max;
                xnPnt = xPnt;
            } else {
                mxmn = min;
                xnPnt = nPnt;
            }
            if (isFullTimeFrame()) {
                std::unique_lock<std::mutex> lck(spMtx);
                if (inDigestDruation) {
                    if (digests.contains(label)) {
                        if (max > digests[label].max) {
                            digests[label].max = max;
                            digests[label].xPnt = xPnt;
                        }
                        if (min < digests[label].min) {
                            digests[label].min = min;
                            digests[label].nPnt = nPnt;
                        }
                        if (mxmn > digests[label].mxmn) {
                            digests[label].mxmn = mxmn;
                            digests[label].xnPnt = xnPnt;
                        }
                        digests[label].num++;
                        digests[label].avgSum += avg;
                    } else {
                        digests[label].max = max;
                        digests[label].xPnt = xPnt;
                        digests[label].min = min;
                        digests[label].nPnt = nPnt;
                        digests[label].mxmn = mxmn;
                        digests[label].xnPnt = xnPnt;
                        digests[label].num = 1;
                        digests[label].avgSum = avg;
                    }
                    continue;
                } else {
                    std::swap(digests[label].max, max);
                    std::swap(digests[label].min, min);
                    std::swap(digests[label].mxmn, mxmn);
                    std::swap(digests[label].xPnt, xPnt);
                    std::swap(digests[label].nPnt, nPnt);
                    std::swap(digests[label].xnPnt, xnPnt);
                    std::swap(digests[label].avgSum, sum);
                    avg = digests[label].num > 0 ? sum / digests[label].num : 0;
                    digests[label].num = 1;
                    lastDigestTime[classId()] = sampTime();
                }
            }
            pps.bind(1, (double)sampTime());
            pps.bind(2, (int)classId());
            pps.bind(3, label.c_str());
            pps.bind(4, mxmn);
            pps.bind(5, max);
            pps.bind(6, min);
            pps.bind(7, xnPnt);
            pps.bind(8, xPnt);
            pps.bind(9, nPnt);
            pps.bind(10, avg);
            pps.bind(11, (int)emitting());
            pps.bind(12, devMask());
            pps.bind(13, i);
            pps.bind(14, init_value);
            pps.execute();
        }
        conn.commit();

        return 0;
    } catch (sql_exception &e) {
        tl::make_unexpected(string("DataFrame::saveIntoDigest:") + e.what());
    } catch (std::exception &e) {
        tl::make_unexpected(string("DataFrame::saveIntoDigest:") + e.what());
    }
}
tl::expected<int, string> DataFrame::saveFrmToFile() const {
    fs::path fileName(hzi::config.dataRoot);
    fileName /= relLocFromTime(sampTime()) / std::to_string(classId()) /
        std::to_string(sampTime());

    try {
        auto dir = fileName.parent_path();
        if (!fs::exists(dir)) {
            fs::create_directories(dir);
        }

        std::ofstream ofs(fileName, std::ofstream::binary);
        ofs.write(pHead_, 32);
        if (classId() == 4) {
            ofs.write((char *)pData_, channels() * points() * 2);
        } else {
            ofs.write((char *)pData_, channels() * points() * 4);
        }
        ofs.close();
        return 0;
    } catch (std::exception &e) {
        string msg("error while writing to file:");
        msg += fileName.string();
        msg += ":";
        msg += e.what();
        return tl::make_unexpected(msg);
    };
}
tl::expected<int, string> DataFrame::save() const {
    if (classId() == 6 && !hzi::config.saveFullMsData) {
        return 0;
    } else if (classId() == 2 && !hzi::config.ms_trigger) {
        return 0;
    } else {
        return saveIntoDataFrmInfo()
            .and_then([&](auto r) { return saveIntoDataDigest(); })
            .and_then([&](auto r) { return saveFrmToFile(); });
    }
}
tl::expected<int, string> DataFrame::remove() const {
    try {
        print("to delete");

        auto conn = hzi::config.pConnPool->getConnection();
        conn.execute("delete from e_data_frm_info where class_id=? and "
                     "abs(unix_timestamp(samp_time)*1000-?)<3",
                     classId(), sampTime());
        cout << "e_data_frm_info updated\n";
        conn.execute("delete from e_data_digest where class_id=? and samp_time=?",
                     classId(), sampTime());
        cout << "e_data_digest updated\n";
        fs::path fileName(hzi::config.dataRoot);
        fileName /= relLocFromTime(sampTime()) / std::to_string(classId()) /
            std::to_string(sampTime());
        if (fs::exists(fileName)) {
            fs::remove(fileName);
            cout << fileName << " deleted\n";
        }
        return 0;
    } catch (fs::filesystem_error &e) {
        cout << e.what();
        return tl::make_unexpected(string("DataFrame::remove error for class_id ") +
                                   std::to_string(classId()) + ":" + e.what());
    } catch (sql_exception &e) {
        cout << e.what();
        return tl::make_unexpected(string("DataFrame::remove error for class_id ") +
                                   std::to_string(classId()) + ":" + e.what());
    } catch (std::exception &e) {
        cout << e.what();
        return tl::make_unexpected(string("DataFrame::remove error for class_id ") +
                                   std::to_string(classId()) + ":" + e.what());
    }
}
/*
double DataFrame::sumOfSums(int chn,
                            int index,
                            uint8_t order,
                            uint8_t num,
                            float amp) {
    if (pData_ == nullptr)
        return -1.0;

    int32_t* chnData = pChnData(chn);
    auto& vec = sinSamples[order - 1][num];
    auto pnts = points();
    if (index < 0) {
        index += (1000.0 / (lowerFreq + num * 0.1)) * order / sampIntvl();
    }
    return std::reduce(
               chnData, chnData + points(), 0.0,
               [&amp, &vec, &pnts, n = index](double acc, double x) mutable {
                   return acc + std::fabs(x * chnScale + amp * vec[n++ % pnts]);
               }) /
           points();
}

float DataFrame::meanAmplitude(int chn) {
    int32_t* chnData = pChnData(chn);
    return std::reduce(
               chnData, chnData + points(), 0.0,
               [](double a, double b) { return a + std::fabs(b * chnScale); }) /
           points();
}

std::pair<int, float> DataFrame::initMinIndex(int chn,
                                              uint8_t order,
                                              uint8_t num,
                                              float amp) {
    int numInPeriod = 20 * order / sampIntvl();
    float minSum = std::numeric_limits<float>::max();
    int minIndex = 0;
    for (int i = 0; i < numInPeriod; i += INIT_STEPS) {
        auto sum = sumOfSums(chn, i, order, num, amp);
        if (sum < minSum) {
            minIndex = i;
            minSum = sum;
        }
    }
    return std::make_pair(minIndex, minSum);
}

std::pair<int, float> DataFrame::searchMinIndex(int chn,
                                                uint8_t order,
                                                uint8_t num,
                                                float amp) {
    auto minPair = initMinIndex(chn, order, num, amp);
    for (int i = minPair.first - INIT_STEPS; i < minPair.first + INIT_STEPS;
         i++) {
        auto sum = sumOfSums(chn, i, order, num, amp);
        if (sum < minPair.second) {
            minPair.first = i;
            minPair.second = sum;
        }
    }
    if (minPair.first < 0)
        minPair.first +=
            (1000.0 / (lowerFreq + 0.1 * num)) * order / sampIntvl();
    if (minPair.first > points())
        minPair.first = minPair.first % points();
    return minPair;
}

void DataFrame::initSamples(float fromFreq, float toFreq) {
    if (sinSamples[0].empty()) {
        for (int i = 1; i <= ORDERS; i++) {
            for (float j = fromFreq; j <= toFreq; j += 0.1) {
                sinSamples[i - 1].push_back(sampleSin(j, i));
            }
        }
    }
    return;
}
void DataFrame::filterPowFreq(float meanAmp,
                              int chn,
                              uint8_t order,
                              uint8_t num) {
    auto& vec = sinSamples[order - 1][num];
    int32_t* pCData = pChnData(chn);

    auto minPair = searchMinIndex(chn, order, num, meanAmp);
    if (minPair.second > meanAmp)
        return;

    auto minEng = minPair.second;
    float amp = meanAmp;
    float deltAmp = 0.1;
    auto sum = sumOfSums(chn, minPair.first, order, num, amp + deltAmp);
    if (sum > minPair.second) {
        sum = sumOfSums(chn, minPair.first, order, num, amp - deltAmp);
        deltAmp = -deltAmp;
    }
    if (sum < minPair.second && amp + deltAmp > 0) {
        auto a = amp + 2 * deltAmp;
        auto newSum = sumOfSums(chn, minPair.first, order, num, a);
        while (a > 0 && newSum < sum) {
            a += deltAmp;
            sum = newSum;
            newSum = sumOfSums(chn, minPair.first, order, num, a);
        }
        amp = a;
    }

    std::rotate(vec.begin(), vec.begin() + minPair.first, vec.end());
    std::transform(
        pCData, pCData + points(), vec.begin(), pCData,
        [&](auto x, auto y) { return (int32_t)(x + amp * y / chnScale); });
    std::rotate(vec.begin(), vec.end() - minPair.first, vec.end());
    return;
}

void DataFrame::filterPowFreqs(int chn) {
    filterZeroDrift(chn);
    auto meanAmp = meanAmplitude(chn);
    int32_t* pCData = pChnData(chn);
    // for (int i = 0; i < ORDERS; i++) {
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < sinSamples[i].size(); j++) {
            // filterPowFreq(meanAmp, chn, i + 1, j);
            auto freq = lowerFreq + 0.1 * j;
            auto period = (1000.0 / freq) * (i + 1);
            auto numInPeriod = period / sampIntvl();
            filterPowFreq1(numInPeriod, pCData, points(), sinSamples[i][j],
                           meanAmp);
        }
    }
    return;
}
tl::expected<int, string> DataFrame::preprocess() {
    if (pData_ == nullptr) {
        return tl::make_unexpected(string("DataFrame::preprocess error:") +
                                   " data not ready");
    }

    if (classId() != 6 && classId() != 2)
        return 0;

    auto start = nowMS();
    // 滤工频
    // initSamples(lowerFreq, upperFreq);
    for (int i = 0; i < channels(); i++) {
        // filterPowFreqs(i);
        int32_t* pCData = pChnData(i);
        auto ret = pyFilterPowFreq(pCData, points(), 1000 / sampIntvl(), 3, 1);
        if (ret != 0) {
            cout << i << ":pyFilterPowFreq error\n";
        } else {
            cout << i << ":pyFilterPowFreq ok\n";
        }
    }

    auto end = nowMS();
    cout << "\npreprocess time for:" << (unsigned)classId() << ":"
         << (end - start) << "ms\n";
    return 0;
}
*/
// 返回新的DataFrame，其构成：
// this各道向前平移pnts个数据点，尾部从df前部复制points个点补齐。
tl::expected<DataFrame, string> DataFrame::shift(const DataFrame &df,
                                                 int pnts) {
    if (devMask() != df.devMask()) {
        return tl::make_unexpected("DataFrame::shift error: 两帧通道不一致。");
    }

    try {
        DataFrame newDF(channels(), points());
        memcpy(newDF.pHead_, pHead_, 32);
        for (int i = 0; i < channels(); i++) {
            auto copyTo = i * points(), copyFrom = i * points() + pnts,
            movePnts = points() - pnts;
            auto cpyTo = copyTo + (points() - pnts), cpyFrom = i * points(),
            cpyPnts = pnts;

            // memmove((char*)pData_ + copyTo * 4, (char*)pData_ + copyFrom
            // * 4,
            //         movePnts * 4);
            memcpy((char *)newDF.pData_ + copyTo * 4, (char *)pData_ + copyFrom * 4,
                   movePnts * 4);
            memcpy((char *)newDF.pData_ + cpyTo * 4, (char *)df.pData_ + cpyFrom * 4,
                   cpyPnts * 4);
        }
        newDF.setSampTime((double)sampTime() + sampIntvl() * pnts);
        return std::move(newDF);
    } catch (std::exception &e) {
        return tl::make_unexpected(string("DataFrame::shift error:") + e.what());
    }
}

tl::expected<DataFrame, string> DataFrame::merge(
    float samptimeDiff,
    const DataFrame
    df) { // 通用错位合并，除微震事件帧外，this头去fromPnt，df去尾
    try {
        auto intvl = sampIntvl();
        int newChns = channels() + df.channels();

        int difPnts = floor((float)samptimeDiff / sampIntvl());
        // 微震事件帧只加长,前帧后面补0，后帧前部补填原帧第一个点数值
        int fromPnt = classId() == 2 ? 0 : difPnts;
        int newPnts = classId() == 2 ? points() + difPnts : points() - fromPnt;
        DataFrame newDF(newChns, newPnts); // 构造时数据区已经初始化0
        memcpy(newDF.pHead_, pHead_, 32);
        newDF.setChannels(newChns);
        newDF.setPoints(newPnts);
        if (!newDF.isMerged()) {
            newDF.setMerged();
            newDF.setDevMask();
            if (df.emitting()) {
                newDF.setEmitting();
            }
        }
        newDF.setSampTime((double)sampTime() + fromPnt * sampIntvl());

        int toChn = 0;

        if (classId() == 1) { // copy电流通道
            memcpy((char *)newDF.pData_, (char *)pData_ + fromPnt * 4, newPnts * 4);
            toChn++;
        }
        for (int i = 1; i <= hzi::config.devicesMap.size(); i++) {
            if (devInFrame(i)) {
                auto chnsB4 = chansBefore(i);
                auto thisChns = hzi::config.devicesMap[i].dataChns[classId()];
                auto jj = classId() == 1 ? 1 : 0;
                auto jj1 = classId() == 1 ? thisChns + 1 : thisChns;
                for (int j = jj; j < jj1; j++) {
                    auto from = (char *)pData_ + ((j + chnsB4) * points() + fromPnt) * 4;
                    auto to = (char *)newDF.pData_ + toChn * newPnts * 4;
                    memcpy(to, from, (classId() == 2 ? points() : newPnts) * 4);
                    toChn++;
                }
                newDF.addDevMask(i);
            }
            if (df.devInFrame(i)) {
                auto chnsB4 = df.chansBefore(i);
                auto dfChns = hzi::config.devicesMap[i].dataChns[df.classId()];
                for (int j = 0; j < dfChns; j++) {
                    auto from = (char *)df.pData_ + ((j + chnsB4) * df.points()) * 4;
                    auto to = (char *)newDF.pData_ + toChn * newPnts * 4;
                    if (classId() == 2) {
                        int32_t *intTo = (int32_t *)to;
                        for (int k = 0; k < difPnts;
                             k++) { // 用df第j道第一个数据点填充前面difPnts部分
                            intTo[k] = *(int32_t *)from;
                        }
                        to += difPnts * 4;
                    }
                    memcpy(to, from, (classId() == 2 ? points() : newPnts) * 4);
                    toChn++;
                }
                newDF.addDevMask(i);
            }
        }
        return newDF;
    } catch (std::exception &e) {
        return tl::make_unexpected(string("DataFrame::merge error:") + e.what());
    }
}

// 合并一个非发射站自电帧，多个帧时应具有相同的通道数和采样点数
tl::expected<DataFrame, string>
    DataFrame::merge(int fromPnt, // 第一帧开始处。 按激电帧长度确定最后一帧结束位置
                     std::vector<DataFrame *> dfs) { // 多并一，自电并到激电
    if (fromPnt < 0) {
        return tl::make_unexpected("DataFrame::merge error: negative from point");
    }
    auto pnts0 = dfs[0]->points();
    auto chns0 = dfs[0]->channels();

    if (sampTime() < dfs[0]->sampTime() ||
        endTime() > dfs[dfs.size() - 1]->endTime()) {
        return tl::make_unexpected("DataFrame::merge: not enough frames");
    }

    DataFrame newDF(chns0, points());
    memcpy(newDF.pHead_, dfs[0]->pHead_, 32);
    newDF.setPoints(points());
    newDF.setSampTime(sampTime());
    auto from = fromPnt; // 第一帧从fromPnt合并,后续帧从0开始
    int pnts = 0;        // 累计各帧数据点
    for (int i = 0; i < dfs.size(); i++) {
        if (i > 0 && (dfs[i]->channels() != chns0 || dfs[i]->points() != pnts0)) {
            return tl::make_unexpected(
                string("DataFrame::merge error: channels or points not "
                       "compatible"));
        }
        bool enough = true;
        auto pntsNeed = points() - pnts;
        if (dfs[i]->points() - from < pntsNeed) {
            pntsNeed = dfs[i]->points() - from;
            enough = false;
        }

        for (int j = 0; j < chns0; j++) {
            auto to = (char *)newDF.pData_ + (j * points() + pnts) * 4;
            auto fr = (char *)dfs[i]->pData_ + (j * pnts0 + from) * 4;
            memcpy(to, fr, pntsNeed * 4);
        }
        if (enough) {
            break;
        }
        from = 0;
        pnts += pntsNeed;
    }
    return this->merge(0, std::move(newDF));
}

// 合并后的通道labels
vector<string> DataFrame::chnLabels() const {
    if (isMerged()) {
        vector<string> cLabels;
        for (int i = 0; i < 8; i++) {
            if (((int)safePow(2, i) & devMask()) > 0) {
                auto labeli = hzi::config.devicesMap[i + 1].dataChnLabel[classId()];
                cLabels.insert(cLabels.end(), labeli.begin(), labeli.end());
            }
        }
        return cLabels;
    } else {
        return hzi::config.devicesMap[devMask()].dataChnLabel[classId()];
    }
}
int32_t *DataFrame::chnData(size_t chn) const {
    int32_t *pD = (int32_t *)upData.get() + chn * points();
    int32_t sum = 0;
    for (int i = 0; i < points(); i++) {
        sum += pD[i];
    }
    auto avg = sum / points();
    for (int i = 0; i < points(); i++) {
        pD[i] -= avg;
    }
    return pD;
}

tl::expected<DataFrame, string> DataFrame::make(uint32_t cmdSeq,
                                                unique_ptr<char[]> upData) {
    try {
        char *ptr = upData.get() + 16;
        auto chns = be16toh(*(uint16_t *)(ptr + 10)); // 包含通道数
        auto pnts = be32toh(*(uint32_t *)(ptr + 12)); // 每通道包含数据点数

        DataFrame df(chns, pnts);

        // df.upHead = std::make_unique<char[]>(new char[32]());
        // df.pHead_ = df.upHead.get();
        auto pHead_ = df.pHead_;

        *(uint16_t *)(pHead_ + 10) = chns;
        *(uint32_t *)(pHead_ + 12) = pnts;

        auto devAddr = *(uint8_t *)(upData.get() + 10);

        //节点系统以采样时间为准
        int64_t tmStmp = be64toh(*(uint64_t *)ptr); // 采样时间

        // int64_t tmStmp =
        //     *(uint8_t *)(ptr + 21)
        //         ? be64toh(*(uint64_t *)(ptr + 22))
        //         : be64toh(*(uint64_t *)ptr); // 采样时间:优先采用对时模块时间

        *(double *)(pHead_) = (double)tmStmp;

        auto classId = *(uint8_t *)(pHead_ + 8) = *(uint8_t *)(ptr + 8); // 数据类型

        *(uint8_t *)(pHead_ + 9) = *(uint8_t *)(ptr + 9); // 是否包含电流通道
        *(uint8_t *)(pHead_ + 16) = classId == 1
            ? *(uint8_t *)(ptr + 16)
            : uint8_t(be16toh(*(uint16_t *)(ptr + 17)));
        // : *(uint8_t*)(ptr + 18);
        // 发射帧序号或微震触发通道号
        *(uint8_t *)(pHead_ + 17) =
            devAddr; // 发射设备号或微震触发设备号,主要用于多基站
        //     be16toh(*(uint16_t*)(ptr + 17)); //微震触发时，值最大的通道号
        *(float *)(pHead_ + 19) =
            (classId == 11) ? 1000.0
            : StartMonitor::getIntvl(classId); // 伽马数据写死1s

        if (classId == 6 && hzi::config.nodalSystem) { //节点系统全时采样固定1s时窗
            *(float *)(pHead_ + 19) = 1000.0 / *(uint32_t *)(pHead_ + 12);
        }

        #ifdef OLDBASE // 基站程序是老版本的时候得从库里取激发类型
        // Connection conn = hzi::config.pConnPool->getConnection();
        // auto rslt = conn.executeQuery(
        //     "select ee_type_id from "
        //     "e_e_samp_config where "
        //     "is_init=0");
        // if (rslt.next()) {
        //     *(uint8_t*)(pHead_ + 23) =
        //         rslt.getInt("ee_type_id");  // 激发类型id
        // }
        *(uint8_t *)(pHead_ + 23) = 1;
        #else
        // 激发类型改由基站标识
        *(uint8_t *)(pHead_ + 23) = *(uint8_t *)(ptr + 30); // 激发类型id
        #endif
        *(uint8_t *)(pHead_ + 24) = *(uint8_t *)(ptr + 19); // 激发电压id
        *(uint8_t *)(pHead_ + 25) = *(uint8_t *)(ptr + 20); // 是否正在发射

        *(uint8_t *)(pHead_ + 26) = (uint8_t)devAddr;

        *(uint8_t *)(pHead_ + 28) = StartMonitor::getEEvoltageSchm();
        // 设备地址
        //  if (classId == 1) {
        //      *(uint8_t*)(pHead_ + 17) = devAddr;
        //  }
        auto size = chns * pnts;

        if (classId == 4) {
            // 温度，2字节
            int16_t *up16 = (int16_t *)(upData.get() + 48);
            int16_t *np16 = (int16_t *)df.pData_;
            for (int i = 0; i < chns; i++) {
                for (int j = 0; j < pnts; j++) {
                    auto k = i * pnts + j;
                    np16[k] = (int16_t)be16toh(up16[k]);
                }
            }
        } else {
            int32_t *up32 = (int32_t *)(upData.get() + 48);
            int32_t *np32 = (int32_t *)df.pData_;
            for (int i = 0; i < chns; i++) {
                for (int j = 0; j < pnts; j++) {
                    auto k = i * pnts + j;
                    np32[k] = be32toh(up32[k]);
                }
            }
        }
        return std::move(df);
    } catch (std::exception &e) {
        return tl::make_unexpected(string("DataFrame::make error:") + e.what());
    }
}

// 从数据文件构造数据帧
tl::expected<DataFrame, string>
    DataFrame::loadFrmFromFile(uint8_t classId, const fs::path &fileName) {
    try {
        if (!fs::exists(fileName) || !fs::is_regular_file(fileName)) {
            return tl::make_unexpected("No such file or file type error: " +
                                       fileName.string());
        }

        std::ifstream ifs(fileName, std::ifstream::binary);
        if (!ifs) {
            return tl::make_unexpected("Unable to open file: " + fileName.string());
        }

        DataFrame df;
        df.upHead = std::make_unique<char[]>(32);
        df.pHead_ = df.upHead.get();
        ifs.read((char *)df.pHead_, 32);

        size_t dataSize = df.channels() * df.points() * (df.classId() == 4 ? 2 : 4);
        df.upData = std::make_unique<char[]>(dataSize);
        df.pData_ = df.upData.get();
        ifs.read((char *)df.pData_, dataSize);
        ifs.close();
        return df;
    } catch (std::exception &e) {
        std::string msg("error while reading from file:");
        msg += fileName.string();
        msg += ":";
        msg += e.what();
        return tl::make_unexpected(msg);
    }
}
```





# 12. 自干涉

---

## （0）功能流程

> [!IMPORTANT]
>
> * 11代表自干涉数据大类：文件名时间戳——提取数据文件，文件名时间戳_fs——频谱数据文件
>
> * 自干涉提取数据文件，路径入库表`e_mining_selfcorrdata_frm_info`
>
> * 自干涉谱图文件，路径不入库（同样放于11目录）
>
> * 前端通过接口`data_file`+`时间戳`或`时间戳_fs`取2种文件
>* 后续基于此文件信息：文件名`时间戳_*`
> 
>* 点击【干涉源提取】：自干涉提取+频率谱计算

> [!NOTE]
>
> * 前端
>
>   新增加参数，页面需要增加输入框（**暂时不加**）
>
>   ```cpp
>   //是否归一化
>   //是否道插值
>   //插值道数
>   //起始频率
>   //结束频率
>   
>   POST：/config/e_mining_PCOSignalParm_history //写表
>   POST：/handerSignal/:from_time/:to_time/:time_len/:devId //相关计算，写文件。频谱计算，写文件。
>   //POST: POST: doCalFreqSpctrm/timestamp	//频谱计算，写文件
>   GET: data_file	//取11_fs文件
>   ```
>   
> * 功能流程：
>
>   > * 用户设定干涉提取参数（SurrockProcParam）：提取参数，滤波参数，振幅均衡参数。
>   >
>   >   保存到库表`e_mining_PCOSignalParm`/`e_mining_PCOSignalParm_history`。
>   >
>   >     ![image-20250710172918364](D:\notes\笔记Img\image-20250710172918364.png)
>   >
>   > * 点击【干涉源提取】（互相关，自相关均执行）：
>   >
>   >   > * 自相关提取过程：**封装成函数：实时+历史**
>   > >
>   >   >   ```cpp
>   >   >   //读表
>   >   >   //提取：相关计算+保存文件（时间戳）
>   >   >   ExtractInterfeSingal(fromtime, totime, devid=1, MSTraceMgr trcMgr);
>   >   >   //频谱计算，保存频谱文件（时间戳_fs）
>   >   >   ProcessAutoInterfeData(MSTraceMgr trcMgr);
>   >   >   ```
>   >   >
>   >   > * 库表读取计算参数
>   >   >
>   >   >   **考虑全局变量，减少频繁读库获取参数**
>   >   >
>   >   >   ```cpp
>   >   >   auto conn = hzi::config.pConnPool->getConnection();
>   >   >   string sqlstr1;
>   >   >   if (flag)
>   >   >   {
>   >   >       // 实时计算
>   >   >       sqlstr1 = "SELECT * FROM `e_mining_PCOSignalParm`";
>   >   >   }
>   >   >   else
>   >   >   {
>   >   >       // 历史计算
>   >   >       sqlstr1 = "SELECT * FROM `e_mining_PCOSignalParm_history`";
>   >   >   }
>   >   >   auto rslt = conn.executeQuery(sqlstr1.c_str());
>   >   >   SurrockProcParam procPara;
>   >   >   
>   >   >   if(rslt.next())
>   >   >   {
>   >   >       procPara.isRealtimeProc=rslt.getInt("isRealtimeProc");
>   >   >       ...
>   >   >   }
>   >   >   ```
>   >   >
>   >   > * 执行相关
>   >   >
>   >   >   * **（考虑异步）**
>   >   >
>   >   >   * **增加取内存变量参数：**
>   >   >
>   >   >     ```cpp
>   >   >     //ExtractInterfeSingal(fromtime, totime, devid);
>   >   >     ExtractInterfeSingal(fromtime, totime, devid, MSTraceMgr& trcMgr);
>   >   >     ```
>   >   >
>   >   >   * 保存干涉提取文件：`时间戳`
>   >   >
>   >   >     **要根据类型分开，入不同库表（e_mining_selfcorrdata_frm_info和e_mining_signaldata_frm_info），文件头也有差异**
>   >   >
>   >   >     ```cpp
>   >   >     //保存提取文件函数
>   >   >     //要根据类型分开
>   >   >     SaveInterfeSignal(df, classid);
>   >   >     ```
>   >   >
>   >   > * 频谱计算：
>   > 
>   >   > * **增加一个新函数：**
>   >  >
>   >   >   ```cpp
>   >   >   //ProcessAutoInterfeData(timestamp); //读取提取文件进行频谱计算
>   >   >   ProcessAutoInterfeData(MSTraceMgr trcMgr);	//从trcMgr中取提取数据计算频谱
>   >   >   ```
>   >   >
>   >   > * > * ~~后端读取干涉提取文件~~
>   >   >   >
>   >   >   >   **改为直接从内存变量`trcMgr`里读取。**
>   >   >   >
>   >   >   >   ```cpp
>   >   >   >   ReadFromDataFrameFile(filepath,trcMgr);
>   >   >   >   ```
>   >   >   >
>   >   >   > * 库表读取计算参数
>   >   >   >
>   >   >   >   ```cpp
>   >   >   >   SurrockProcParam procPara
>   >   >   >   ```
>   >   >   >
>   >   >   > * **信号处理：滤波，陷波，道内均衡**
>   >   >   >
>   >   >   >   ```cpp
>   >   >   >   bool PreprocessSignal(MSTraceMgr& trcMgr, SurrockProcParam& procPara)
>   >   >   >   ```
>   >   >   >
>   >   >   > * 执行频谱计算
>   >   >   >
>   >   >   >   ```cpp
>   >   >   >   CalFreqSpctrm(trcMgr,procPara,dfData);
>   >   >   >   //procPara.fsBegFreq
>   >   >   >   //procPara.fsEndFreq / deltF    
>   >   >   >   ```
>   >   >   >
>   >   >   > * 保存频谱文件：`时间戳_fs`
>   >   >   >
>   >   >   >   ```cpp
>   >   >   >   filepathFS=时间戳+_fs
>   >   >   >   ms_swt::SaveDataFrameToFile(filepathFS,dfData);
>   >   >   >   ```
>   >   >
>   >   > * 前端读取_fs文件成图

## （1）算法

> ### 疑问
>
> ```cpp
> 1.
> swt_advance_process-705-trcMgr.Head().setObsv
> //这是什么?
> 2.
> swt_signal_merge.cpp，L-164代码放于L-211
> 3.
> ```
>

## （2）自干涉

### 异步

### 线程暂停/终止



## （3）频谱

> [!NOTE]
>
> 原始信号-->corrFD自相关-->DataFFT进行fft
>
> `ms_mining.cpp--selfCorrSpectrum()`

* 自相关：因子道-通道号相同，做相关。调用`handleDataFrameVec_signal`并行计算得到相关数据，存在`pCorrResult`

* 对相关数据执行fft，实部保存在`pChDataR`，虚部保存在`pChDataI`

* 对实部和虚部的平方和求平方根，得到幅值`AmplitudePt`。所有点的幅值存于`pOutSelfCorrSpectrum`

* 谱图左右对称，因此只显示一半的点即可。

* 按照文件9的格式，保存到11文件。

  9字节：频率分辨率。19字节：数据长度，`pcoParm.outLen / 2`。23字节：超前点数，为0。

* 前端读11文件，显示幅值谱（频谱）。纵轴是幅值，横轴是频率。频率=k*频率分辨率，k是点的index。

  `频率分辨率=采样频率/采样点数=（1/deltT）/ pcoParm.outLen`。

* 前端可以选定【1个频率范围】（频段）进行显示。后面可以选定【若干频段】进行显示。

## （4）测试



# 13. 速度曲线

---



# 14. 异常预测

---

### 库表

| -                  | -                                                            |
| ------------------ | ------------------------------------------------------------ |
| e_tunnel_lineInfo  |                                                              |
| e_tunnel_threshold |                                                              |
| e_tunnel_errorinfo | 由表`e_tunnel_lineInfo`和表`e_tunnel_threshold`共同得出表`e_tunnel_errorinfo`记录 |
|                    |                                                              |
|                    |                                                              |

### 代码

实时计算。对每次计算得到的偏移图中异常进行保存，保存到表`e_tunnel_lineInfo`。

`ms_mining.cpp-366-saveResult()`中先通过函数`saveLine()`保存提取异常结果到表`e_tunnel_lineInfo`。

**`ms_mining.cpp-5476-getWarningInfo()`**中通过查表`e_tunnel_threshold`和表`e_tunnel_lineInfo`，进行【k-mean聚类】得到【异常预测】结果（也即预测的地质分层面位置与夹角），保存到表`e_tunnel_errorinfo`。

**查询表`e_tunnel_errorinfo`绘制到【巷道探测示意图】。**

# 15. 预警

### 配置文件

```json
"warningTimeSyncIntval":2,//预警发送消息间隔（查表间隔），单位：min
"is_used_warning":false,//is_Used_warning接口返回值的是否使用预警（代码里实际没用它作为判断）
"warningTimeSync":false,//启用预警（实际有效的）
```

### 库表

| 表名                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| e_warningInfo_parm    | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts         | **记录了所有的微震事件。**用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info        | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
| e_warning_parm        | 暂时未用                                                     |
|                       |                                                              |

### 代码

`main.cpp-syncWarningInfo()`在子线程循环运行下面逻辑，线程每隔`hzi::config.warningTimeSyncIntval`时间休眠一次：

* 为了兼容之前代码`getWarningMsg()`函数名未修改，其中只做根据当前时间获取预警时间段的功能。调用`doWarningMsgProcess()`。

* `doWarningMsgProcess()`中，地震和电法分开。

  有地震，则查表`e_warning_level_value`获取：`msFrequency 微震频次`，`highEnergyNum 大能量事件`，`msLocation 异常区域个数`，这3个预警变量的蓝橙红等级阈值，存在`warningLevelMapMS`。**若只有地震，则表中只存地震的等级阈值，作为异常处理依据，若缺少，则抛出异常。电法同理。**

  有电法，则查表获取`e_sp_variation 自电变化量`，`ee_p_variation 视电阻率变化量`，这2个预警变量的蓝橙红等级阈值，存在`warningLevelMapEE`。**若只有电法，则表中只存电法的等级阈值。**

  若两者耦合都有，则表中需都存。

  而后分别按照下面计算各自的预警变量。

* 这5个量的值是计算得来。查表`e_msevt_rslts`（记录所有微震事件）和表`e_warningInfo_parm`（通过微震事件记录的参数计算得到5个预警变量时的一些阈值）。

* 遍历表`e_msevt_rslts`中每条记录，计算得到5个预警变量的值，代码中实际只计算了：微震频次，大能量，异常区域个数。

* 构造msg信息。`msLevelVec`分别保存：【微震频次，大能量，异常区域个数】的预警等级，计算：大于对应预警变量的阈值即为蓝橙红。

  `getMsWarningLevel()`通过`msLevelVec`中保存的【微震频次，大能量，异常区域个数】3个预警等级，综合计算，返回0/1/2/3到**【`msLevel`微震预警等级】，作为微震3个参数计算得到的预警等级**。若为1则蓝色，不为1则橙色，保存到`warningType`。

* 然后，根据电法信息，得到【电法预警等级`leveL_sp`】，作为电法2个参数计算得到的预警等级。

  再通过一定逻辑，`warningType`中已有的微震预警等级，结合电法预警等级`leveL_sp`，得到最终的【综合预警等级`warningType`】，以及【最终的msg信息】。

  `warningType`，`msLevel`，`leveL_sp`，`msg`入库表`e_warning_Info`。

* 最后，预警发送逻辑：给用户组(msg)发送蓝色和处理后的非蓝色，同时运维组也发一份(告知已发送给用户)

  ```mysql
  string sqlQuery = "SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`=1 AND `is_sent_user`=0 
  UNION 
  SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`> 1 AND `is_handle`= 1 AND `is_sent_user`= 0 "; // 取最新的一条
  ```

  蓝色（`warningType`=1）且未发送给用户，非蓝色（`warningType`> 1）且已被运维处理（`is_handle`= 1）且未发送给用户（`is_sent_user`= 0 ），这些信息发送给用户（alarm）和运维（msg)。

  ```cpp
  string cmdMsg("./send_message.sh \"msg\" \"" + string(" 【预警已发送给用户】 ") + msgTmp + "\"");// 发运维
  string cmdAlarm = "./send_message.sh \"alarm\" \"" +  msgTmp + "\""; // 发用户
  ```

  发送成功，则将表`e_warning_Info`中字段`is_sent_user`置1，表示已发送给用户。

### 预警重算

从表`e_msevt_rslts`中重新查询该时间段的微震事件，进行预警的逻辑计算，得到新的预警记录update入库表`e_warning_Info`。（工程人员会修改表`e_msevt_rslts`中的微震记录，之前的记录是系统自动判别的。）

## 接口

### 获取预警列表

> ## GET 预警列表
>
> ```cpp
> /table/:tblName/:cols/:where?
> 参数tblName：e_warning_Info
> 参数cols：查询字段名
> 参数where：WHERE查询条件
> ```
>
> ### 调用举例：
>
> * 查询已处理的10条记录：
>
>   `GET https://ahhzi.com.cn:7001/table/e_warning_Info/tm,warningType,ms_warning,ee_warning,msg:str,is_handle?is_handle=1 limit 10`
>
> ### 字段说明
>
> | 字段名      | 类型    | 说明                                       |
> | ----------- | ------- | ------------------------------------------ |
> | tm          | bigint  | 预警事件时间戳                             |
> | warningType | tinyint | 综合预警类型：0-无，1-黄色，2-橙色；3-红色 |
> | ms_warning  | tinyint | 微震预警等级：1-蓝色，2-橙色，3-红色       |
> | ee_warning  | tinyint | 电法预警等级：1-蓝色，2-橙色，3-红色       |
> | msg         | varchar | 预警信息                                   |
> | is_handle   | tinyint | 该预警是否已被运维处理：0-未处理，1-已处理 |
>
> ### 返回结果
>
> | 状态码 | 状态码含义                                                   | 说明                 | 数据模型 |
> | ------ | ------------------------------------------------------------ | -------------------- | -------- |
> | 200    | OK                                                           | 请求成功             |          |
> | 204    | [No Content](https://tools.ietf.org/html/rfc7231#section-6.3.5) | 空表或存在字段为null | Inline   |
> | 400    | Bad_Request                                                  | sql错误              |          |
> |        |                                                              |                      |          |
>
> > 返回示例
>
> > 204 Response
>
> ```json
> "not found"
> ```
>
> ### 返回数据结构
>
> json格式
>
> ```json
> {
>     "code": 0,
>     "data": [
>         {
>             "tm": 1727719200000,
>             "warningType": 2,
>             "ms_warning": 2,
>             "ee_warning": 0,
>             "msg": "微震：该时间范围内,总频次为 18,总能量为955121.000000J大能量事件 16 次且主要分布在 范围：1020.119995<x<1020.119995,280.125000<y<280.125000,730.375000<z<730.375000;微震预警橙色渗流电场:正常;视电阻率:稳定;综合预警：蓝色;",
>             "is_handle": 1
>         }
>     ]
> }
> ```



# 16. 观测系统

> [!IMPORTANT]
>
> 通道坐标，掘进里程，偏移距，掘进方向，日进尺
>
> 日进尺+掘进方向--->掘进里程
>
> 偏移距+掘进方向--->通道坐标

> 目的：迎头每天都在向前移动，可以通过【当前掘进里程-偏移距】得到传感器的坐标。
>
> 根据偏移距等计算偏移图。
>
> **现场流程：**
>
> * 自动更新：
>
>   【掘进里程】每天根据日进尺自动增加，此时传感器若未挪动，会导致【偏移距】也跟着更新增大
>
> * 手动修改：
>
>   现场的人会同时**填写**【掘进里程】和【偏移距】
>
>   【掘进里程】：当实际每日进尺和设定不一致时需要手动修正掘进里程，并**更新平均日进尺（自动更新掘进里程不重算日进尺）**。若传感器未挪动，偏移距也会跟着变化，计算出新的偏移距（如增大）
>
>   【偏移距】的**数值不会每天改**，但每天改的时候都会一起填入。只有当偏移距过大的时候，会挪动一组传感器到距离迎头一定位置处，然后**改小偏移距的数值填入**。不管【偏移距】数值变不变，都会重算传感器坐标并更新，假设【偏移距】填入数值没变，传感器坐标更新为0
>
> * `hzi::mining_locx`掘进里程，全局变量
>
> * `hzi::heading_mil`偏移距，全局变量
>
>   ![image-20250605155042299](D:\notes\笔记Img\image-20250605155042299.png)

## （1）库表

| -                     | -                                                            |
| --------------------- | ------------------------------------------------------------ |
| p_chn_types           | 通道type_id和工作类型。type_id=0是微震工作类型。             |
| e_chns_config         | 所有工作类型通道配置显示的表。保存用户输入的通道坐标。有update触发器，更新到`e_chns_config_history`。 |
| e_chns_config_history | 保存`e_chns_config`修改历史。                                |
| e_chns_config_tunnel  | （**该表已废弃**）只存微震通道。修改偏移距后，先根据delta，修改该表中通道坐标。再更新到`e_chns_config`。 |
|                       |                                                              |
| e_tunnel_cur_status   | （**已废弃**）基准通道，偏移距，掘进里程。前端发送的掘进里程和偏移距，存到全局变量后，直接入库该表。根据日进尺的自动计算也入库该表。 |
| e_mining_PCOLocParm   | 点击【当前掘进里程，修正】，只保存该按钮点击后前端发来的：掘进方向（0-x正向，1-负向），日进尺，掘进里程，修改参数的时间戳 |
| e_tunnel_locInfo      | 时间戳，日进尺，掘进里程历史和最新                           |
|                       |                                                              |
|                       |                                                              |

## （2）函数

| -                       | -                           |
| ----------------------- | --------------------------- |
| updateTunnelModelInfo() | 更新表`e_tunnel_model_info` |
| updateTunnelCurStatus() | 更新当前掘进状态            |
|                         |                             |
|                         |                             |





## （3）初始化

### `Config.hpp-initChanelsConfig()`，被`Config.hpp-init()`调用初始化通道设置。

### `Config.hpp-initChanelsConfig()`中调用了`Config.hpp-initTunnelCurStatus()`：

* 从表`e_tunnel_cur_status`读取【掘进里程】【偏移距】等。若表为空则直接对赋值`hzi::tunnel_mining_loc = 100; hzi::heading_mil = 5;auto back_distance = hzi::tunnel_mining_loc - 100;auto forward_distance = hzi::tunnel_mining_loc + 50;`，然后入库表`e_tunnel_cur_status`。

* 从`e_chns_config`中读取【基准通道坐标】。

* 若表`e_chns_config_tunnel`为空，则从表`e_chns_config`读取【`type_id=0`，微震通道】的所有记录插入表`e_chns_config_tunnel`。

### `Config.hpp-initChanelsConfig()`中调用了`Config.hpp-updateTunnelModelInfo()`：

* 从表`e_info`读取工作面长度

* 若`ms_tunnel_listen`为true，从表`e_tunnel_cur_status`读取回采位置

  为false，从表`e_mining_PCOLocParm`读取【掘进方向】，【回采位置】，【日进尺】，【时间戳`timestamp`（修改参数表当日0时刻）】。（若表`e_tunnel_locInfo`非空，则读取回采位置和日进尺覆盖）

* 根据当前时间戳`sampTime`和`timestamp`计算时间段，乘以日进尺，计算新的回采位置，再计算新的偏移距。调用函数`updateTunnelCurStatus`入库表`e_tunnel_cur_status`
* 计算采空率并入库表`e_tunnel_model_info`

### `Config.hpp-initChanelsConfig()`中调用了`Config.hpp-initTunnelGeologyStructMap()`：

* 判断表`e_geology_info`（岩性，p波s波速度）是否为空，若为空则插入若干固定值

* 判断表`e_tunnel_geology_info`（位置id，岩性）是否为空，若为空则插入若干固定值

  

## （2）自动更新掘进里程——旧代码

### 位置1（`ms_mining.cpp-L1225`）

> [!NOTE]
>
> `setPCOLocParm()`，这里只是取参数进行计算，根据日进尺和偏移方向计算回采位置，而不入库`e_tunnel_locInfo`。
>
> **但`ms_mining.cpp-L5972`，若`!hzi::config.ms_tunnel_listen`则将重算出的回采位置赋值给全局变量，虽没入库但也更新了全局**

### 位置2（`client_handle_data.cpp-L185`）

> [!NOTE]
>
> * 函数`updateTunnelModelInfo`自动更新。
>
> * `hzi::config.ms_tunnel_listen`从配置文件中读取，false则根据日进尺计算新的【掘进里程】。
>
> * 调用`updateTunnelCurStatus`更新掘进里程和偏移距到表`e_tunnel_cur_status`。（改为updateTunnelLocInfo）。
>
> * 根据【掘进里程】计算采空率。

**每天【掘进里程】和【偏移距】自动计算，实际也就是每天使用日进尺计算更新掘进里程。用偏移距更新通道坐标。**

```cpp
auto sampTime = nowMS();

//从e_mining_PCOLocParm取掘进位置和掘进方向
auto rslt = conn.executeQuery(
    "SELECT mining_locx,mining_dir,"
    "UNIX_TIMESTAMP(mining_date)AS tm ,day_step"
    " FROM `e_mining_PCOLocParm`  ORDER BY mining_date DESC "
    "LIMIT 1");
if (rslt.next())
{
    auto m_dir = rslt.getInt("mining_dir");
    mining_locx = rslt.getDouble("mining_locx");

    auto dayStep = rslt.getDouble("day_step");

    auto timestamp = rslt.getDouble("tm");

    //若e_tunnel_locInfo中有记录，用它的掘进位置和日进尺
    auto rslt2 = conn.executeQuery(
        "SELECT mining_loc,day_step  FROM `e_tunnel_locInfo`"
        " WHERE tmstamp <= ? ORDER BY tmstamp DESC LIMIT 1",(double)sampTime);
    if (rslt2.next())
    {
        mining_locx = rslt2.getDouble("mining_loc");
        dayStep = rslt2.getDouble("day_step");
    }

    int days = floor((sampTime / 1000.0 - timestamp) / 24 / 3600);
    // 根据时间戳在当日时刻，在细分进尺量
    mining_locx = (m_dir == 0) ? (mining_locx + days * dayStep) : (mining_locx - days * dayStep);
    hzi::heading_mil = mining_locx - hzi::firstChn_locx;//计算偏移距
    auto ret1 = updateTunnelCurStatus(mining_locx, hzi::heading_mil, hzi::isConnected,hzi::isRunning, "更新掘进位置", false);
}
```

## （3）手动修改偏移距

> **点击【当前掘进里程-->修正】**，调用接口`config/e_mining_PCOLocParm`，修改表`e_mining_PCOLocParm`中【掘进里程和日进尺】。只是保存参数到`e_mining_PCOLocParm`，不更新表`e_tunnel_cur_status`，因此不保存到回采历史表`e_mining_locx_history`。
>
> **点击【偏移距，修改】**，调用接口`/setHeadingMil/:typeId/:isWarning`**，调用函数`updateTunnelCurStatus`，update表`e_tunnel_cur_status`，**将前端发送的掘进里程和偏移距保存到全局变量`hzi::heading_mil`和`hzi::tunnel_mining_loc`，并入库表`e_tunnel_cur_status`（因此需要保存到回采历史表`e_mining_locx_history`）。再调用函数`updateChanelsLoc`，根据新的掘进里程和偏移距计算通道移动距离，更新表`e_chns_config_tunnel`中通道坐标。表`e_chns_config_tunnel`内容更新到表`e_chns_config`，让通道设置的显示改变。
>
> 再通过触发器将表`e_chns_config`内容更新到历史表`e_chns_config_history`
>
> 总结表更新：`e_tunnel_cur_status`，`e_chns_config_tunnel`--->`e_chns_config`--->`e_chns_config_history`

* 偏移距就是新的传感器距离迎头距离了，手动修改【偏移距】：

  `client_handle_data.cpp-433`

  ```cpp
  auto constDic = hzi::tunnel_mining_loc - hzi::heading_mil - hzi::firstChn_locx;
  //此时偏移距hzi::heading_mil是更新过的，减小了的。hzi::tunnel_mining_loc - hzi::heading_mil是挪过来的检波器和迎头的距离。即新的hzi::firstChn_locx。再减去旧的hzi::firstChn_locx，就是新旧传感器（最靠近迎头）距离迎头距离的差值。
  ```

  `client_handle_data.cpp-472`

  ```cpp
  //把e_chns_config_tunnel里每个检波器的坐标都加constDic
  "values(loc_x) + ?, loc_y=values(loc_y),loc_z=values(loc_z)";
  conn.execute(sql.c_str(), (double)localtime, (double)ts,constDic);
  //e_chns_config_tunnel坐标更新到e_chns_config
  hzi::firstChn_locx = hzi::tunnel_mining_loc - hzi::heading_mil;//经过前面的更新，将hzi::firstChn_locx更新为新的
  ```

## （4）回采位置历史记录

* 手动修改偏移距：增加表`e_mining_PCOLocParm_history`，在表`e_mining_PCOLocParm`上增加触发器，当【手动修改偏移距】时表`e_mining_PCOLocParm`新增一条记录，在history表INSERT一条记录。当修改一条记录时，在history表修改该记录。时间戳统一为当天0点。
* 自动和手动，都会调用`updateTunnelCurStatus`将当前回采位置入库到`e_tunnel_cur_status`，只有修改了表`e_tunnel_cur_status`时才会将回采位置记录到回采历史表`e_mining_locx_history`。

## （5）使用通道坐标的地方

### `handleSignalProcess()`

* 函数`setPCOLocParm()`

  从表`e_mining_PCOLocParm`读取【回采位置】【日进尺】【掘进方向】等

  若表`e_tunnel_locInfo`有【回采位置】【日进尺】则覆盖

  根据当前时刻和日进尺计算回采位置，没有入库表`e_tunnel_cur_status`，只是作为参数参加计算。（自动计算在函数`updateTunnelModelInfo`中完成，这里可能是为了提高计算精度）

  

* 函数`setPCOCalChn()`

  从表`e_chns_config_history`读取(指定时间戳前，某类型通道)的所有坐标。

  若表`e_chns_config_history`为空，则从表`e_chns_config_tunnel`读取。

## （6）会变更回采位置或偏移距的地方

* 改回采位置：`updateTunnelModelInfo`
* `initTunnelCurStatus`
* 偏移距：`ConnectServer.cpp-client_receive_frame`

## （7）会读取基准通道坐标的地方

* `initTunnelCurStatus`自动计算处

* `updateChanelsLoc`读取基准坐标计算Δx，计算通道坐标变更

* `initTunnelCurStatus`初始化基准通道坐标

* `ConnectServer.cpp-client_receive_frame`，若原始帧第9字节的【回采位置】和系统中的全局变量【回采位置】不一致时：

  调用`insertTunnelLocInfo()`将【回采位置】入库表`e_tunnel_locInfo`

  调用`updateTunnelCurStatus()`重新计算【偏移距】，入库表`e_tunnel_cur_status`

  调用`updateTunnelModelInfo()`使用表`e_tunnel_locInfo`中【回采位置】【日进尺】自动计算

# 17. 页面

---

## （1）首页

### 里程状态与偏移距

> **老代码：**
>
> ![image-20250409154122217](D:\notes\笔记Img\image-20250409154122217.png)
>
> > 基准传感器（之前代码里写死为通道1，后面改为在挪动的时候可指定通道n）距离迎头距离。4个传感器一组，距离过远把最远那一组移到迎头处。
>
> 打开页面，调用接口`/samp_conf/:tblName/:itmNames/:fromInit?`从表`e_tunnel_cur_status`中读取。
>
> 点击【修正】调用接口`config/e_mining_PCOLocParm`
>
> 点击【修改】调用接口`/setHeadingMil/:typeId/:isWarning`

* 来自表`e_mining_PCOLocParm`

  ![image-20250718172106072](D:\notes\笔记Img\image-20250718172106072.png)

* 来自表`e_tunnel_locInfo`

  ![image-20250718172202148](D:\notes\笔记Img\image-20250718172202148.png)

* 里程错输

  错输里程，先输入了很大的里程，可能点了计算通道坐标并保存，也可能没点。现在输入一个小里程（沿X向），则判定之前输入的里程可能错误，弹出确认框【是否删除上一条记录】。若用户点击确认，则表示上一条记录为错输，要删除。

  * `e_tunnel_locInfo`要删除上一条记录

  * `e_chns_config_history`要删除，`locInfo`错输记录时间戳t对应的通道坐标。取时间戳t加减一个小时间段，作为delete筛选条件。

    ```mysql
    -- 删除通道历史表中错输记录
    DELETE FROM e_chns_config_history
    WHERE updatetime BETWEEN DATE_SUB('2025-07-25 09:48:06.0000', INTERVAL 40 SECOND)
                        AND DATE_ADD('2025-07-25 09:48:06.0000', INTERVAL 40 SECOND);
    ```

  * `e_chns_config`必须重新计算并保存

  * 表`locInfo`里最新插入的记录的日进尺，需根据最新插入的里程和删除错输记录后的上次里程之差计算





### 巷道探测示意图

> 显示预测的地质异常（地质分层的位置和角度）

![image-20250422131919742](D:\notes\笔记Img\image-2025042213191974211)

## （2）系统

### 工程参数

#### 停止监测

下发命令字:5,设备地址:1,字节数:22,命令标识:101327

#### 启动监测

250408 09:12:50 下发命令字:2,设备地址:1,字节数:54,命令标识:101328
250408 09:12:50 下发命令字:5,设备地址:1,字节数:22,命令标识:101329
250408 09:12:55 下发命令字:3,设备地址:1,字节数:278,命令标识:101330
250408 09:13:15 下发命令字:4,设备地址:1,字节数:38,命令标识:101331

#### 通道配置

> * 用户修改指定基站连接的通道配置信息。
> * 显示的是表`e_chns_config`。

* 修改【工程位】（location2）/【地层位】（location1）/【状态】（state_id），调用接口`/table/`，载荷为`dev_id`，`chn_no`+`location2`/`location1`/`state_id`，修改库表`e_chns_config`中字段。

  其中state_id中状态从库表`p_chn_states`读取。

#### 采集置参

| 库表             | 微震采集参数                                                 | 说明 |
| ---------------- | ------------------------------------------------------------ | ---- |
| e_ms_samp_config | 采样间隔，采样点数，超前点数，触发方式，微震触发脉宽，背景采样间隔（微震背景极值检测时窗），（背景上传时窗）微震背景极值上传时窗，（振铃阈值）微震背景振铃检测阈值 |      |
| e_ms_trig_params | 触发通道智能剔除，触发通道剔除判断时间，微震背景数据类型，触发通道数，触发时窗 |      |
|                  |                                                              |      |

| 微震采集参数                         | 库表                            | 变量                     | 说明                   |
| ------------------------------------ | ------------------------------- | ------------------------ | ---------------------- |
| 采样间隔                             | e_ms_samp_config，p_samp_intvls | hzi::msEvtCnf.sampIntvl  |                        |
| 采样点数                             | e_ms_samp_config，p_points      |                          |                        |
| 超前点数                             | e_ms_samp_config，p_points      | hzi::msEvtCnf.msAheadPnt |                        |
| 触发方式                             | e_ms_samp_config，p_ms_trigs    |                          | 0-全时触发，1-阈值触发 |
| 触发通道智能剔除                     | e_ms_trig_params                |                          |                        |
| 触发通道剔除判断时间（s)             | e_ms_trig_params                |                          |                        |
| 微震背景数据类型                     | e_ms_trig_params                |                          |                        |
| 触发通道数                           | e_ms_trig_params                | hzi::msEvtCnf.msTrigChns |                        |
| 触发时窗                             | e_ms_trig_params                | hzi::msEvtCnf.msTrigWin  |                        |
| 微震触发脉宽                         | e_ms_samp_config                | hzi::msEvtCnf.pulsWid    |                        |
| 背景采样间隔（微震背景极值检测时窗） | e_ms_samp_config，p_time_wins   |                          |                        |
| 背景上传时窗（微震背景极值上传时窗） | e_ms_samp_config，p_time_wins   |                          |                        |
| 振铃阈值（微震背景振铃检测阈值）     | e_ms_samp_config                | hzi::msEvtCnf.ringThrld  |                        |

| -                        | 库表                 | 说明                                                         |
| ------------------------ | -------------------- | ------------------------------------------------------------ |
| **saveDevConfig()**      |                      |                                                              |
|                          | e_tempr_samp_config  | 入库表，温度采样参数                                         |
|                          | e_coupl_samp_config  | 入库表，耦合采样参数                                         |
|                          | e_samp_auto_gain     |                                                              |
|                          |                      |                                                              |
| **insertDataIntoDb()**   |                      |                                                              |
|                          | e_start_monitor_time | cmd_id=4时的启动监测下发命令入库（cmd_seq，dev_addr，start_time） |
|                          | e_net_info           | cmd_id=6时的ip设置下发命令入库（dev_addr，dev_ip，dev_mac，dev_port...） |
|                          |                      |                                                              |
| **readStationInfoMap()** |                      |                                                              |
|                          | e_station_info       | 记录：基站监测命令应答帧入库                                 |
|                          | p_station_schemas    | 映射：（id，基站工作模式）                                   |
|                          |                      |                                                              |
| **readDevClockMap()**    |                      |                                                              |
|                          | e_dev_clock          | 记录：时间校准命令应答帧入库                                 |
|                          |                      |                                                              |
| **readDevConfigMap()**   |                      |                                                              |
|                          | e_dev_config_ack     | 记录：采集置参命令应答帧入库                                 |
|                          |                      |                                                              |

> [!NOTE]
>
> * 点击【保存】后，调用接口`/cmds/:cmd_id/:dev_id?`3次，`cmd_id`分别为2/5/3
>
>   > * **cmd::sendCmd()**
>   >
>   >   > * cmdId == 2
>   >   >
>   >   >   > * Time::setValues()——将当前日期时间存于upBuf
>   >   >
>   >   > * cmdId == 3
>   >   >
>   >   >   > * DevConfig::setValues()——从doc中构建采集参数配置帧数据区存于upBuf
>   >   >   > * saveDevConfig()——将从doc中解析出的存于upBuf的采样参数和少部分doc中未存于upBuf的采样参数**入库表**。
>   >   >
>   >   > * cmdId == 4
>   >   >
>   >   >   > * StartMonitor::settimestamp()
>   >   >   > * hzi::initChanelsConfig()
>   >   >   > * calcEmitTimes()
>   >   >   > * StartMonitor::setValues()——当前时间+30s并取整作为启动时间存于upBuf
>   >   >
>   >   > * cmdId == 6
>   >   >
>   >   >   > * IpInfo::setValues()——从doc中解析读取ip，mac等参数
>   >   >
>   >   > * sender::sendCmd()——下发命令帧
>   >   >
>   >   > * devaddrAndCmdseqMap——(dev_id，cmdseq)，基站号和发送给该基站的最新一条命令的cmd_seq
>   >   >
>   >   > * insertDataIntoDb()——在这里单独处理cmd_id=4or6时下发命令帧的入库，不放在`handleRecvCmd()`处（**cmd_id==4为采集数据，会不断上传，因此只入库下发帧。**上位机不对5/6/7/8/9应答帧做处理。或是下位机对这5种下发命令帧无应答？）
>   >   >
>   >   > * responseDataMap()——轮询数据库，当前的下发命令帧是否从下位机那里得到应答帧并入库。通过轮询若干次和sleep，提供下位机应答时间和receive应答帧入库时间。
>   >   >
>   >   >   > * hzi::config.recvTries——等待下位机应答帧信息成功入库，轮询次数（每次查询后sleep若干时间）
>   >   >   > * cmd_id==1基站检测，readStationInfoMap()——查询表`e_station_info`，结果拼字符串返回
>   >   >   > * cmd_id==2时间校准，readDevClockMap()——查询表`e_dev_clock`，结果拼字符串返回
>   >   >   > * cmd_id==3采集置参，readDevConfigMap()——查询表`e_dev_config_ack`，结果拼字符串返回

### 随掘监测

#### 实时参数

* 将参数保存到表`e_mining_PCOSignalParm`和`e_mining_PCOLocParm`。

| 页面参数                   | 库表参数`e_mining_PCOSignalParm` | 参数说明                                                     |
| -------------------------- | -------------------------------- | ------------------------------------------------------------ |
| 用户参数->【拼接数据类型】 | `class_id`                       | 实时计算取用的数据类型，是【全时/背景】。`threadHanleData()` |
| 用户参数->【监测前方距离】 | `mark_XLen`                      | 超前探测距离。偏移图横轴长度。                               |
| 用户参数->【监测频度】     | `dataFreq`                       |                                                              |
| 干涉源提取->【数据时长】   | `dataLen`                        | 数据时长（单位时间min)（`时间段/数据时长=炮数`），历史计算代码里是`time_len`即页面上的【分段时长】，实时计算代码里用的是`hzi::miningDateLen` |
| 干涉源提取->【因子时长】   | `coeLen`                         | 因子系数长度(时间单位：min)                                  |
| 干涉源提取->【超前点数】   | `coefBegPt`                      | CSP道集提取用到。                                            |
| 干涉源提取->【输出点数】   | `outLen`                         | 输出及其长度(时间单位ms)                                     |
| 干涉源提取->【因子道】     | `chn_no`                         | 选用因子通道号                                               |
|                            |                                  |                                                              |



## （3）监测

### ①实时数据

#### 微震全时

![image-20250417103359063](D:\notes\笔记Img\image-202504171033590631)

### ②历史数据

#### 微震全时

点击【刷新】后，调用接口：

`table/e_data_frm_info/frm_loc:str/class_id=6 and round(unix_timestamp(samp_time),3)>=1747678200 and round(unix_timestamp(samp_time),3)<1747678320 order by samp_time`

多个`data_file/2025/5/20/6/1747678317500`，把`1747678200 ~ 1747678320 `时间范围之间的文件都取过来。

`table/e_chns_config/chn_label:str,state_id/dev_id=1 and type_id=(select ch_type_id from p_data_types where type_id=6)`（表`e_chns_config`中`type_id`：通道工作类型id）

## （4）随掘

### 随掘地震

> **该页面上属于历史重算。**
>
> **历史重算目的：通过偏移图进行验证输入的参数的效果。把效果好的参数填入实时参数内，然后进行自动处理，并保存为文件。**

#### 树形图

> **查询表`e_mining_pcodata_frm_info`获取数据时间戳。**表`e_mining_pcodata_frm_info`若没记录，表`e_mining_signaldata_frm_info`即使有记录树形图也不会有选项。

* 点击树形图的时间戳后：调用接口`/data_file/:year/:month/:day/:type/:timestamp`

![image-20250415161308369](D:\notes\笔记Img\image-20250415161308369.png)

* 参照园区试验系统->监测->微震事件，解决需求【自动干涉后记录有效标记，无效删除】，在表【e_mining_signaldata_frm_info】中增加字段【isValid】，让用户自己给树形图中项目增加是否有效的标记。

#### 波形显示控件

* **波形显示控件**在接收到接口`/handerSignal/`的固定格式的response后，**从response中解析出时间戳，**通过接口`data_file`取文件。

* 根据表`e_chns_config`字段**`state_id`和`is_ms_trig`**共同决定是否显示某一道的波形。

* **波形显示控件**打开页面时，会显示树形图最新的一个文件的图。点击时间树时，会显示点击时间树时间的图。

  ```cpp
  string rslt("{");
  rslt += "\"ms_miningSignal\": \"";
  rslt += std::to_string(hzi::config.ms_miningSignal);
  rslt += "\",";
  rslt += " \"tm\": \"";
  string filepath = std::to_string(xcorrData.Head().sampleTime);
  rslt += filepath;
  rslt += "\" } ";
  response.headers().add<Http::Header::ContentType>("application/json; charset='utf-8'");
  response.send(Http::Code::Ok, rslt);
  ```

#### 干涉源提取

> * 点击黄色按钮**【干涉源提取】**。
>
> * 页面上的干涉源提取属于历史重算。只做干涉源提取+偏移（干涉提取图+干涉提取基础上的偏移图），再提取+偏移需手动执行。
>
> * 手动选择时间段，进行干涉（互相关或自相关）得到`提取数据(class_id=9)`和`干涉提取波形图`。并在提取数据和提取图的基础上，按照左侧设定的偏移参数进行偏移得到`偏移数据(class_id=10)`的`偏移图`。
>
> * 重算所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
> 
>   > 若用背景原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。
>   >
>   > 若用全时原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。
> 
> 时间段不要选太大，一般几分钟，否则数据太多响应很慢。
> 
> 分段时长，一般设置和时间段一样大。

* 分段时长：`时间段/分段时长=炮数`。代码逻辑中，时间戳转ms，（开始-结束）/分段时长，得到`dataSize`，即炮数。若干炮数的数据叠加（简单的幅值叠加）。

  ![image-20250416141111347](D:\notes\笔记Img\image-20250416141111347.png)

* 调用接口`/handerSignal/:from_time/:to_time/:time_len/:devId`（time_len即分段时长），回调`handleSignalProcess(dfvec, false,dev_id)`，只进行干涉提取。

* 从表`e_mining_PCOSignalParm_history`中查询`hzi::miningFreq`，`hzi::miningDateLen`，`hzi::mining_classId`。

* 内部调用`mergeMs`拼接帧数据，再调用`handleSignalProcess`进行处理。

* 调用`handleSignalProcess(dfvec, false,dev_id)`，其中`false`表示进行历史计算。

* **但页面上，和【实时参数-数据时长】会写入库表`dataLen`不同的是。历史计算的【分段时长】并没有入库。**

#### 信号处理

> * 属于历史计算。
>
> 根据设定好的计算参数对当前选中时间戳的提取数据，**进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`**，并在再提取数据和再提取波形图的基础上，得到新的偏移图。
>
> * **需手动点击【执行】，调用接口`/handerExtSignalParm/:samp_time/:typeId`，回调`handerExtSignalParm`，调用函数`handleExtSignalData`根据时间戳读取上面干涉源提取得到的类型9文件，使用提取文件再次进行后续处理。在`handleExtSignalData`里调用了`PureCommonOperation::handleSignalData`**

![image-20250415161001067](D:\notes\笔记Img\image-20250415161001067.png)

* 点击【执行】后会依次调用接口`/config/:tblName`，回调`setConfig`，将页面上的参数写入表`e_mining_PCOSignalParm_history`。

* 接口`/handerExtSignalParm/:samp_time/:typeId`，回调handleExtSignalData`读取类型9文件进行除干涉提取以外的计算处理。

  ![image-20250415161431325](D:\notes\笔记Img\image-20250415161431325.png)

![image-20250415161517845](D:\notes\笔记Img\image-20250415161517845.png)

![image-20250415161559236](D:\notes\笔记Img\image-20250415161559236.png)

#### 提取图上选项

![image-20250509111846311](D:\notes\笔记Img\image-20250509111846311-1746760727617-1.png)

## （5）分析

### 日报发布

### 日报查询

| -                                    | -                                                            |
| ------------------------------------ | ------------------------------------------------------------ |
| /daily_sheet_dates                   | 获取日报pdf文件文件名的json。                                |
| /post_daily_sheet/:name              | 将日报pdf文件以【年-月-日.pdf】的名称作为参数name，重命名文件，二进制类型，发送到后端。 |
| /daily_sheet/:year/:month/:day/:file | 从服务器获取日报pdf文件。                                    |

前端页面里在代码里拼的url，使用的`daily_sheet`获取的pdf，使用`iframe`打开：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test pdf</title>
</head>

<body>
    <iframe src="../daily_sheet/2022/3/15/DailySheet.pdf" frameborder="0"></iframe>
</body>

</html>
```

# 18. 通道类型

---

| type_id | 数据类型                  | 通道数                              | 通道label           |
| ------- | ------------------------- | ----------------------------------- | ------------------- |
| 0       | 微震采集                  | datachns[2/3/6]                     | dataChnLabel[2/3/6] |
| 1       | 电法采集                  | datachns[0/1]                       | dataChnLabel[0/1]   |
| 2       | 电法发射eeChannel（激电） |                                     |                     |
| 3       | 电磁采集                  |                                     |                     |
| 4       | 温度采集                  | datachns[4]                         |                     |
| 5       | 电法B极                   | datachns[0]+datachns[2]+datachns[4] | dataChnLabel[5]     |
| 6       | 电法N极                   |                                     |                     |

# 19. 接口

---

> 接口名：routes.cpp
>
> 回调函数：commands.cpp，ms_commands

## 接口模板

```cpp
//GET请求 
Routes::Get(RoutesManager::router, "/devices",
              Routes::bind(&cmd::getDevices));

//POST请求 
Routes::Post(RoutesManager::router, "/save_devices",
              Routes::bind(&cmd::saveDevices));

//request解析
if(!request.hasParam(":from_time") || !request.hasParam(":to_time"))//判断参数是否存在
{
  response.send(Http::Code::Bad_Request, "缺少参数：起止时间");
  return;
}
uint64_t fromTime = request.param(":from_time").as<uint64_t>();
uint64_t endTime = request.param(":to_time").as<uint64_t>();

//response相关
response.headers().add<Http::Header::ContentType>(MIME(Text, Plain));//设定response响应头

//发送
response.send(Http::Code::Expectation_Failed, "重算失败");//直接传字符串
string err = "error";
response.send(Http::Code::Expectation_Failed, "重算失败：" + err); //传字符串+string
response.send(Http::Code::Expectation_Failed, err.c_str());//只传string要转char*
```

```cpp
  void getDevices(const Rest::Request &request, Http::ResponseWriter response)
  {
    try
    {
      response.headers().add<Http::Header::ContentType>("application/json");
      //string devices = "{";
      string devices="{\"devices\":[";
      string id;
      string device_ip;
      string device_port;
      string server_port;
      auto iter = hzi::config.devicesMap.begin();
      for (; iter != hzi::config.devicesMap.end(); iter++)
      {
        id = std::to_string(iter->second.id);
        device_ip = iter->second.devIp;
        device_port = std::to_string(iter->second.devPort);
        server_port = std::to_string(iter->second.serverPort);
        std::ostringstream oss;
        oss << "{" << "\"id\":" << id << ",\"device_ip\":\"" << device_ip << "\",\"device_port\":" + device_port + ",\"server_port\":" + server_port + "}";
        string device = oss.str();
        // string device = std::format("{id: {0}, device_ip: {1}, device_port: {2}, device_port: {3}}",id,device_ip,device_port,sever_port);
        devices += device;
        devices += ",";
      }
      devices.pop_back();
      devices += "]}";
      response.send(Http::Code::Ok, devices.c_str());
    }
    catch(const std::exception &e)
    {
      response.send(Http::Code::Bad_Request, e.what());
    }
  }
```

## apifox测试接口

```url
https://192.168.74.37:11507/devices
https://192.168.74.37:11507/save_devices/sys_config.json
```

## 状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | 成功                                                         |
| 405    | 接口的方法类型搞错了。比如一个接口是POST方法，发了GET请求    |
| 204    | 成功响应但是没有返回内容，No Content                         |
| 413    | HTTP 状态码 **413 Content Too Large**（内容过大）表示客户端发送的请求实体超过了服务器定义的大小限制。服务器可能会关闭连接或返回一个 *Retry-After* 头字段 |
| 417    | HTTP 417 错误，即**“Expectation Failed”**                    |
|        |                                                              |



## 接口汇总

| 我写的或修改过的接口                | 功能                                                         | 用法                                              |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| /upload_save_warningImg/:name       | 上传图片并入库                                               | name传图片名称，包括后缀名                        |
| /upload_doc/:mime/:name             | 文件上传：图片，pdf，xlsx，csv，zip                          | mime传后缀名，name传文件名包括后缀名              |
| /download_doc/:mime/:name           | 下载文件：图片，pdf，xlsx，csv，zip                          |                                                   |
| /configFilePath                     | 获取配置文件路径                                             |                                                   |
| /firstChnNO                         | 获取基准通道号                                               |                                                   |
| /devices                            | 获取配置文件中devices字段信息                                |                                                   |
| /update_devices/:jsonName           | 修改配置文件中devices字段信息                                | jsonName传配置文件名，包括etc/                    |
| /semt                               | 用户登录。改了`verifyUser`函数。                             |                                                   |
| /nopswd                             |                                                              |                                                   |
| /warning_recalc/:from_time/:to_time | 预警历史重算：e_warning_info表删除指定时间段内已有预警信息，从e_msevt_rslts中重新筛选记录经过计算入库。 |                                                   |
| /table/:tblName/:delCondition?      |                                                              | 我增加了：function类型，用于传SQL函数作为插入值。 |
|                                     |                                                              |                                                   |

| 接口汇总                                                     | 功能                                                         | 使用方法                                                     | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| MySQL增删改查                                                |                                                              |                                                              |                                                              |
| /update_columns/:tblName/:condition                          | 修改已有记录的字段值                                         |                                                              |                                                              |
| /table/:tblName/:cols/:where?                                | 查询表。                                                     | `table/e_chns_config/chn_label:str,state_id/dev_id=1 and type_id=(select ch_type_id from p_data_types where type_id=6)` | 查询的列，若存在任一列值为null则返回`No_Content`。cols存要查询的列名。**cols若写成`列名:str`，则字段值用字符串形式输出。**where写查询条件。**查询结果**整体方括号，每条记录花括号，若值是字符串用引号包裹：[{"chn_label":"S1GR01","state_id":0},{"chn_label":"S1GR02","state_id":0}] |
| /table/:tblName/:delCondition?                               | 插入（修改）记录或删除记录                                   | delCondition传入true为【删除所有记录】，若传入查询条件则【删除条件筛选】出来的记录；然后再插入。若想不清空表，则delCondition不要填入值。values中传值，schema中传值对应的类型type，有：string,float,double,int64等。传入null时，代码里没有类型没有处理其类型，直接传入会报错，为null的字段不传即可。 | delCondition传"true"则清空表，传其他字符串则会作为删除WHERE后的条件。                                                                                                                                                                                 若payload传json，则会继续执行插入（修改）操作：`schema`字段为数组`{"schema":[ {"name":"mining_date", "type":"string"}, {"name":"mining_locx", "type":"float"}, {"name":"day_step", "type":"float"}],"values":[["2025-04-27 00:00:00.0000", 1300, 10],["2025-04-28 00:00:00.0000", 1300, 11]]}`，传表所有字段名`name`和类型`type`（string，float，double，int64）；`values`传字段的对应值。注意：datetime类型字段，后台没专门写，type写string。我增加了：function类型，用于传SQL函数作为插入值。 |
|                                                              |                                                              |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
| /setHeadingMil/:typeId/:isWarning                            | 修改偏移距                                                   |                                                              |                                                              |
| /config/:tblName                                             |                                                              |                                                              | 根据传入json的`is_init`字段：为true时，先删除指定表中`is_init==1`的记录。为false时，先`TURNCATE`清空表。最后，把记录值`INSERT`插入表，is_init置1。 |
| /handerSignal/:from_time/:to_time/:time_len/:devId           | 历史计算                                                     |                                                              |                                                              |
| /handerSignalMining/:from_time/:to_time/:time_len/:devId     | 历史计算（mining？）                                         |                                                              |                                                              |
| /download/:from_time/:to_time/:is_csv/:file_name             | 选中时间段内原始数据（根据hzi::mining_classId决定类型3/6）拼帧并打包为zip下载 | is_csv=0-bin文件/1-csv文件/2-qfx文件。file_name未用。        |                                                              |
| /download/:type_id/:from_time/:to_time/:is_csv/:file_name/:only_ms_valid? |                                                              |                                                              |                                                              |
| /samp_conf/:tblName/:itmNames/:fromInit?                     |                                                              |                                                              |                                                              |
| /daily_sheet/:year/:month/:day/:file                         | 从data_root下获取文件                                        |                                                              |                                                              |
| /daily_sheet_dates                                           | 以json形式返回data_root下的年月日的pdf文件，文件名类似2025-5-1.pdf。json形式是年字段下数组为月数组，月数组下为日字段对应文件的路径。 |                                                              |                                                              |
| /post_daily_sheet/:name                                      |                                                              |                                                              |                                                              |
| /data_file/:year/:month/:day/:type/:timestamp                |                                                              |                                                              |                                                              |
| /handerExtSignal/:samp_time/:typeId                          | 回调：`handerExtSignal`，回调调用`processMethods`，这个函数。使用提取信号再次进行后续的再提取和偏移。 |                                                              |                                                              |
| /handerExtSignalParm/:samp_time/:typeId                      | 回调：`handerExtSignalParm`，回调调用`handleExtSignalData`   |                                                              |                                                              |
| /handerExtSignalPianYi/:from_time/:to_time                   | 用指定时间段的提取文件（9），调用saveResult()生成偏移文件（10） |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
| **采集**                                                     |                                                              |                                                              |                                                              |
| /change_ms_trig                                              |                                                              |                                                              |                                                              |
| **/cmds/:cmd_id/:dev_id?**                                   | 详见页面-采集置参                                            |                                                              |                                                              |
| /handerPickDataTime/:from_time/:to_time/:classID             | 数据提取                                                     |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
| **日报**                                                     |                                                              |                                                              |                                                              |
| /daily_sheet_dates                                           | 获取日报pdf文件文件名的json。                                |                                                              | 遍历`data_root`下所有目录（看作年份目录），再遍历年份目录下的目录（看作月份目录），再遍历月份目录下的目录（看作日目录），将年-月-日.pdf作为文件名。最后将年，月，日写为json的树状结构，日作为字段，文件名作为值。json字符串发送给前端。json形如：`{2025: {5: {1: "2025-5-1.pdf", 2: "2025-5-2.pdf"}}}` |
| /post_daily_sheet/:name                                      | 将日报pdf文件以【年-月-日.pdf】的名称作为参数name，重命名文件，二进制类型，发送到后端。 |                                                              |                                                              |
| /daily_sheet/:year/:month/:day/:file                         | 从服务器获取日报pdf文件。                                    |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
| /ms_mining                                                   | 无随采返回false，有随采返回true                              |                                                              |                                                              |
| /latest/:type/:lastTime                                      | 查询表`e_data_frm_info`中，lastTime时间之后最新的记录的对应的文件。若lastTime传0，则直接返回最新的一条。 |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |





# 20. 数据库

---

> * 使用开源库`libzdb`
>
> * 凡是查表，一定要考虑表为空的情况，增加查不到记录时的边界条件判断，增加软件健壮性。
>
> ```cpp
> Connection conn = hzi::config.pConnPool->getConnection();
> ```

> [!NOTE]
>
> ```cpp
> auto rslt = conn.executeQuery(
>     "SELECT mining_locx,mining_dir,mark_XLen,"
>     "dXGrdLen,dYGrdLen,dZGrdLen,UNIX_TIMESTAMP(mining_date)AS tm ,day_step"
>     " FROM `e_mining_PCOLocParm`  ORDER BY mining_date DESC "
>     "LIMIT 1");
> auto rslt2 = conn.executeQuery("SELECT `mining_loc`,`day_step` FROM e_tunnel_locInfo ORDER BY tmstamp DESC LIMIT 1");
> if (rslt.next())
> {
>     //这里
> }
> ```
>
> 

## 查询

```cpp
//zdbpp.h
int columnCount() {
    return ResultSet_getColumnCount(t_);
}

const char *columnName(int columnIndex) {
    except_wrapper( RETURN ResultSet_getColumnName(t_, columnIndex) );
}

long columnSize(int columnIndex) {
    except_wrapper( RETURN ResultSet_getColumnSize(t_, columnIndex) );
}

void setFetchSize(int prefetch_rows) {
    ResultSet_setFetchSize(t_, prefetch_rows);
}

int getFetchSize() {
    return ResultSet_getFetchSize(t_);
}

bool next() {
    except_wrapper( RETURN ResultSet_next(t_) );
}

bool isnull(int columnIndex) {
    except_wrapper( RETURN ResultSet_isnull(t_, columnIndex) );
}

const char *getString(int columnIndex) {
    except_wrapper( RETURN ResultSet_getString(t_, columnIndex) );
}

const char *getString(const char *columnName) {
    except_wrapper( RETURN ResultSet_getStringByName(t_, columnName) );
}

int getInt(int columnIndex) {
    except_wrapper( RETURN ResultSet_getInt(t_, columnIndex) );
}

int getInt(const char *columnName) {
    except_wrapper( RETURN ResultSet_getIntByName(t_, columnName) );
}

long long getLLong(int columnIndex) {
    except_wrapper( RETURN ResultSet_getLLong(t_, columnIndex) );
}

long long getLLong(const char *columnName) {
    except_wrapper( RETURN ResultSet_getLLongByName(t_, columnName) );
}

double getDouble(int columnIndex) {
    except_wrapper( RETURN ResultSet_getDouble(t_, columnIndex) );
}

double getDouble(const char *columnName) {
    except_wrapper( RETURN ResultSet_getDoubleByName(t_, columnName) );
}

template <typename T>
std::tuple<const void*, int> getBlob(T v) {
    int size = 0;
    const void *blob = nullptr;
    if constexpr (std::is_integral<T>::value)
        except_wrapper( blob = ResultSet_getBlob(t_, v, &size) );
    else
        except_wrapper( blob = ResultSet_getBlobByName(t_, v, &size) );
    return {blob, size};
}

//返回时间戳，（time_t是时间戳epoch到现在的seconds)
time_t getTimestamp(int columnIndex) {
    except_wrapper( RETURN ResultSet_getTimestamp(t_, columnIndex) );
}

time_t getTimestamp(const char *columnName) {
    except_wrapper( RETURN ResultSet_getTimestampByName(t_, columnName) );
}

//返回datetime，（tm是结构体存有年月日时分秒）
struct tm getDateTime(int columnIndex) {
    except_wrapper( RETURN ResultSet_getDateTime(t_, columnIndex) );
}

struct tm getDateTime(const char *columnName) {
    except_wrapper( RETURN ResultSet_getDateTimeByName(t_, columnName) );
}

struct tm
{
    int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
    int tm_min;			/* Minutes.	[0-59] */
    int tm_hour;			/* Hours.	[0-23] */
    int tm_mday;			/* Day.		[1-31] */
    int tm_mon;			/* Month.	[0-11] */
    int tm_year;			/* Year	- 1900.  */
    int tm_wday;			/* Day of week.	[0-6] */
    int tm_yday;			/* Days in year.[0-365]	*/
    int tm_isdst;			/* DST.		[-1/0/1]*/

    # ifdef	__USE_MISC
    long int tm_gmtoff;		/* Seconds east of UTC.  */
    const char *tm_zone;		/* Timezone abbreviation.  */
    # else
    long int __tm_gmtoff;		/* Seconds east of UTC.  */
    const char *__tm_zone;	/* Timezone abbreviation.  */
    # endif
};
```

```cpp
string sqlQuery="";
Connection conn = hzi::config.pConnPool->getConnection();
ResultSet rslt = conn.executeQuery(sqlQuery.c_str(),val,val,val);
if(!rslt)
{
    cout<<"查询结果为空"<<endl;
}
//或是直接写字符串
auto rslt = conn.executeQuery("",val,val,val);
if(!rslt)
{
    cout<<"查询结果为空"<<endl;
}

//常用获取字段函数
rslt.getInt("field");
rslt.getDouble("field");
rslt.getString("field");

//封装executeQuery
template <typename... Args>
tl::expected<ResultSet, std::string> queryDb(Connection &conn, const char *sql, Args... args) 
{
  try 
  {
    ResultSet result = conn.executeQuery(sql, args...);
    if (result.next()) 
    {
      return result;
    } 
    else 
    {
      return tl::make_unexpected("not found in query: " + std::string(sql));
    }
  } 
  catch (zdb::sql_exception &e) 
  {
    return tl::make_unexpected("sql error for " + std::string(sql) + ": " + std::string(e.what()));
  }
}
bool ret = queryDb(conn,"SELECT * FROM e_users where user_name=? and password=PASSWORD(?)",user, pswd)?true:false;

queryDb(conn, sql.c_str()) 
    .map([&](ResultSet set)
     {
         
     }
    .map_error([&](auto err)
     {
         
     }
```

```cpp
//查询有记录则返回，否则返回字符串异常
template <typename... Args>
tl::expected<ResultSet, std::string> queryDb(Connection &conn, const char *sql, Args... args) 
{
  try 
  {
    ResultSet result = conn.executeQuery(sql, args...);
    if (result.next()) 
    {
      return result;
    } 
    else 
    {
      return tl::make_unexpected("not found in query: " + std::string(sql));
    }
  } 
  catch (zdb::sql_exception& e) //sql_exception定义在zdbpp.h中
  {
    return tl::make_unexpected("sql error for " + std::string(sql) + ": " + std::string(e.what()));
  }
  catch (std::exception& e) 
  {
    return tl::make_unexpected(std::string(e.what()));
  }
}
```

```cpp
//方法的作用是检查指定列索引的值是否为 SQL 空值（NULL）。如果该列的值为 NULL，则返回 true；否则返回 false
//columnIndex从1开始
bool ResultSet::isnull(int columnIndex);

//下一条记录
bool ResultSet::next();

const char* ResultSet::getString(int columnIndex);//columnIndex从1开始
const char* ResultSet::getString(const char* columnName);
```



## 插入/删/改（若存在则更新）

> [!NOTE]
>
> * INSERT 和 UPDATE 触发器都可能被触发
>
> * **自增ID**：即使执行的是 UPDATE，自增ID也会增加
>
> * `ON DUPLICATE KEY UPDATE`语句中：
>
>     **明确列在 `UPDATE` 部分的字段**：会被更新为新值（使用 `VALUES(column_name)` 或指定的值）
>
>   **未列在 `UPDATE` 部分的字段**：会保持原来的值不变

```cpp
string sql = "INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)";
conn.execute(sql.c_str(), val,val,val);

//或
conn.execute("INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)", val1,val2,val3,val4,val5,val6,val7);
```

## 存储过程

```cpp
//prepareStatement的sql语句需要直接在括号内写字符串，不能先定义为string再传值
Connection conn = hzi::config.pConnPool->getConnection();
PreparedStatement prp = conn.prepareStatement("INSERT INTO e_tunnel_locInfo (mining_loc,tmstamp) values(?,?) ON DUPLICATE KEY UPDATE tmstamp = values(tmstamp)");
conn.beginTransaction();
prp.bind(1, mining_locx);
prp.bind(2, (double)tmstamp);//时间戳转成double再存
prp.execute();
conn.commit();
```

```cpp
function "zdb::PreparedStatement::bind(int, int)" (declared at line 394)
function "zdb::PreparedStatement::bind(int, long long)" (declared at line 398)
function "zdb::PreparedStatement::bind(int, double)" (declared at line 402)
function "zdb::PreparedStatement::bind(int, time_t)" (declared at line 406)
```

## 表更新

```cpp
//where?表示where可选，可不传值
//SELECT [cols冒号左侧为字段名field1,field2,...] FROM [tblName] [where];
//response：{"code":0,"data":[{"field1":"field1Val"},{"field2":"field2Val"},...]}
Routes::Get(RoutesManager::router, "/table/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData));//表查询
Routes::Get(RoutesManager::router, "/table1/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData1));//queryTblData1用的是pTempConnPool
```

```cpp
//UPDATE tblName set [请求体updates字段值] where [condition]
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));

//
Routes::Post(RoutesManager::router, "/update/:tblName/:refCol/:updateCol",
               Routes::bind(&cmd::updateColumnRef));

//delCondition传true：delete from [tblName]
//传where语句：delete from [tblName] where ...
//若请求体中有schema和values，遍历json数组schema获取要更新的字段名，遍历json数组value获取要更新的字段的值。请求体中还应有type，指明字段值的类型是string/float/double/int64：insert into [tblName] (field1, field2,...)values('value11','value12',...),('value21','value22',...) on duplicate key update field1=values(value1),field2=values(value2)...;插入多条记录，若有主键相同的记录改为update修改(on duplicate key)
Routes::Post(RoutesManager::router, "/table/:tblName/:delCondition?",
               Routes::bind(&cmd::updateTable));//表增删改


//UPDATE [tblName] set [请求体updates字段值] where [condition].
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));
```

* `response.headers().add<Http::Header::ContentType>("text/plain; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `text/plain`。这表示服务器返回的内容是纯文本格式
* `response.headers().add<Http::Header::ContentType>("application/json; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `application/json; charset='utf-8'`。这表示服务器返回的内容是JSON格式，并且使用UTF-8字符集进行编码。

## 变量与表对应

| 变量                                           | 表名                                                 | 说明 |
| ---------------------------------------------- | ---------------------------------------------------- | ---- |
| hzi::viewSpace                                 | e_space                                              |      |
| hzi::densityGrays                              | p_density_grays                                      |      |
| hzi::densityColors                             | p_density_colors                                     |      |
| hzi::msEvtCnf.sampIntvl                        | p_samp_intvls                                        |      |
| hzi::msEvtCnf.msAheadPnt                       | p_points                                             |      |
| hzi::msEvtCnf.pulsWid，hzi::msEvtCnf.ringThrld | e_ms_samp_config                                     |      |
| hzi::msEvtCnf.msThrldsMap                      | e_chns_config（chn_label，ms_trig_thrld,is_ms_trig） |      |
| hzi::viewSpace                                 | e_speed                                              |      |
| hzi::viewSpace.vtispeed_vector                 | e_vti_speeds                                         |      |
| hzi::chnState                                  | e_chns_config（chn_label, state_id）                 |      |
|                                                |                                                      |      |

## 表说明

> [!IMPORTANT]
>
> 把表分为4类：
>
> * 参数表：读写系统需要用到的一些参数值。一般一条记录（或主键不重复，等价于一条记录）
> * 映射：若干字段的多种可能取值和id映射。
> * 实时记录：用于记录，用于日志或当前数据或当前状态。（一条记录）
> * 历史记录：用于记录，用于日志或历史数据或历史状态。

| 表名                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
|                                |                                                              |
| **参数配置**                   |                                                              |
| e_send_frm_log                 | 服务器向设备发送的命令的日志                                 |
| e_station_info                 | 基站监测，【基站检测应答帧】参数入库                         |
| e_dev_clock                    | 时间校准，【时间校准应答帧】参数入库                         |
| e_dev_config_ack               | 参数配置，【参数配置应答帧】参数入库                         |
| e_users                        | 用户名，密码                                                 |
| e_space                        | 系统-工程参数-空间参数（设定这张表中所存参数：**原点坐标/巷道xyz的范围/网格宽度**等坐标常数）。数据计算时，`getPCO_parm`函数查出存到`PureCommonOperation::PCOLocParm`变量里。 |
| e_info                         | 系统-工程参数-工程参数                                       |
| p_data_types                   | 数据类型编号说明type_id                                      |
| p_chn_types                    | 通道类型和type_id，label对应关系                             |
| e_tunnel_cur_status            | 存储【掘进位置】【偏移距】【超前距离】【back_distance】【forward_distance】等巷道参数 |
|                                |                                                              |
| e_chns_config_tunnel           | 通道的配置等参数。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn` |
| e_chns_config                  | **用户输入的通道信息**。比如坐标。                           |
| e_chns_config_history          | **通道的历史信息（因为通道会移动，坐标也会改变，而历史计算需要历史的通道的数据）**。通道更新`e_chns_config`时触发器会自动更新该表。代码中用到该表都是查询。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn`变量。 |
|                                |                                                              |
| e_tunnel_serverInfo            | 服务器的ip和port                                             |
| e_tunnel_model_info            |                                                              |
|                                |                                                              |
| **原始帧数据采集**             |                                                              |
| p_station_schemas              | 映射：基站工作模式                                           |
| e_station_info                 | 实时记录：基站检测应答帧入库（基站信息：当前模式（见表p_station_schemas），采集软件版本等）。 |
| e_dev_clock                    | 历史记录：时间校准应答帧入库                                 |
| e_dev_config_ack               | 历史记录：采集置参应答帧入库（cmd_seq，dev_addr，置参成功与否） |
|                                |                                                              |
|                                |                                                              |
| **采集置参，启动监测**         |                                                              |
| e_ms_samp_config               | 参数：保存【采集置参->微震采集参数】修改                     |
| p_samp_intvls                  | 映射：【采样间隔，id】，`for_ms`表示该间隔是否可用于微震     |
| p_points                       | 映射：【采样点数，id】或【超前点数，id】                     |
| p_ms_trigs                     | 映射：【触发方式，id】                                       |
| p_time_wins                    | 映射：【时窗id，时窗值(ms)】，`for_ms_bg`——是否可用于微震背景检测，`for_ms_up`——微震背景上传 |
| e_ms_trig_params               | 参数：触发通道数，触发时窗等                                 |
| e_start_monitor_time           | 历史记录：开始监测下发命令帧                                 |
| e_net_info                     | 实时记录：ip地址设置下发命令帧                               |
|                                |                                                              |
|                                |                                                              |
| **干涉提取**                   |                                                              |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | 9类型数据，提取图数据                                        |
| e_mining_pcodata_frm_info      | 10类型数据，偏移图数据                                       |
| e_mining_PCOSignalParm         | **实时计算参数，信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **历史计算参数，信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。 |
| e_mining_PCOLocParm            | **实时/历史计算，坐标等参数值。回采位置/回采方向/日进尺/回采位置更新日期**等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | 回采位置/回采位置对应时间戳/日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | 当前使用的通道的设备/编号/类型：0-微震采集，1-电法采集，2-电法发射，3-电磁采集，4-温度采集，5-电法B极，6-电法N极 |
| e_chns_config_history          | 从中读取通道历史信息参与历史计算                             |
|                                |                                                              |
|                                |                                                              |
| **偏移**                       |                                                              |
|                                |                                                              |
| **回采位置**                   |                                                              |
| e_tunnel_cur_status            | 当前回采位置，偏移距，基准通道。实时，历史都会更新到这。     |
| e_mining_locx_history          | 记录回采位置被修改时的历史。                                 |
|                                |                                                              |
|                                |                                                              |
| e_data_digest                  |                                                              |
|                                |                                                              |
| e_geology_info                 | 岩性，p波s波速度                                             |
|                                |                                                              |
| **界面提取**                   |                                                              |
| e_tunnel_line_info             | 界面提取，保存从偏移图中提取的：起始点坐标，终止点坐标，与横轴夹角等信息。 |
| e_tunnel_error_info            | 保存对`e_tunnel_line_info`进行【聚类】算法后，得到的【地质异常】（即地质分层） |
|                                |                                                              |
|                                |                                                              |
|                                |                                                              |
| **预警**                       |                                                              |
| e_warningInfo_parm             | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts                  | 记录了所有的微震事件。用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value          | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info                 | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
|                                |                                                              |
| **随采**                       |                                                              |
| e_mining_surveyLines           |                                                              |
|                                |                                                              |

# 21. 登录

---

## （1）验证用户名密码

>  表`e_users`中存的`password`就只是`PASSWORD(password)`

```cpp
//commands.cpp
//body传plain/text，形如：【username=admin&password=Hzi12345!】
void login(const Rest::Request &request, Http::ResponseWriter response)
{}
    
//login中调用的verifyUser重载是下面的：用于分别验证用户名和密码。
//user和pswd都是传明文
bool verifyUser(string user, string pswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  auto ret = queryDb(conn, "SELECT * FROM e_users where user_name=? and password=PASSWORD(?)", user, pswd)
                 ? true : false;
  return ret;
}
```

```cpp
//接口
Routes::Post(RoutesManager::router, "/auth_user", Routes::bind(&cmd::authUser));

void authUser(const Rest::Request &request, Http::ResponseWriter response)
{
  Document bodyDoc;
  if (bodyDoc.Parse(request.body().c_str()).HasParseError())
  {
    response.send(Http::Code::Bad_Request, "用户认证格式错");
  }
  string userPswd = bodyDoc["user_pswd"].GetString();
  response.headers().add<Http::Header::ContentType>("text/plain");
  verifyUser(userPswd)
      .map([&](auto r)	{ response.send(Http::Code::Ok, "user_verified:ok"); })
      .map_error([&](auto err)	{ response.send(Http::Code::Unauthorized, "user_verified:failed"); });
}


//authUser调用的verifyUser重载是下面的：
//传入参数userPswd是：形如【user:password】这样的字符串，再base64编码后的字符串。
tl::expected<int, string> verifyUser(string userPswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  //SELECT FROM_BASE64(?)解码base64
  return queryDb(conn, "SELECT FROM_BASE64(?) as user", userPswd.c_str())
      .and_then([&](ResultSet userPsw) -> tl::expected<int, string>
                {
    				auto user = string(userPsw.getString("user"));
    				auto colonPos = user.find(":");
    				if (colonPos != string::npos) 
                    {
    				  auto userName = user.substr(0, colonPos);
    				  auto psw = user.substr(colonPos + 1);
                        //PASSWORD()为MySQL中自带函数，用于对密码进行单向加密，生成的加密字符串无法直接还原为原始密码，主要用于安全存储密码。
    				  return queryDb(conn,
    				                 "SELECT * FROM e_users where user_name=? and "
    				                 "password=PASSWORD(?)",
    				                 userName, psw)
    				      .and_then([&](auto r) { return tl::expected<int, string>(0); });
    				} 
                })
      .or_else([&](auto e) -> tl::expected<int, string>
               {
    			cout << "error:" << e << "\n";
    			return tl::make_unexpected(string("error verifying user:") + e); 
               });
}
```

## （2）修改密码

```cpp
//接口
Routes::Post(RoutesManager::router, "/password/:user/:pswd", Routes::bind(&cmd::changePswd));

void changePswd(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":user").as<string>();
  auto pswd = request.param(":pswd").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  try
  {
    conn.execute("UPDATE e_users set password=PASSWORD(?) where user_name=?",
                 pswd, userName);
    response.send(Http::Code::Ok, "ok");
  }
  catch (zdb::sql_exception &err)
  {
    response.send(Http::Code::Bad_Request, err.what());
  }
  // conn.close();
}
```

## （3）用户是否存在

```cpp
//接口
Routes::Get(RoutesManager::router, "/users/:name", Routes::bind(&cmd::userExists));

void userExists(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":name").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  queryDb(conn, "SELECT * from e_users where user_name=?", userName.c_str())
      .map([&](auto r)
           { response.send(Http::Code::Ok, "ok"); })
      .map_error([&](auto err)
                 {
      if (err.find("not found") != string::npos) {
        response.send(Http::Code::Not_Found, "not found");
      } else {
        response.send(Http::Code::Bad_Request, err);
      } });
  // conn.close();
}
```

# 23.日志

---

## （1）查看日志

远程桌面finalshell，日志路径：`opt/hzisemt`

```cpp
void logInfo(string const &info) {
    std::cout << timeStr(std::chrono::system_clock::now()) << " " << info
        << std::endl;
}
void logInfo(const std::vector<string> &infos) {
    std::cout << timeStr(std::chrono::system_clock::now()) << " ";
    for (int i = 0; i < infos.size(); i++) {
        std::cout << infos[i];
    }
    std::cout << std::endl;
}
void logErr(string const &info) {
    std::cerr << timeStr(std::chrono::system_clock::now()) << " " << info
        << std::endl;
}
void logErr(const std::vector<string> &infos) {
    std::cerr << timeStr(std::chrono::system_clock::now()) << " ";
    for (int i = 0; i < infos.size(); i++) {
        std::cerr << infos[i];
    }
    std::cerr << std::endl;
}

template <typename T> void debugLog(T &info) {
  if (hzi::config.verbose) {
    logInfo(info);
  }
}

template <typename T> void debugErr(T &info) {
  if (hzi::config.verbose) {
    logErr(info);
  }
}
```

![日志路径](D:\notes\笔记Img\日志路径.png)

## （2）替换可执行文件2min自动重启

```bash
ps aux | grep hzisemt | grep -v "grep"
chmod +x hzisemt
pkill hzisemt
```

# 24. 上传文件发送文件

---

## （1）文件指定格式上传/下载

> * 发送文件到前端，通过字节流：
>
>   ```cpp
>   //依赖库pistache
>   auto stream = response.stream(Http::Code::Ok);
>   while(ifs.gcount() > 0)
>   {
>       stream.write(bufTmpPtr, ifs.gcount());
>       stream << flush;
>       ifs.read(bufTmpPtr, fileSize);
>   }
>   ifs.close();
>   stream << ends;
>   ```
>
> * 发送文件到前端，通过`serveFile`
>
>   ```cpp
>   //函数原型
>   Http::serveFile(ResponseWriter& writer, const std::string& fileName,
>             const Mime::MediaType& contentType = Mime::MediaType());
>   ```
>
>   ```cpp
>   //依赖库pistache
>   Http::serveFile(res, fig, MIME(Application, Png));
>   ```

```cpp
/**
 * @brief 上传
*/ 

Routes::Post(RoutesManager::router, "/upload_doc/:mime/:name",
             Routes::bind(&cmd::uploadDocument));

void uploadDocument(const Rest::Request &request, Http::ResponseWriter response) 
{
    response.headers().add<Http::Header::ContentType>(MIME(Text, Plain));                          
    if(!request.hasParam(":name") || !request.hasParam(":mime"))
    {
        response.send(Http::Code::Bad_Request, "缺少参数");
        return;
    }
    string filename = request.param(":name").as<string>();
    string fileMime = request.param(":mime").as<string>();

    if (request.body().empty()) 
    {
        response.send(Http::Code::No_Content, "没有传入文件");
        return;
    }

    fs::path filePath("assets/images/");
    filePath /= filename;
    if (!fs::exists(filePath.parent_path())) 
    {
        response.send(Http::Code::Expectation_Failed, "Invalid path");
        return;
    }

    try 
    {
        //根据格式保存文件
        std::ofstream ofs;
        //图片
        if(fileMime == "png" || fileMime == "jpg" || fileMime == "jpeg" || fileMime == "gif" || fileMime == "bmp")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "pdf")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "xlsx")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "csv")
        {
            ofs.open(filePath);
        }

        if (!ofs.is_open())
        {
            response.send(Http::Code::Expectation_Failed, "failed to create: " + filename);
            return;
        }
        
        ofs.write(request.body().data(), request.body().size());
        ofs.close();
        response.send(Http::Code::Ok, filename + " uploaded!");
    } 
    catch (std::exception &e) 
    {
        logErr(e.what());
        response.send(Http::Code::Expectation_Failed, "Failed to upload: " + filename);
        return;
    }
}
```

```cpp
Routes::Get(RoutesManager::router, "/download_doc/:mime/:name", Routes::bind(&cmd::downloadDocument)); 

void downloadDocument(const Rest::Request &request, Http::ResponseWriter response)
{
    // response.headers().add<Http::Header::ContentType>(
    //   MIME3(Application, OctetStream, Zip));
    if(!request.hasParam(":name") || !request.hasParam(":mime"))
    {
        response.send(Http::Code::Bad_Request, "缺少参数");
        return;
    }

    string filename = request.param(":name").as<string>();
    string fileMime = request.param(":mime").as<string>();

    if (filename == "undefined") {
        response.send(Http::Code::No_Content, "没有指定pdf文件名");
        return;
    }

    fs::path filePath("assets/");//文件存储目录
    filePath /= filename;
    if (!fs::exists(filePath) || !fs::is_regular_file(filePath)) {
        cout << "file not exists: " << filePath.string() << endl;
        response.send(Http::Code::Expectation_Failed, "file not exists:" + filename);
        return;
    }

    try
    {
        std::ifstream ifs;
        if(fileMime== "png" || fileMime == "jpg" || fileMime == "jpeg" 
           || fileMime == "gif" || fileMime == "bmp" || fileMime == "pdf")
        {
            ifs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "csv" || fileMime == "xlsx")
        {
            ifs.open(filePath);
        }    

        if (!ifs.is_open())
        {
            cout << "failed to open file: " << filePath << endl;
            response.send(Http::Code::Expectation_Failed, "failed to open: " + filename);
            return;
        }  

        if(fileMime == "png")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Png));
        }
        else if(fileMime == "jpg")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
        }
        else if(fileMime == "jpeg")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
        }
        else if(fileMime == "gif")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Gif));
        }
        else if(fileMime == "bmp")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Bmp));
        }
        else if(fileMime == "pdf")
        {
            response.headers().add<Http::Header::ContentType>("application/pdf; charset=utf-8");
        }
        else if(fileMime == "csv")
        {
            response.headers().add<Http::Header::ContentType>("text/csv; charset=utf-8");
        }
        else if(fileMime == "xlsx")
        {
            response.headers().add<Http::Header::ContentType>("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet; charset=utf-8");
        }

        //保存到文件
        int64_t fileSize = fs::file_size(filePath);
        unique_ptr<char[]> bufTmp = make_unique<char[]>(fileSize);
        char* bufTmpPtr = static_cast<char*>(bufTmp.get());
        ifs.read(bufTmpPtr, fileSize);
        auto stream = response.stream(Http::Code::Ok);
        while(ifs.gcount() > 0)
        {
            stream.write(bufTmpPtr, ifs.gcount());
            stream << flush;
            ifs.read(bufTmpPtr, fileSize);
        }
        ifs.close();
        stream << ends;
    }
    catch(const std::exception& e)
    {
        cout << "failed to download:" << filename << endl;
        logErr(e.what());
        response.send(Http::Code::Expectation_Failed, "failed to download: " + filename);
        return;
    }
}
```

## （2）zip压缩/解压缩

> [!NOTE]
>
> 库：`libzip`
>
> 目录：`usr/include/zip.h`

### 压缩

* `zip_open`创建zip文件，返回`zip_t*`
* `zip_source_file`打开文件为一个source，返回`zip_source_t*`
* `zip_file_add`把source添加到zip实现把文件添加到zip，返回`zip_int64_t`。错误时返回-1，调用`zip_source_free(source)`释放source。
* `zip_close`关闭zip文件。

```cpp
/*
* 打包压缩文件
*/
#include <stdlib.h>
#include <zip.h>
struct fileNode 
{
    string fileName;//文件名
    fs::path filePath;//文件路径
};

//zipPath形如/tmp/hzisemt.zip
//isRandomSuffix=true表示加上随机后缀生成临时文件，此时zipPath中路径将被改为加上后缀后的路径
//isRandomSuffix=false表示直接使用传入路径作为zip路径

//这里是随机生成zip临时文件名为/tmp/hzisemt.zip.XXXXXX，然后下载该文件。
//若想指定下载的zip文件名，可去掉mkstemp64按照文件名模板自动生成随机文件名的代码，而使用从request中解析出的filename
tl::expected<bool, string> packZip(const vector<fileNode>& fileList, string* zipPath, bool addRandomSuffix)
{
    //入参判断
    if(fileList.size()==0 || zipPath==nullptr)	
        return tl::make_unexpected(string("入参非法"));
    
    bool failure = false;
    int filesAddZipCount = 0;	//成功添加到zip中的文件数
    string zipPathSuffix = ".XXXXXX";
    string zipPathTmpStr = *zipPath + zipPathSuffix;
    char* zipPath_;//最后使用的zip路径
    
    if(addRandomSuffix)
    {
        *zipPath = zipPathTmpStr;
        memset(zipPath_, zipPathTmpStr.c_str(), zipPathTmpStr.size());
        zipPath_ = zipPathTmpStr.c_str(); //char zipName[] = "/tmp/hzisemt.zip.XXXXXX";
        
        int fd = mkstemp64(zipPath_);//mkstemp64会根据替换zipName中的XXXXXX为随机数字并创建临时文件，返回该文件的描述符
        close(fd);	//调用方通过zip文件名访问，不通过fd读写
    }
    else
    {
        zipPath_ = zipPath->c_str();
    }
    
    //创建zip文件
    zip_t* z = zip_open(zipPath_, ZIP_CREATE | ZIP_TRUNCATE, nullptr);
    if (!z) 
    {
        // 获取系统错误信息
        char sys_errbuf[256];
        zip_error_t error;
        zip_error_init_with_code(&error, error_code);
        snprintf(sys_errbuf, sizeof(sys_errbuf), 
                 "无法创建zip文件: %s (系统错误码: %d)",
                 zip_error_strerror(&error), 
                 zip_error_system_type(&error));
        zip_error_fini(&error);
        
        return tl::make_unexpected(string("zip_open failed:") + string(sys_errbuf));
    }
    
    //遍历文件下载列表
    for (auto file : files) 
    {
        //打开文件为一个source(把source添加到zip中实现添加文件到zip)
        zip_source_t* source = zip_source_file(z, file.filePath.c_str(), 0, 0);
        if (!source) 
        {
            if (fs::exists(zipPath_))
            	remove(zipPath_);	//打包失败，把生成的zip删除
            return tl::make_unexpected(string("zip_source_file failed"));
        }
        
        //把source添加到zip中，并返回该文件在zip中的index 
        zip_int64_t index = zip_file_add(z, file.fileName.c_str(), source, ZIP_FL_ENC_RAW);
        if (-1 == index/* || -1 == zip_set_file_compression(z, index, ZIP_CM_STORE, 0)*/) 
        {
            zip_source_free(source);//index=-1，文件保存失败，释放source，跳出循环终止后续文件的添加
            if (fs::exists(zipPath_))
                remove(zipPath_);	
            
            // 直接获取当前zip实例的错误信息
            const zip_error_t* zerror = zip_get_error(z);
            std::string errmsg = "添加文件失败: " + 
                std::string(zip_error_strerror(zerror)) +
                " (系统错误码: " + 
                std::to_string(zip_error_system_type(zerror)) + ")";
            
            return tl::make_unexpected(string("zip_file_add failed:") + errmsg);
        } 
        ++filesAddZipCount;//成功添加文件数+1
    }
    
    if (zip_close(z) == -1) //文件添加完毕，关闭zip
    {
        if (fs::exists(zipPath_))
            remove(zipPath_);	
        
        // 获取关闭时的错误信息
        const zip_error_t* zerror = zip_get_error(z);
        std::string errmsg = "关闭zip文件失败: " + 
            std::string(zip_file_strerror(z));

        // 注意：zip_close失败后需要手动保留错误信息
        zip_discard(z); // 必须调用以避免内存泄漏
        return tl::make_unexpected(string("zip_close failed:") + errmsg);
    }

    if (filesAddZipCount == 0) //zip内没文件
    {
        if (fs::exists(zipPath_))
            remove(zipPath_);	
    	return tl::make_unexpected(string("zip为空！"));
    }
    
    return true;
}
```

### 解压缩

* 使用`zip_open`打开一个压缩文件，并使用`zip_get_num_entries`获取压缩文件中的条目数。

* 遍历每个条目，使用`zip_stat_index`获取条目的基本信息。

* 使用`zip_fopen_index`打开条目，使用`zip_fread`读取其中的数据，并将解压后的数据写入本地文件。

```cpp
/*
* 解压缩，返回文件名列表
*/
#include <zip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


vector<string>& unPackZip(string zipPath, string zipUnPackPath)
{
    int err = 0;
    struct zip* zipfile = zip_open(zipPath.c_str(), ZIP_CHECKCONS, &err);
    if (!zipfile) 
    {
        printf("zip open failed: %d\n", err);
        return 1;
    }

    zip_int64_t num_entries = zip_get_num_entries(zipfile, 0);
    for (zip_int64_t i = 0; i < num_entries; i++) 
    {
        struct zip_stat stat;
        zip_stat_index(zipfile, i, 0, &stat);
        printf("the file name is: %s\n", stat.name);

        struct zip_file *entry = zip_fopen_index(zipfile, i, 0);
        if (!entry) 
        {
            printf("fopen index failed\n");
            continue;
        }

        FILE *fp = fopen(stat.name, "w+");
        if (!fp) 
        {
            printf("create local file failed\n");
            zip_fclose(entry);
            continue;
        }

        char buf[1024];
        zip_int64_t len = 0;
        while (len < stat.size) 
        {
            int read = zip_fread(entry, buf, sizeof(buf));
            if (read < 0) {
                printf("read file failed\n");
                break;
            }
            fwrite(buf, 1, read, fp);
            len += read;
        }

        fclose(fp);
        zip_fclose(entry);
    }

    zip_close(zipfile);
    return 0;
}
```

## （3）文件列表打包zip下载

> 打包函数+文件下载接口

```cpp
/*
* 数据保存为bin/csv/qfx，打包zip并下载
*/
Routes::Get(RoutesManager::router,
              "/download/:from_time/:to_time/:is_csv/:file_name",
              Routes::bind(&ms_comm::downloadRawDateFile));


void downloadRawDateFile(const Rest::Request &request,
                         Http::ResponseWriter response) {
  uint64_t fromTime = request.param(":from_time").as<uint64_t>();
  uint64_t toTime = request.param(":to_time").as<uint64_t>();
  auto isCsvId = request.param(":is_csv").as<int>();
  int dev_id = 0;

  auto conn = hzi::config.pConnPool->getConnection();

  auto rslt0 = conn.executeQuery(
      "SELECT dataFreq,dataLen,class_Id  FROM `e_mining_PCOSignalParm`");
  if (rslt0.next()) {
    hzi::miningFreq = rslt0.getInt("dataFreq");
    hzi::miningDateLen = rslt0.getInt("dataLen");
    hzi::mining_classId = rslt0.getInt("class_Id");
  }
  debugLog(" downloadRawDateFile start mergeMs1");
  // mergeEngDenity(fromTime, toTime);

  // response.send(Http::Code::No_Content, "此时间段内无数据！");
  // return;

  mergeMs(fromTime, toTime,dev_id)
      .map([&](DataFrame df) {
        auto dftmp = std::move(df);
        auto chns = dftmp.channels();
        auto tmStmp = dftmp.sampTime();
        auto deltT = dftmp.sampIntvl();
        auto points = dftmp.points();
        auto pretime = 0;

        int32_t *p32 = (int32_t *)dftmp.upData.get();
        // 开始下载数据
        struct fileNode {
          float sampIntvl;
          string fileName;
          string frmLoc;
          string csvLoc;
        };

        std::vector<fileNode> files; // 下载文件列表
        fileNode file;
        //  file.frmLoc = path.string();
        // file.csvLoc = "/tmp" +
        // file.frmLoc.substr(file.frmLoc.find_last_of('/'));
        file.csvLoc = "/tmp/" + std::to_string(tmStmp);
        // + (isCsv ? ".csv" : ".bin");
        file.fileName = std::to_string(tmStmp);
        float tmpf;
        vector<vector<float>> v;
        v.resize(chns);
        for (int ch = 0; ch < chns; ++ch) {
          v.at(ch).resize(points);
          for (int pt = 0; pt < points; ++pt) {
            v.at(ch).at(pt) = p32[ch * points + pt] * 3000.0 / 8388607.0;
          }
        }
        if (isCsvId == 0) {
          try {
            file.csvLoc += ".bin";
            file.fileName += ".bin";
            std::ofstream ofs(file.csvLoc, std::ofstream::binary);
            ofs.write(dftmp.upHead.get(), 32);
            ofs.write((char *)dftmp.upData.get(), chns * points * 4);
            ofs.close();

          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败：" + file.csvLoc);
            return;
          }

        } else if (isCsvId == 1) {
          file.csvLoc += ".csv";
          file.fileName += ".csv";
          try {
            std::ofstream ofs(file.csvLoc);
            ofs << chns << ',' << points << ',' << deltT << ',' << (int)pretime
                << std::endl;

            for (int j = 0; j < points; ++j) {
              for (int k = 0; k < chns; ++k) {
                ofs << v.at(k).at(j) << ",";
              }
              ofs << std::endl;
            }
            ofs.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败：" + file.csvLoc);
            return;
          }
        } else if (isCsvId == 2) {
          file.csvLoc += ".qfx";
          file.fileName += ".qfx";
          STQfxFileHead fhQfx;
          STQfxTraceHead thQfx;
          fhQfx.nTraceCount = chns;
          fhQfx.nSamplePoints = points;
          fhQfx.fSampleInterval = deltT;
          fhQfx.nAdvanPoints = (int)pretime;
          if (fhQfx.nTraceCount < 1 || fhQfx.nSamplePoints < 1 ||
              fhQfx.fSampleInterval < 1e-9f) {
            response.send(Http::Code::Expectation_Failed,
                          "文本数据文件错误：" + file.csvLoc);
            return;
          }

          fhQfx.uchSurveyUnit = QFX_SSU_MV;
          std::ofstream ofsQfx(file.csvLoc);
          ofsQfx.write(reinterpret_cast<char *>(&fhQfx), sizeof(STQfxFileHead));

          thQfx.nSamplePoints = fhQfx.nSamplePoints;
          thQfx.fSampleInterva = fhQfx.fSampleInterval;

          try {
            for (int k = 0; k < chns; ++k) {
              thQfx.uchTraceType = 1;
              thQfx.nTraceNum = thQfx.nOrgTraceNum = k + 1;
              ofsQfx.write(reinterpret_cast<char *>(&thQfx),
                           sizeof(STQfxTraceHead));
              for (int j = 0; j < points; ++j) {
                ofsQfx.write((char *)&v[k][j], sizeof(float));
              }
            }
            ofsQfx.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败 2：" + file.csvLoc);
            return;
          }
        }
        files.push_back(file);

#pragma region 生成压缩文件
        bool failure = false;
        char fileName[] = "/tmp/hzisemt.zip.XXXXXX";
        int fd = mkstemp64(fileName), filesCnt = 0;//返回的fd没用到，后面用文件名读写的文件
        if (files.size() > 0) 
        {
          zip_t *z = zip_open(fileName, ZIP_CREATE | ZIP_TRUNCATE, nullptr);
          if (z) {
            for (auto file : files) {
              zip_source_t *source =
                  zip_source_file(z, file.csvLoc.c_str(), 0, 0);
              if (source) {
                zip_int64_t index = zip_file_add(z, file.fileName.c_str(),
                                                 source, ZIP_FL_ENC_RAW);
                if (-1 == index/* || -1 == zip_set_file_compression(z, index, ZIP_CM_STORE, 0)*/) {
                  failure = true;
                  zip_source_free(source);
                  break;
                } else {
                  ++filesCnt;
                }
              }
            }
            int ret = zip_close(z);
            if (-1 == ret) {
              failure = true;
            }
          }
        }
        if (failure) {
          if (fs::exists(fileName)) {
            remove(fileName);
          }
          response.headers().add<Http::Header::ContentType>(
              "text/plain; charset='utf-8'");
          response.send(Http::Code::Expectation_Failed,
                        "无法生成 zip 压缩文件！");
          return;
        }
        if (0 == filesCnt) {
          response.headers().add<Http::Header::ContentType>(
              "text/plain; charset='utf-8'");
          response.send(Http::Code::No_Content, "此时间段内无数据！");
          return;
        }
#pragma endregion
        response.headers().add<Http::Header::ContentType>(
            MIME3(Application, OctetStream, Zip));
        constexpr int MAX_BUFFER_SIZE = 512;
        char streamBuffer[MAX_BUFFER_SIZE] = {};
        auto stream = response.stream(Http::Code::Ok);
        
        std::ifstream ifs(fileName);//通过文件名读文件
        
       	ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        while (ifs.gcount() > 0) {
          stream.write(streamBuffer, ifs.gcount());
          stream << flush;
          ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        }
        ifs.close();
        stream << ends;
        close(fd);
      })
      .map_error([&](auto err) {
        if (hzi::config.verbose) {
          std::stringstream ss;
          logErr(ss.str());
        }
        response.headers().add<Http::Header::ContentType>(
            "text/plain; charset='utf-8'");
        response.send(Http::Code::Expectation_Failed, "NO data");
        return;
      });
}
```



# 25. 时间戳

---

## （1）UTC时间与UTC+8

> [!NOTE]
>
> * **UTC（协调世界时）** 和 **UTC+8（东八区时间）** 是两种不同的时间标准，主要区别在于 **时区偏移**。
>
>   **UTC 时间 = GMT（格林尼治标准时间）**（但 GMT 可能受地球自转影响，UTC 更精确）。UTC 是全球标准时间，基于原子钟计算，不受夏令时影响。
>
>   **UTC+8 表示比 UTC 快 8 小时，东八区，适用于中国**、新加坡、马来西亚、菲律宾等地区。**北京时间（CST, China Standard Time）**。中国全境统一使用 UTC+8。
>
>   如果 UTC 时间是 `2025-06-12 00:00:00`，那么：
>
>   UTC+8（北京时间）** 是 `2025-06-12 08:00:00`。
>
>   UTC-5（纽约时间） 是 `2025-06-11 19:00:00`（前一天）。

> [!CAUTION]
>
> * **unix时间戳是UTC时间，单位为s**
>
> * **代码中`uint64_t/time_t`一律使用UTC时间戳（标准时间）**
>
> * **库表中的`datetime`类型一律存当地时间（北京时间），存：`FROM_UNIXTIME(uint64_t)`获取当地时间，取：`UNIX_TIMESTAMP()`得到UTC时间戳**
>
> * MySQL会根据服务器所在时区选择UTC+8(服务器在中国)，`UNIX_TIMESTAMP(datetime)`会认为datetime是北京时间，先减去8小时得到UTC时间再计算时间戳。
>
>   比如：`UNIX_TIMESTAMP('2025-06-12 10:42:10')`，它会认为 `'2025-06-12 10:42:10'` 是北京时间，并转换成 UTC 时间（`2025-06-12 02:42:10`），再计算`2025-06-12 02:42:10`的时间戳 → **1749696130**

* 从UTC unix时间戳得到当地的时间

  比如：从`1749696130`获得`2025-06-12 10:42:10`，而不是`2025-06-12 02:42:10`

  ```cpp
  //timep：指向 time_t 类型的指针，表示从1970年1月1日00:00:00 UTC开始的秒数。
  //返回一个指向 struct tm 的指针，该结构体包含转换后的本地时间信息。如果转换失败，返回 NULL。
  struct tm* std::localtime(const time_t* timep);
  
  //localtime_r 是 localtime 的线程安全版本，localtime 是较早版本的函数
  struct tm* std::localtime_r(const time_t* timep, struct tm* result);
  ```

* 从当地时间得到UTC unix时间戳

  比如：从`2025-06-12 10:42:10`获得`1749696130`

  ```cpp
  //timeptr：指向 struct tm 的指针，该结构体包含要转换的本地时间信息。
  //返回一个 time_t 类型的时间戳，表示从1970年1月1日00:00:00 UTC开始的秒数。如果输入的 struct tm 无效，返回 -1。
  time_t std::mktime(struct tm* timeptr);
  
  time_t utc_timestamp = std::mktime(&local_tm); // 将本地时间转换为UTC时间戳
  ```

## （2）由unix时间戳（uint64_t或time_t）获取datetime

> [!NOTE]
>
> datetime在代码中以`std::tm`表示
>
> ```cpp
> #include <ctime>
> std::tm
> 
> struct tm
> {
>   int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
>   int tm_min;			/* Minutes.	[0-59] */
>   int tm_hour;			/* Hours.	[0-23] */
>   int tm_mday;			/* Day.		[1-31] */
>   int tm_mon;			/* Month.	[0-11] */
>   int tm_year;			/* Year	- 1900.  */
>   int tm_wday;			/* Day of week.	[0-6] */
>   int tm_yday;			/* Days in year.[0-365]	*/
>   int tm_isdst;			/* DST.		[-1/0/1]*/
> 
> # ifdef	__USE_MISC
>   long int tm_gmtoff;		/* Seconds east of UTC.  */
>   const char *tm_zone;		/* Timezone abbreviation.  */
> # else
>   long int __tm_gmtoff;		/* Seconds east of UTC.  */
>   const char *__tm_zone;	/* Timezone abbreviation.  */
> # endif
> };
> ```
>
> ```cpp
> //年份
> tm.tm_year+1900
> //月份
> tm.tm_year+1
> //日
> tm.tm_mday
> //星期
> tm.tm_wday+1
> ```

```cpp
//uint64_t--->std::tm
#include <ctime>
#include <cstdint>
int uint64_to_tm(uint64_t timestamp, struct tm* tm_ptr) //timestamp为秒时间戳
{
    // 将时间戳转换为 time_t 类型
    time_t time = static_cast<time_t>(timestamp);
    // 转换为本地时间
    localtime_r(&sec_timestamp, tm_ptr);
    return 0;
}

int uint64_to_tm(uint64_t timestamp, struct tm* tm_ptr) //timestamp为秒时间戳
{
    // 手动给UTC时间戳+8小时调整时区到东八区（北京时间），得到本地时间戳
    int64_t milli = timestamp + (int64_t)8 * 60 * 60 * 1000; 
    auto mTime = std::chrono::milliseconds(milli);
    auto tp = std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds>(mTime);
    auto tt = std::chrono::system_clock::to_time_t(tp);//chrono::time_point转time_t
    *tm_ptr = std::gmtime(&tt);
}

//C++20标准
#include <chrono>
#include <format>

void uint64_to_tm(uint64_t timestamp, struct tm* tm_ptr) 
{
    auto tp = std::chrono::system_clock::from_time_t(timestamp);
    zoned_time zt{"Asia/Shanghai", tp}; // 指定时区
    *tm_ptr = std::chrono::get_tm(zt);
}
```

## （3）datetime获取unix时间戳（uint64_t或time_t）

```cpp
//std::tm--->uint64_t
#include <ctime>
#include <chrono>
#include <cstdint>
uint64_t tm_to_uint64(const std::tm& tm_time) //返回秒
{
    // 将 std::tm 转换为 time_t
    std::time_t time_t_value = mktime(const_cast<std::tm*>(&tm_time));
    // 转换为 uint64_t
    return static_cast<uint64_t>(time_t_value);
}

// 将 std::chrono::system_clock::time_point 转换为 uint64_t 时间戳（秒为单位）
uint64_t chrono_to_uint64(const std::chrono::system_clock::time_point& time_point) 
{
    // 转换为秒
    auto duration = time_point.time_since_epoch();
    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration);
    return static_cast<uint64_t>(seconds.count());
}
```

## （4）由UTC unix毫秒时间戳获取`YYYY-MM-DD HH:MM:SS.mmm`字符串

```cpp
// utc unix毫秒时间戳（13位）获取YYYY-MM-DD HH:MM:SS.mmm字符串
std::string timestampToString(int64_t timestamp_ms) 
{
  // Convert milliseconds to seconds and remainder milliseconds
  std::time_t seconds = timestamp_ms / 1000;
  int milliseconds = timestamp_ms % 1000;

  //使用std::localtime函数将seconds（以秒为单位的时间）转换为本地时间，结果存储在tm结构体中
  std::tm *tm = std::localtime(&seconds);

  //存储格式化后的时间字符串（不包括毫秒部分）。大小为24，足以存储"YYYY-MM-DD HH:MM:SS"格式的字符串
  //将tm结构中的时间信息格式化为"YYYY-MM-DD HH:MM:SS"格式的字符串，并存储在buffer中
  char buffer[24];
  std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm);

  //将buffer中的字符串和毫秒部分拼接起来
  //std::setfill('0')设置填充字符为'0'，std::setw(3)设置字段宽度为3，确保毫秒部分总是三位数字，不足时前面补零。
  std::ostringstream oss;
  oss << buffer << '.' << std::setfill('0') << std::setw(3) << milliseconds;

  return oss.str();
}
```

## （5）HH:MM:SS时间字符串转成ms

```cpp
//将形如1:30:21格式时间段转换为毫秒数
static uint64_t timeStringToMillis(const std::string &timeString)
{
    int hours, minutes, seconds;
    sscanf(timeString.c_str(), "%d:%d:%d", &hours, &minutes, &seconds);
    return (hours * 3600 + minutes * 60 + seconds) * 1000;
}
```

## （6）YYYY-MM-DD HH:MM:SS.mmm字符串获取UTC unix毫秒时间戳（13位）

```cpp
//YYYY-MM-DD HH:MM:SS.mmm字符串获取utc unix毫秒时间戳（13位）
int64_t stringToTimestamp(const std::string &datetime_str) 
{
  std::tm tm = {};
  int milliseconds = 0;

  // Manually parse the string "YYYY-MM-DD HH:MM:SS.mmm"
  if (sscanf(datetime_str.c_str(), "%4d-%2d-%2d %2d:%2d:%2d.%3d", &tm.tm_year,
             &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec,
             &milliseconds) != 7) 
  {
    throw std::runtime_error("Failed to parse date-time string");
  }

  // Adjust fields for tm structure
  tm.tm_year -= 1900; // tm_year is years since 1900
  tm.tm_mon -= 1;     // tm_mon is 0-based (0 = January)

  // Convert to time_t (seconds since epoch) and add milliseconds
  std::time_t seconds = std::mktime(&tm);
  if (seconds == -1) 
  {
    throw std::runtime_error("Failed to convert to time_t");
  }

  return static_cast<int64_t>(seconds) * 1000 + milliseconds;
}
```

## （6）将yyyy-MM-dd hh:mm:ss字符串转成yyyyMMddhhmmss字符串

```cpp
std::string convertDateFormat(const std::string& date_str) 
{
    if (date_str.empty()) {
        throw std::invalid_argument("Input date string is empty");
    }

    // 检查输入长度是否符合 "YYYY-MM-DD HH:MM:SS"
    if (date_str.size() != 19) {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 提取并验证格式
    std::string year = date_str.substr(0, 4);
    std::string month = date_str.substr(5, 2);
    std::string day = date_str.substr(8, 2);
    std::string hour = date_str.substr(11, 2);
    std::string minute = date_str.substr(14, 2);
    std::string second = date_str.substr(17, 2);

    // 确保字符的位置符合标准格式
    if (date_str[4] != '-' || date_str[7] != '-' || date_str[10] != ' ' || 
        date_str[13] != ':' || date_str[16] != ':') {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 合并为目标格式
    std::string result = year + month + day + hour + minute + second;
    return result;
}
```

## （8）获取当前UNIX时间戳

```cpp
uint64_t nowMS() 
{
    std::chrono::time_point<std::chrono::system_clock> now =
        std::chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    auto millis =
        std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();
    return millis;
}
```

## （9）根据时间戳获取当日零点时间戳

```cpp
//timestamp（单位ms）
//返回值（单位ms）
time_t midnight(uint64_t timestamp) 
{
    time_t tmt = timestamp / 1000;
    tm* pTM = localtime(&tmt);
    pTM->tm_hour = 0;
    pTM->tm_min = 0;
    pTM->tm_sec = 0;
    auto midnight_timet = mktime(pTM) * 1000;
    return midnight_timet;
}

uint64_t midnite = midnight(ms_now);    // 当天0点时间戳
```

## （10）库表中时间类型的选择

* 日期时间类型：`DATETIME(4)` 表示时间戳的精度为4位小数（毫秒级）。如果你需要更高的精度（例如微秒级），可以使用 `DATETIME(6)`
* 时间戳类型：存储`s/ms/us`，使用`bigint`

## （11）c++代码中时间类型

> [!NOTE]
>
> uint64_t和time_t可直接强转
>
> ```cpp
> std::time_t time_t_value;
> uint64_t uint64_value static_cast<uint64_t>(time_t_value);
> ```

* 日期时间类型：`std::tm`或`std::chrono::system_clock::time_point`

* 时间戳类型：`uint64_t`或`time_t`，这两者数值一致。

  **秒时间戳：10位整数。**

  **毫秒时间戳：13位整数。**

## （12）MySQL语句中时间戳处理

> * `time_t（time_t是时间戳epoch到现在的seconds）`或`uint_64`可表示秒，毫秒，微秒时间戳，精度够
> * 字段类型为时间戳：存，`time_t`或`uint_64`格式变量在`execute()`中执行插入到字段时，都要先转double（秒）或long long（微秒，微秒用long long约定俗成）。取，用`getDouble()`或`getLLong()`直接取库表里的字面值。
>
> * **比较时间先后，一律使用时间戳进行比较。datetime也先转成时间戳再比较！**

### 获取日期当天零点

```mysql
-- 获取指定datetime的当天0点
SELECT DATE_FORMAT(`datetime字段`, '%Y-%m-%d 00:00:00') AS midnight;

-- 获取现在时间的当天0点
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d 00:00:00') AS midnight;
```

### unix时间戳（int64_t或time_t）存取

* 库表字段数据类型假设为`bigint`，11位，但存入库中不直接存uint64_t，类型`time_t`或`uint64_t`需要转成double或long long才能被`libzdb`库的函数`execute`使用

  ```cpp
  //存入
  uint64_t tm;
  auto tmTmp = static_cast<long long>(tm);
  conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", tmTmp);
  或
  auto tmTmp = static_cast<double>(tm);
  conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", tmTmp);
  ```

* 用`getDouble()`或`getLLong()`读取库表中unix时间戳字面值

  **`getDouble()`会不会是使用`getTimestamp()`？不要用getTimestamp()！！！！！**

  ```cpp
  //获取表内字面值，强转long long int。（无法获取字面值）
  auto rslt = conn.executeQuery("...");
  uint64_t tm = rslt.getLLong("tm");//一般用来取ms或us
  cout<<"tm="<<tm<<endl;//和数据库中所存的值相等
  或
  uint64_t tm = rslt.getDouble("tm");//用来取秒时间戳
  cout<<"tm="<<tm<<endl;//和数据库中所存的值不等
  cout<<"tm="<<(double)(tm)<<endl;//和数据库中所存字面值相等
  ```

### unix时间戳（int64_t或time_t）转成datetime存取

```cpp
//MySQL会根据服务器所在时区选择UTC+8(服务器在中国)
UNIX_TIMESTAMP(datetime)//datetime转unix时间戳(单位s，拿到datetime先减去8小时得到UTC时间再计算时间戳)
FROM_UNIXTIME(uint64_t)//unix时间戳(s)转datetime（拿到uint64_t转成datetime后加上8小时）
```

库表字段数据类型设为`datetime(4)`，秒后面4位小数。

调用函数`FROM_UNIXTIME()`将unix时间戳（单位s）转成`datetime`插入

datetime类型字段用`conn.getDateTime("field")`从查询结果中获取，获取结果是`struct tm`类型

```cpp
//int64_t或time_t--->datetime后存入
uint64_t tmStmp = dfVec[0]->sampTime();//ms

conn21.execute(
"INSERT INTO "
"e_mining_signaldata_frm_info "
"(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
"loc,fx,fy,fz,dis)"
"values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "//ms转成datetime
" ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
"values(valNum),vecSize= values(vecSize),outLen= values(outLen)",
(uint8_t)devId,  // dev_id
(double)tmStmp / 1000.0, // tmStmp是uint64_t毫秒时间戳，转秒，因此要再转double
classId2,        // class_id
deltT,           // curt_ch
valNum,          // channels
vecSize,
pcoParm.outLen, // ch_pnts
(relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp)).c_str(), // frm_loc
pcoLocParm.fx,
pcoLocParm.fy,
pcoLocParm.fz,
pcoLocParm.dis_y);

//datetime--->int64_t或time_t取出
auto rslt = conn.executeQuery("SELECT UNIX_TIMESTAMP(field) from table");
uint64_t tm = rslt.getLLong("field");

//直接读取datetime类型字段，获取struct tm类型（若需要uint64_t类型可再转）
std::tm = conn.getDateTime("field");
```

> ### 1. **`time_t`**
>
> - **定义**：`time_t` 是 C 和 C++ 标准库中用于表示时间的类型，通常用于表示从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的秒数（即 Unix 时间戳）。
> - **类型**：`time_t` 的具体实现依赖于平台和编译器，但通常是 `long` 或 `long long` 类型。在大多数现代系统中，`time_t` 是一个 64 位有符号整数。
> - **用途**：主要用于时间相关的操作，如获取当前时间、时间间隔计算等。
> - **范围**：由于 `time_t` 是有符号整数，其范围通常是 `-2^63` 到 `2^63-1`（在 64 位系统中）。
>
> ### 2. **`uint64_t`**
>
> - **定义**：`uint64_t` 是 C++ 标准库中定义的无符号 64 位整数类型，属于 `<cstdint>` 头文件中的固定宽度整数类型。
> - **类型**：`uint64_t` 是一个无符号 64 位整数。
> - **用途**：用于需要精确表示 64 位无符号整数的场景，如大整数计算、文件大小、内存地址等。
> - **范围**：`0` 到 `2^64-1`。
>
> ### 对比
>
> | 特性       | `time_t`                | `uint64_t`             |
> | :--------- | :---------------------- | :--------------------- |
> | **类型**   | 通常是 64 位有符号整数  | 64 位无符号整数        |
> | **范围**   | `-2^63` 到 `2^63-1`     | `0` 到 `2^64-1`        |
> | **用途**   | 时间相关的操作          | 大整数计算、文件大小等 |
> | **标准库** | `<ctime>` 或 `<chrono>` | `<cstdint>`            |

# 26. 字符串处理

---

## （1）字符分割

```cpp
//deli作为分割，从origStr中分割出子字符，保存到vals中
void splitStr(const string &origStr, char deli, std::vector<string> &vals) {
    string str = origStr;

    while (!str.empty()) {
        auto pos = str.find_first_of(deli);
        if (pos == string::npos) {
            // 如果找不到分隔符，将剩余字符串作为最后一个部分
            vals.push_back(str);
            break;
        } else {
            // 提取当前部分并更新剩余字符串
            vals.push_back(str.substr(0, pos));
            str = str.substr(pos + 1); // 更新剩余字符串
        }
    }
}
```

# 27. 数值计算

---

## （1）整数幂计算

```cpp
//base^power
int safePow(int base, unsigned int power) 
{
  if (power == 0) 
  {
    return 1;
  }
  int p = 1;
  for (int i = 0; i < power; i++) 
  {
    p *= base;
  }
  return p;
}
```

## （2）双精度数值格式化为保留两位小数的字符串

```cpp
// 格式化函数：将双精度数值格式化为保留两位小数的字符串
std::string formatDouble(double value, int fmat) {
  std::ostringstream oss;
  oss << std::fixed << std::setprecision(fmat) << value;
  std::string str = oss.str();

  // If the number is an integer, remove the decimal part
  if (std::fabs(value - static_cast<int>(value)) < 1e-9) {
    str.erase(str.find('.'));
  } else {
    // Remove trailing zeros
    str.erase(str.find_last_not_of('0') + 1, std::string::npos);
    // If there is a dangling decimal point, remove it
    if (str.back() == '.') {
      str.pop_back();
    }
  }

  return str;
}
```

## （3）计算字节形式存储的整数的均值

```cpp
double avg(const char *p, int from, int to) {
  int64_t sum = 0;
  for (int i = from; i < to; i++) {
    sum += *(int32_t *)(p + i * 4);
  }
  return sum / (to - from);
}
```

## （4）fabsf

> `fabsf` 是一个 C 标准库中的数学函数，用于计算单精度浮点数的绝对值。
>
> ```cpp
> float fabsf(float x);
> ```
>
> 

## （5）floor()

`floor()` 函数是一个数学函数，用于计算小于或等于给定数值的最大整数

# 28.异常

---

## （1）使用tl::expected库处理异常

>  expected，替代bool或返回码。
>
> 好处：简便的将异常的详细信息返回到调用处使用。可链式调用。

```cpp
static tl::expected<Document, string> jsonDocFromFile(string const &file) {
    FILE *fp = fopen(file.c_str(), "r");
    if (!fp)
      return tl::make_unexpected("failed opening file: " + file);

    char readBuf[1024];
    FileReadStream frs(fp, readBuf, sizeof(readBuf));
    Document doc;

    if (doc.ParseStream<kParseCommentsFlag>(frs).HasParseError()) {
      return tl::make_unexpected("jsonDocFromFile: invalid json file:" + file);
    }
    return std::move(doc);
  }
```

* 比较and_then与or_else，map与map_erro的区别

```cpp
//and_then和or_else 
return jsonDocFromFile(jsonConf).and_then([&](Document doc) -> tl::expected<Config, string> 
     	{
            ...
        })
     	.or_else([&](string unexpect) -> tl::expected<Config, string>
    	{
            ...
        });
```

```cpp
//map和map_error

```

## （2）throw抛异常

throw抛异常后，代码将终止，不会执行throw之后的语句。

throw一般用于抛异常到上层代码，让其捕获处理。

但目前来说，写代码，最好那里发生哪里捕获哪里处理，不要往上层抛。

## （3）多个catch

多个catch，前面的catch捕获异常后，后面的catch不会再捕获异常并处理。

# 29. Makefile

```makefile
# cxx = /usr/bin/g++
cxx = nvc++
base_version = NEWBASE
stdpar = multicore
# ARCH ?= native  # 默认架构，使用本机架构

target = ../../hzisemt
major_srcs = $(shell find . -type d \( -path ./bkups -o -path ./on_gpu -o -path ./python -o -path ./python2cpp \) -prune -false -o -name "*.cpp")
major_objs = $(major_srcs:%.cpp=%.o)

gpu_srcs = $(shell find ./on_gpu -name "*.cpp")
gpu_objs = $(gpu_srcs:%.cpp=%.o)

# cflags = -I/usr/local/include/zdb  -I/usr/local/include/pistache -I/opt/pistache/include -I./  -std=c++23 -fPIC -fcoroutines -Wno-deprecated  -O3 -fpermissive -D${base_version}
# cflags = -I/opt/oldzdb/include/zdb  -I/usr/local/include/pistache -I/usr/include/python3.11 -I/opt/anaconda3/lib/python3.11/site-packages/numpy/core/include -I/usr/include/eigen3 -I/usr/include/openssl -I./  -std=c++23 -fPIC -fcoroutines -Wno-deprecated  -O3 -fpermissive -D${base_version}
cflags = -I/opt/oldzdb/include/zdb -I/usr/local/include/pistache -I/usr/include/eigen3 -I/usr/include/openssl -I./ -std=c++23 -fPIC -fcoroutines -Wno-deprecated -O3 -fpermissive -D${base_version}

# for skylake：
# cflags = -I/opt/oldzdb/include/zdb -I/usr/local/include/pistache -I/usr/include/eigen3 -I/usr/include/openssl -I./ -std=c++23 -fPIC -fcoroutines -Wno-deprecated -O1 -fpermissive -D${base_version} -tp=$(ARCH) -Minfo=all 

$(major_objs): mcflags := -stdpar=multicore 
$(gpu_objs): gcflags := -stdpar=${stdpar} 

lnkflags = -L/usr/local/lib -L/usr/lib/x86_64-linux-gnu -L/lib/x86_64-linux-gnu -L/opt/oldzdb/lib -lpthread -lzdb -lpistache -lzip -lssl -lcrypto -lceres -lglog -lcurl -lmariadb -lmysqlclient -lrdkafka++ -lrdkafka -Wl,-rpath,/usr/lib/x86_64-linux-gnu
#$(shell python3-config --ldflags)

$(target): $(major_objs) $(gpu_objs)
	$(cxx) $(cflags) -stdpar=$(stdpar) -o $(target) $(lnkflags) $(major_objs) $(gpu_objs)

main.o: main.cpp
	$(cxx) $(cflags) $(mcflags) -c main.cpp -o main.o

%.o: %.cpp %.hpp Config.hpp resis_handler.hpp FrameQueue.hpp
	$(cxx) $(cflags) $(mcflags) $(gcflags) -c $< -o $@ 

clean:
	rm -f *.o web/*.o DataImage/*.o algorithms/msl/*.o on_gpu/*.o ../../hzisemt
```

