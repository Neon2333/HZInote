

# 1. 系统概述与业务

---

* 传感器：基站上有根线，线的远端是1号，近端是16号。1号靠近迎头。每个传感器线上固定间距5m。

* 当前掘进里程（掘进位置）：迎头的位置（每天更新）

* 【系统-工程参数-工作面名称/工作面长度和宽度】工作面：大巷侧面是煤层，从大巷侧面垂直开的巷道叫工作面，进风面/出风面以及最后横向挖通构成一个U字形，中间很薄的一层是煤层。可能高度600米只有3米的煤层，其他是岩层。

* 掘进是什么？目的是什么？：主要判断前面有没有构造：水/断层之类的，提前知道，有相应方法处理。

* 【系统-工程参数-空间参数】将煤底层位置设为（0，0，0）

* 【系统-工程参数-通道配置】S1表示基站，GR01表示第一个传感器。（问题：矿上把传感器位置放反了，把线的近端放在了靠近迎头。代码里逻辑可能后面要修改。）

* 【采集置参】：关注**采样间隔**

* 【数据存储策略】：为了节省内存，设定不存储指定的数据。

* 【系统-随掘监测-数据提取】：【1-最小比例~1+最大比例】作为比例，乘以【平均能量时窗】内数据（背景数据）的均值。用【时窗】内数据（背景数据）进行比较，判断是否在掘进。（用背景数据进行判断。全时数据数据量太大）

  判断是否正在掘进过程：通过1h内数据，计算平均值，平均值乘以比例作为基准。后面时窗即以2min为单位计算平均值，若在范围内，则判断这个时窗内为正在掘进。

* 【系统-随掘监测-实时参数】：用全时数据，根据设定参数自动进行提取处理。（随掘地震那里的设定，是为了修改参数值，通过偏移图看效果，找到最适合的参数，填入实施参数的设定参数进行自动提取。）

  监测前方距离：超前探测距离。

  拼接数据类型：一般是微震全时，即在全时数据的基础上进行提取，得到提取图。

# 2. 随掘地震概述

---

【目的】：监测掘煤前方的地质结构，提前预知水/岩石/煤的存在，做好措施。

【软件系统】：通道采集原始信号，经过干涉源提取生成提取数据和【图提取】。再经过滤波/振幅均衡/反褶积/反射波提取/偏移，得到偏移数据和【偏移图】。最后，通过【界面提取】，从偏移图中提取界面的坐标点和与横轴夹角。最后通过【聚类】算法，对提取的界面进行处理，找出真正的地质异常（也就是分层面），绘制在【首页的巷道探测示意图】。

波在介质中传播，当介质的密度突然发生改变时会发生反射。使用传感器接收反射波，通过系统处理，发现不同介质的分层。随掘系统，波的震源是掘锚机，通道（传感器）打在两侧的墙壁上。掘锚机的波向后首先到达传感器，这个波叫做直达波，在提取图上表现为最左侧的一些波，提取前需要去掉；而且因为通道号越大距离掘锚机越远，直达波到达的越晚，所以各个通道的直达波波形是从左上角向右下角。向前的波经过地质遇到分层会反射回来，再次被传感器收到，这个波是我们需要的。







# 3. 后端

---

## （0）测试环境搭建

### 数据路径

数据放入：`var/kwang/frame_data/2025/4/5`

3-背景原始数据

6-全时原始数据

9-提取数据

10-偏移数据

99-再提取数据

### 库表设置

* `var/kwang/frame_data/2025/4/5/6`和`var/kwang/frame_data/2025/4/5/3`下文件的名称需和表`e_data_frm_info`记录保持一致。
* `var/kwang/frame_data/2025/4/5/9`下文件名称要和表`e_mining_signaldata_frm_info`保持一致
* `var/kwang/frame_data/2025/4/5/10`下文件名称要和表`e_mining_pcodata_frm_info`保持一致
* `e_chn_types`
* `e_chns_config`
* `e_chns_config_history`
* `e_chns_config_tunnel`
* `e_mining_PCOLocParm`
* `e_mining_PCOSignalParm`
* `e_mining_PCOSignalParm_history`
* `e_tunnel_extractPara`

## （1）参数含义

### 滤波

* 陷波：消除50周的信号干扰。

### 偏移

传感器发送信号，一来一回，时间乘以速度（速度参数里设定的：P波，S波，导波：P波算的某个网格幅值+S波算的某个网格幅值），再除以2进行画圆，若网格在圆内部，则取这个点的幅值作为这个网格的值。综合起来就是16个通道的所有**幅值的绝对值**（因为幅值有正负）相加，得到某个网格的幅值。即偏移图，通过颜色表示幅值。

折线图，偏移图Y=0那条线上的幅值。

### 叠加信号偏移

再偏移。手动取时间段，将时间段内所有的的偏移图结果（2min），相加再除（取均值）。



## （2）干涉提取

> * 实时计算：干涉源提取+再提取+偏移成图。
> * 历史计算：干涉源提取+偏移成图。再提取需要手动点执行。
>
> * 所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
>
> > 若用背景原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。
> >
> > 若用全时原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。

### 库表

| 表名                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | 9类型数据，提取图数据                                        |
| e_mining_pcodata_frm_info      | 10类型数据，偏移图数据                                       |
|                                |                                                              |
| e_mining_PCOSignalParm         | **实时计算参数，信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **历史计算参数，信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。 |
| e_mining_PCOLocParm            | **实时/历史计算，坐标等参数值。回采位置/回采方向/日进尺/回采位置更新日期**等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | 回采位置/回采位置对应时间戳/日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | 当前使用的通道的设备/编号/类型                               |
| e_chns_config_history          | 从中读取通道历史信息参与历史计算                             |
|                                |                                                              |
|                                |                                                              |

### 参数

* 塑形：选取若干点数，在波形边缘进行，防止吉布斯效应。

* 因子道：所有道和该道进行互相关。

* 互相关：互相关函数，在频率进行。某道和因子道，取某道所有点和因子道第一个点相乘，得到所有点结果相加，再除以点数。得到和因子道第一个点的互相关结果。再和因子道第二个点……以此类推，得到某道所有点的互相关结果。

  因子道和自身自相关。

### 代码

* 历史重算调用回调`handerTunnelSignalProcess`

  ```cpp
  int datasize = int((end_loc - start_loc) / timeLen) + 1;//这里计算dataSize，即为炮数
  
  //拼帧，每一炮拼成一个df，存入sps，最后存入dfvec。dfvec.size()即为炮数。
   logInfo("start mergeMs2");
    std::vector<DataFrame *> dfvec;
    std::vector<DataFrame> sps;
    auto endLoc =
        (fromTime + constTimeLen) > toTime ? toTime : (fromTime + constTimeLen);
    // cout<<" datasize = "<<datasize << endl;
    for (int i = 0; i < datasize; i++) {
      mergeMs(fromTime, endLoc,dev_id)
          .map([&](DataFrame df) {
            auto dftmp = std::move(df);
            sps.push_back(std::move(dftmp));
          })
          .map_error([&](auto err) {
            if (hzi::config.verbose) {
              std::stringstream ss;
              logErr(ss.str());
            }
          });
      fromTime += constTimeLen;
      endLoc =
          (fromTime + constTimeLen) > toTime ? toTime : (fromTime + constTimeLen);
    }
    for (auto &sp : sps) {
      dfvec.push_back(&sp);
    }
  ```

* 并行计算

  对每一炮数据开个线程异步计算。

  ![image-20250422162255401](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-202504221622554011)

  ![image-20250422162201166](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-202504221622011661)

### 



## （3）再提取

> 属于历史重算。
>
> 根据设定好的计算参数对当前选中时间戳的提取数据，**进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`**，并在再提取数据和再提取波形图的基础上，得到新的偏移图。
>
> 重算所得文件名（时间戳）入库表`e_mining_pcodata_frm_info`。

### 库表



### 参数



### 代码

 





## （3）异常预测

### 库表

| -                  | -                                                            |
| ------------------ | ------------------------------------------------------------ |
| e_tunnel_lineInfo  |                                                              |
| e_tunnel_threshold |                                                              |
| e_tunnel_errorinfo | 由表`e_tunnel_lineInfo`和表`e_tunnel_threshold`共同得出表`e_tunnel_errorinfo`记录 |
|                    |                                                              |
|                    |                                                              |

### 代码

实时计算。对每次计算得到的偏移图中异常进行保存，保存到表`e_tunnel_lineInfo`，

`ms_mining.cpp-366-saveResult()`中先通过函数`saveLine()`保存异常结果到表`e_tunnel_lineInfo`，然后通过`writeSvg()`保存偏移图，并入库到表`e_mining_pcodata_frm_info`。

`ms_mining.cpp-5328-getWarningInfo()`中通过查表`e_tunnel_threshold`和表`e_tunnel_lineInfo`，进行k-mean聚类得到【异常预测】结果（也即预测的地质分层面位置与夹角），保存到表`e_tunnel_errorinfo`。

查询表`e_tunnel_errorinfo`绘制到【巷道探测示意图】。



## （4）预警

### 库表

| 表名                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| e_warningInfo_parm    | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts         | **记录了所有的微震事件。**用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info        | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
| e_warning_parm        | 暂时未用                                                     |
|                       |                                                              |

### 代码

`main.cpp-syncWarningInfo()`在子线程循环运行下面逻辑，线程每隔`hzi::config.warningTimeSyncIntval`时间休眠一次：

* `getWarningMsg()`，查表`e_warning_level_value`获取：`msFrequency 微震频次`，`highEnergyNum 大能量事件`，`msLocation 异常区域个数`，`e_sp_variation 自电变化量`，`ee_p_variation 视电阻率变化量`，这5个预警变量的蓝橙红阈值，存在`warningLevelMap`。

* 这5个量的值是计算得来。查表`e_msevt_rslts`（记录所有微震事件）和表`e_warningInfo_parm`（通过微震事件记录的参数计算得到5个预警变量时的一些阈值）。

* 遍历表`e_msevt_rslts`中每条记录，计算得到5个预警变量的值，代码中实际只计算了：微震频次，大能量，异常区域个数。

* 构造msg信息。`msLevelVec`分别保存：【微震频次，大能量，异常区域个数】的预警等级，计算：大于对应预警变量的阈值即为蓝橙红。

  `getMsWarningLevel()`通过`msLevelVec`中保存的【微震频次，大能量，异常区域个数】3个预警等级，综合计算，返回0/1/2/3到**【`msLevel`微震预警等级】，作为微震3个参数计算得到的预警等级**。若为1则蓝色，不为1则橙色，保存到`warningType`。

  * 然后，根据电法信息，得到【电法预警等级`leveL_sp`】，作为电法2个参数计算得到的预警等级。

    再通过一定逻辑，`warningType`中已有的微震预警等级，结合电法预警等级`leveL_sp`，得到最终的【综合预警等级`warningType`】，以及【最终的msg信息】。

    `warningType`，`msLevel`，`leveL_sp`，`msg`入库表`e_warning_Info`。

* 最后，预警发送逻辑：给用户组(msg)发送蓝色和处理后的非蓝色，同时运维组也发一份(告知已发送给用户)

  ```mysql
  string sqlQuery = "SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`=1 AND `is_sent_user`=0 
  UNION 
  SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`> 1 AND `is_handle`= 1 AND `is_sent_user`= 0 "; // 取最新的一条
  ```

  蓝色（`warningType`=1）且未发送给用户，非蓝色（`warningType`> 1）且已被运维处理（`is_handle`= 1）且未发送给用户（`is_sent_user`= 0 ），这些信息发送给用户（alarm）和运维（msg)。

  ```cpp
  string cmdMsg("./send_message.sh \"msg\" \"" + string(" 【预警已发送给用户】 ") + msgTmp + "\"");// 发运维
  string cmdAlarm = "./send_message.sh \"alarm\" \"" +  msgTmp + "\""; // 发用户
  ```

  发送成功，则将表`e_warning_Info`中字段`is_sent_user`置1，表示已发送给用户。

### 预警重算

根据传入的时间段，从表`e_warning_Info`查询已有的预警信息，进行删除。从表`e_msevt_rslts`中重新查询该时间段的微震事件，进行预警的逻辑处理，然后重新入库表`e_warning_Info`。（工程人员会修改表`e_msevt_rslts`中的微震记录，之前的记录是系统自动判别的。）



## （5）掘进里程和偏移距

目的：迎头每天都在向前移动，可以通过【当前掘进里程-偏移距】得到每天第一个传感器的坐标。

**流程：**

每天【掘进里程】和【偏移距】自动增加（当每日进尺和实际一样时，保持自动增加就行。当实际每日进尺和设定不一致时可手动修正），但是【偏移距】不会每天改，只有当偏移距过大的时候，会挪动一组传感器到距离迎头一定位置处。这时偏移距就是新的传感器距离迎头距离了，手动修改【偏移距】。

**代码：**

* 每天【掘进里程】和【偏移距】自动增加：

  `client_handle_data.cpp-185`

  ```cpp
  mining_locx = (m_dir == 0) ? (mining_locx + days * dayStep) : (mining_locx - days * dayStep);
  //mining_locx掘进里程每天增加，hzi::firstChn_locx靠近迎头传感器坐标保持不变，因此相减得新的偏移距，偏移距也会增加，并显示在页面上
  hzi::heading_mil = mining_locx - hzi::firstChn_locx;
  auto ret1 = updateTunnelCurStatus(mining_locx, hzi::heading_mil, hzi::isConnected,hzi::isRunning, "更新掘进位置", false);//将新的掘进里程和偏移距入库
  ```

* 偏移距就是新的传感器距离迎头距离了，手动修改【偏移距】：

  `client_handle_data.cpp-433`

  ```cpp
  auto constDic = hzi::tunnel_mining_loc - hzi::heading_mil - hzi::firstChn_locx;
  //此时偏移距hzi::heading_mil是更新过的，减小了的。hzi::tunnel_mining_loc - hzi::heading_mil是挪过来的检波器和迎头的距离。即新的hzi::firstChn_locx。再减去旧的hzi::firstChn_locx，就是新旧传感器（最靠近迎头）距离迎头距离的差值。
  ```

  `client_handle_data.cpp-472`

  ```cpp
  "values(loc_x) + ?, loc_y=values(loc_y),loc_z=values(loc_z)";
  conn.execute(sql.c_str(), (double)localtime, (double)ts,constDic);//把e_chns_config_tunnel里每个检波器的坐标都加constDic
  hzi::firstChn_locx = hzi::tunnel_mining_loc - hzi::heading_mil;//经过前面的更新，将hzi::firstChn_locx更新为新的
  ```

       

# 4. 页面

---

## （1）首页

### 里程状态与偏移距

![image-20250409154122217](D:\notes\笔记Img\image-20250409154122217.png)

> 基准传感器（之前代码里写死为通道1，后面改为在挪动的时候可指定通道n）距离迎头距离。4个传感器一组，距离过远把最远那一组移到迎头处。

* 调用接口

```cpp
 url = "../setHeadingMil/" + electrodeRadio + "/" + 1;
                    } else {
                        url = "../setHeadingMil/" + electrodeRadio + "/" + 0;
```

### 巷道探测示意图

> 显示预测的地质异常（地质分层的位置和角度）

![image-20250422131919742](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-202504221319197421)

## （2）系统

### 工程参数

#### 停止监测

下发命令字:5,设备地址:1,字节数:22,命令标识:101327

#### 启动监测

250408 09:12:50 下发命令字:2,设备地址:1,字节数:54,命令标识:101328
250408 09:12:50 下发命令字:5,设备地址:1,字节数:22,命令标识:101329
250408 09:12:55 下发命令字:3,设备地址:1,字节数:278,命令标识:101330
250408 09:13:15 下发命令字:4,设备地址:1,字节数:38,命令标识:101331

### 随掘监测

#### 实时参数

将参数保存到表`e_mining_PCOSignalParm`和`e_mining_PCOLocParm`。

表`e_mining_PCOSignalParm`的`class_id`字段决定是拿【全时/背景】数据来计算，函数`getPCO_parm`取参数时，根据flag，查表`e_mining_PCOSignalParm`或表`e_mining_PCOSignalParm_history`来获取实时/历史的参数。

## （3）监测

### 实时数据

#### 微震全时

![image-20250417103359063](D:\notes\笔记Img\image-20250417103359063.png)

## （4）随掘

### 随掘地震

> **该页面上属于历史重算。**
>
> **历史重算目的：通过偏移图进行验证输入的参数的效果。把效果好的参数填入实时参数内，然后进行自动处理，并保存为文件。**

#### 树形图

**查询表`e_mining_pcodata_frm_info`获取数据时间戳。**表`e_mining_pcodata_frm_info`若没记录，表`e_mining_signaldata_frm_info`即使有记录树形图也不会有选项。

#### 干涉源提取

> * 页面上的干涉源提取属于历史重算。只干涉源提取+偏移，再提取+偏移需手动执行。
>
> * 手动选择时间段，进行干涉（互相关或自相关）得到`提取数据(class_id=9)`和`干涉提取波形图`。并在提取数据和提取图的基础上，按照左侧设定的偏移参数进行偏移得到`偏移数据(class_id=10)`的`偏移图`。
>
> * 重算所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
>
>   > 若用背景原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。
>   >
>   > 若用全时原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。
>
> 时间段不要选太大，一般几分钟，否则数据太多响应很慢。
>
> 分段时长，一般设置和时间段一样大。

* 分段时长：`时间段/分段时长=炮数`。代码逻辑中，时间戳转ms，（开始-结束）/分段时长，得到`dataSize`，即炮数。若干炮数的数据叠加（简单的幅值叠加）。

  ![image-20250416141111347](D:\notes\笔记Img\image-20250416141111347.png)

* 调用接口`handerSignalProcess`，内部调用`mergeMs`拼接帧数据，再调用`handleSignalProcess`进行处理。

#### 再提取

> 页面上的干涉源提取属于历史计算。
>
> 需手动点击【执行】。
>
> 根据设定好的计算参数对当前选中时间戳的提取数据，**进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`**，并在再提取数据和再提取波形图的基础上，得到新的偏移图。

从`e_mining_PCOSignalParm_history查表，得到class_id`，表示当前再提取计算使用的数据类型。

![image-20250415161001067](D:\notes\笔记Img\image-20250415161001067.png)

* 点击树形图的时间戳后

  调用接口`/data_file/:year/:month/:day/:type/:timestamp`

  ![image-20250415161308369](D:\notes\笔记Img\image-20250415161308369.png)

* 点击执行后会依次调用接口`/config/:tblName`，回调`setConfig``

* 接口`/handerSignal/:from_time/:to_time/:time_len/:devId`，回调`handerSignalProcess`，调用`handleSignalProcess(dfvec, false,dev_id)`，其中`false`表示进行历史计算。

* 接口`/handerExtSignalParm/:samp_time/:typeId`，回调handleExtSignalData`对类型9文件进行处理

  ![image-20250415161431325](D:\notes\笔记Img\image-20250415161431325.png)

![image-20250415161517845](D:\notes\笔记Img\image-20250415161517845.png)

![image-20250415161559236](D:\notes\笔记Img\image-20250415161559236.png)

# 4. 配置文件

---

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],

	//"semt"微震系统
	//"semt_carousel"轮播图微震系统
	//"tunnel"长沙铁建
	//"tunnel_1"随掘
	//"mining"随采
    "serve_for": "tunnel_1",
    "ms_tunnel_listen":false,
    "http_port": 11507,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": true, //随采
    "ms_miningSignal": true,//
    "save_full_msdata": false,
    "ms_tunnel": true,//
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 2,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",//本地服务器数据库
    "data_root": "/var/kwang/frame_data"//本地服务器数据路径
    // "mysql_url": "mysql://192.168.74.118:3309/semtdb1?user=hzidba&password=dzaqZHk3",//地下坑道随掘数据库
    // "data_root": "/home/kwang/workspace/kengdao_tunnel"//地下坑道随掘数据路径
}
```

```json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.134",
            "device_port": 5086,
            "server_port": 5086
        }
    ],
    //"serve_for": "tunnel_1",
    "serve_for": "semt",
    "http_port": 11507,
    "realtime_interval": 1,
    "link_device": true,
    "time_sync": false,
    "timesync_interval": 10,
    
    "ms_experimental": false,
    "multi_chn_trig": false,
    "ms_grid_step": 0.1,
   
    "ms_tunnel_listen":false,    // 修改成是否有tcp通讯
    "warningType":0,  // warningType 异常预警计算类型（约定 1：铁建移动检波器时异常聚类  2：根据时间进行聚类提取 3：样本数量 4：提取次数）
    "ms_interface_type":0, //采集页面维度类型 0-XY 1-XZ 2-XYZ 
    "ms_mining_type":0,    //随采类型 0-无随采 1-随采 2-随掘
    "ms_components":1,     //微震通道分量设置，默认单分量
    "ms_rate": 0.8,
    "ms_mining":true,
    "ms_miningSignal":true,
    "ms_locating":true,
    "ms_tunnel":true,
    "save_full_msdata":true,
    "ms_trigger":true,
    "is_used_warning":true,

    "warningTimeSyncIntval":2,
    "warningTimeSync":true,
    "tunnel_server":"192.168.72.110",
    "tunnel_port":3002,

    "ftpUrl":"ftp://192.168.74.232:21/shfz/411081005643/WZ/",
    "ftpUserName":"ftpUser",
    "ftpPassWord":"testFTP123456",
    "upWSData":true,

    "digest_duration": 10,
    "optical_strain":true,
    "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/var/kwang/frame_data",
    //"data_root": "/home/kwang/workspace/yuanqu",
    "project_name":"库尔勒金川煤矿",
    "msg_receivers":"WangKun",
    "alarm_receivers":"WangKun",
    "leader_receivers":"GuoJinShuai",
    "probe_to":{
        "min_x":50,
        "max_x":50,
        "min_y":50,
        "max_y":50,
        "min_z":50,
        "max_z":10
    }
}
```

# 5. 通道类型

---

| type_id | 数据类型                  | 通道数                              | 通道label           |
| ------- | ------------------------- | ----------------------------------- | ------------------- |
| 0       | 微震采集                  | datachns[2/3/6]                     | dataChnLabel[2/3/6] |
| 1       | 电法采集                  | datachns[0/1]                       | dataChnLabel[0/1]   |
| 2       | 电法发射eeChannel（激电） |                                     |                     |
| 3       | 电磁采集                  |                                     |                     |
| 4       | 温度采集                  | datachns[4]                         |                     |
| 5       | 电法B极                   | datachns[0]+datachns[2]+datachns[4] | dataChnLabel[5]     |
| 6       | 电法N极                   |                                     |                     |

# 6. 接口

---

> 接口名：routes.cpp
>
> 回调函数：commands.cpp，ms_commands

## 接口模板

```cpp
//GET请求 
Routes::Get(RoutesManager::router, "/devices",
              Routes::bind(&cmd::getDevices));
//POST请求 
Routes::Post(RoutesManager::router, "/save_devices",
              Routes::bind(&cmd::saveDevices));
```

```cpp
  void getDevices(const Rest::Request &request, Http::ResponseWriter response)
  {
    try
    {
      response.headers().add<Http::Header::ContentType>("application/json");
      //string devices = "{";
      string devices="{\"devices\":[";
      string id;
      string device_ip;
      string device_port;
      string server_port;
      auto iter = hzi::config.devicesMap.begin();
      for (; iter != hzi::config.devicesMap.end(); iter++)
      {
        id = std::to_string(iter->second.id);
        device_ip = iter->second.devIp;
        device_port = std::to_string(iter->second.devPort);
        server_port = std::to_string(iter->second.serverPort);
        std::ostringstream oss;
        oss << "{" << "\"id\":" << id << ",\"device_ip\":\"" << device_ip << "\",\"device_port\":" + device_port + ",\"server_port\":" + server_port + "}";
        string device = oss.str();
        // string device = std::format("{id: {0}, device_ip: {1}, device_port: {2}, device_port: {3}}",id,device_ip,device_port,sever_port);
        devices += device;
        devices += ",";
      }
      devices.pop_back();
      devices += "]}";
      response.send(Http::Code::Ok, devices.c_str());
    }
    catch(const std::exception &e)
    {
      response.send(Http::Code::Bad_Request, e.what());
    }
  }
```

## apifox测试接口

```url
https://192.168.74.37:11507/devices
https://192.168.74.37:11507/save_devices/sys_config.json
```

## 错误码

| -    | -                                                         |
| ---- | --------------------------------------------------------- |
| 200  | 成功                                                      |
| 405  | 接口的方法类型搞错了。比如一个接口是POST方法，发了GET请求 |
| 204  | 成功响应但是没有返回内容，No Content                      |
|      |                                                           |



## 接口汇总

| 我写的或修改过的接口                | 功能                                                         | 用法                                 |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------ |
| /upload_save_warningImg/:name       | 上传图片并入库                                               | name传图片名称，包括后缀名           |
| /upload_doc/:mime/:name             | 文件上传：图片，pdf，xlsx，csv                               | mime传后缀名，name传文件名包括后缀名 |
| /download_doc/:mime/:name           | 下载文件：图片，pdf，xlsx，csv                               |                                      |
| /configFilePath                     | 获取配置文件路径                                             |                                      |
| /firstChnNO                         | 获取基准通道号                                               |                                      |
| /devices                            | 获取配置文件中devices字段信息                                |                                      |
| /update_devices/:jsonName           | 修改配置文件中devices字段信息                                | jsonName传配置文件名，包括etc/       |
| /semt                               | 用户登录                                                     |                                      |
| /nopswd                             |                                                              |                                      |
| /warning_recalc/:from_time/:to_time | 预警历史重算：e_warning_info表删除指定时间段内已有预警信息，从e_msevt_rslts中重新筛选记录经过计算入库。 |                                      |



| 接口名                                                       | 功能                                                         | 使用方法                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------- |
| /update_columns/:tblName/:condition                          | 修改已有记录的字段值                                         |                                                       |
| /table/:tblName/:delCondition?                               | 插入（修改）记录或删除记录                                   |                                                       |
|                                                              |                                                              |                                                       |
| /setHeadingMil/:typeId/:isWarning                            | 修改偏移距                                                   |                                                       |
| /config/:tblName                                             | 根据传入json的`is_init`字段：为true时，先删除指定表中`is_init==1`的记录。为false时，先`TURNCATE`清空表。最后，把记录值`INSERT`插入表，is_init置1。 |                                                       |
| /handerSignal/:from_time/:to_time/:time_len/:devId           | 历史计算                                                     |                                                       |
| /handerSignalMining/:from_time/:to_time/:time_len/:devId     | 历史计算（mining？）                                         |                                                       |
| /download/:from_time/:to_time/:is_csv/:file_name             | 选中时间段内原始数据（根据hzi::mining_classId决定类型3/6）拼帧并下载 | is_csv=0-bin文件/1-csv文件/2-qfx文件。file_name未用。 |
| /download/:type_id/:from_time/:to_time/:is_csv/:file_name/:only_ms_valid? |                                                              |                                                       |
| /samp_conf/:tblName/:itmNames/:fromInit?                     |                                                              |                                                       |
|                                                              |                                                              |                                                       |





# 7. 数据库

---

## 查询

```cpp
string sqlQuery="";
auto rslt = conn.executeQuery(sqlQuery.c_str(),val,val,val);
//或是直接写字符串
auto rslt = conn.executeQuery("",val,val,val);

//获取字段函数
rslt.getInt("field");
rslt.getDouble("field");
rslt.getString("field");

//或者
bool ret = queryDb(conn,"SELECT * FROM e_users where user_name=? and password=PASSWORD(?)",user, pswd)?true:false;
```

```cpp
//查询有记录则返回，否则返回字符串异常
template <typename... Args>
tl::expected<ResultSet, std::string> queryDb(Connection &conn, const char *sql, Args... args) 
{
  try 
  {
    ResultSet result = conn.executeQuery(sql, args...);
    if (result.next()) 
    {
      return result;
    } 
    else 
    {
      return tl::make_unexpected("not found in query: " + std::string(sql));
    }
  } 
  catch (sql_exception &e) 
  {
    return tl::make_unexpected("sql error for " + std::string(sql) + ": " + std::string(e.what()));
  }
}
```



## 插入/删/改（若存在则更新）

```cpp
string sql = "INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)";
conn.execute(sql.c_str(), val,val,val);

//或
conn.execute("INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)", val1,val2,val3,val4,val5,val6,val7);
```

## 存储过程

```cpp
//prepareStatement的sql语句需要直接在括号内写字符串，不能先定义为string再传值
Connection conn = hzi::config.pConnPool->getConnection();
PreparedStatement prp = conn.prepareStatement("INSERT INTO e_tunnel_locInfo (mining_loc,tmstamp) values(?,?) ON DUPLICATE KEY UPDATE tmstamp = values(tmstamp)");
conn.beginTransaction();
prp.bind(1, mining_locx);
prp.bind(2, (double)tmstamp);//时间戳转成double再存
prp.execute();
conn.commit();
```

```cpp
function "zdb::PreparedStatement::bind(int, int)" (declared at line 394)
function "zdb::PreparedStatement::bind(int, long long)" (declared at line 398)
function "zdb::PreparedStatement::bind(int, double)" (declared at line 402)
function "zdb::PreparedStatement::bind(int, time_t)" (declared at line 406)
```

## 时间戳相关

库表格式为`bigint`，8位，但存入库中不直接存uint64_t，而是强转为double再存入，用getDouble获取。

```cpp
//获取表内字面值，强转long long int。（uint64_t无法获取字面值）
uint64_t tm = msgSentToUsers.getDouble("tm");
cout<<"tm="<<tm<<endl;//和数据库中所存的值不等
cout<<"tm="<<static_cast<long long>(tm)<<endl;//和数据库中所存字面值相等
auto tmTmp = static_cast<long long>(tm);
conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", tmTmp);

//但这里为什么uint64_t可以取数据库字面值？
string sqlMs = "SELECT * FROM `e_msevt_rslts` WHERE samp_time >=" + std::to_string(fromsampTime) +
                   " and samp_time <= " + std::to_string(endsampTime) + " and validity = 1";
auto rslt_ms = conn.executeQuery(sqlMs.c_str());
```

```cpp
//where?表示where可选，可不传值
//SELECT [cols冒号左侧为字段名field1,field2,...] FROM [tblName] [where];
//response：{"code":0,"data":[{"field1":"field1Val"},{"field2":"field2Val"},...]}
Routes::Get(RoutesManager::router, "/table/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData));//表查询
Routes::Get(RoutesManager::router, "/table1/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData1));//queryTblData1用的是pTempConnPool
```

## 表更新

```cpp
//UPDATE tblName set [请求体updates字段值] where [condition]
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));

//
Routes::Post(RoutesManager::router, "/update/:tblName/:refCol/:updateCol",
               Routes::bind(&cmd::updateColumnRef));

//delCondition传true：delete from [tblName]
//传where语句：delete from [tblName] where ...
//若请求体中有schema和values，遍历json数组schema获取要更新的字段名，遍历json数组value获取要更新的字段的值。请求体中还应有type，指明字段值的类型是string/float/double/int64：insert into [tblName] (field1, field2,...)values('value11','value12',...),('value21','value22',...) on duplicate key update field1=values(value1),field2=values(value2)...;插入多条记录，若有主键相同的记录改为update修改(on duplicate key)
Routes::Post(RoutesManager::router, "/table/:tblName/:delCondition?",
               Routes::bind(&cmd::updateTable));//表增删改


//UPDATE [tblName] set [请求体updates字段值] where [condition].
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));
```

* `response.headers().add<Http::Header::ContentType>("text/plain");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `text/plain`。这表示服务器返回的内容是纯文本格式
* `response.headers().add<Http::Header::ContentType>("application/json; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `application/json; charset='utf-8'`。这表示服务器返回的内容是JSON格式，并且使用UTF-8字符集进行编码。

## 上传图片

```cpp
Routes::Post(RoutesManager::router, "/upload_image/:name",
               Routes::bind(&cmd::uploadImage));

void uploadImage(const Rest::Request &request, Http::ResponseWriter response) {
  response.headers().add<Http::Header::ContentType>(
      "text/plain; charset='utf-8'");
  string name = request.param(":name").as<string>();
  if (request.body().empty() || name == "undefined") {
    response.send(Http::Code::No_Content, "没有传入图片！");
    return;
  } // 理论上，严谨的写法，还需要判断传入的 MIME type 是不是图片

  try {
    string path = "assets/images/" + name;
    std::ofstream fout(path);
    fout.write(request.body().data(), request.body().size());
    fout.close();
  } catch (std::exception &e) {
    string reason = "图片 " + name + " 写入目录错误：" + e.what();
    logErr(reason);
    response.send(Http::Code::Expectation_Failed, reason);
    return;
  }
  response.send(Http::Code::Ok, "图片 " + name + " 上传成功！");
}
```

## 上传数据文件

```cpp
Routes::Post(RoutesManager::router, "/upload_DateFile/:name",
               Routes::bind(&ms_comm::uploadDateFile));


void uploadDateFile(const Rest::Request &request,
                    Http::ResponseWriter response) {
  if (request.body().empty()) {
    response.send(Http::Code::No_Content, "The request body is empty");
    return;
  }
  string name = request.param(":name").as<string>();
  cout << " name = " << name << endl;
  try {
    if (0) {
      //电法反演数据处理
      string fileName2 = "test/1111.dat";
      std::ifstream dat_data("test/1111.dat", std::ios::in);
      string line_dat;

      if (!dat_data.is_open()) {
        return;
      }

      char deli = (fileName2.find(".dat") != std::string::npos) ? '\t' : ',';

      std::vector<string> words_dat; // 声明一个字符串向量
      std::vector<vector<float>> dataVec;

      // 读取数据
      while (std::getline(dat_data, line_dat)) {
        words_dat.clear();
        split_String(line_dat, deli, words_dat);
        //  cout<<" words_dat.size() = "<<words_dat.size()<<endl;
        if (words_dat.size() == 4) {
          vector<float> tmpData;
          tmpData.push_back(atof(words_dat[0].c_str()));
          tmpData.push_back(atof(words_dat[1].c_str()));
          tmpData.push_back(atof(words_dat[2].c_str()) - 720);
          tmpData.push_back(atof(words_dat[3].c_str()));
          dataVec.push_back(tmpData);
          // cout<<atof(words_dat[0].c_str())<<","
          //     <<atof(words_dat[1].c_str())<<","
          //     <<atof(words_dat[2].c_str())<<","
          //     <<atof(words_dat[3].c_str())<<endl;
        }
      }

      float dx = 5;
      float dy = 4;
      float dz = 20;
      float max_x, min_x, max_y, min_y, max_z, min_z;
      max_x = 960;
      min_x = 0;
      max_y = 510;
      min_y = 0;
      max_z = -575;
      min_z = -820;

      int xSize = int((max_x - min_x) / dx);
      int ySize = int((max_y - min_y) / dy);
      int zSize = int((max_z - min_z) / dz);
      cout << " size = " << dataVec.size() << " ," << xSize << " ," << ySize
           << "," << zSize << endl;
      //初始化网格
      vector<vector<vector<GridCell>>> grid;
      initializeGrid(grid, xSize, ySize, zSize);

      for (int i = 0; i < dataVec.size(); i++) {
        auto x = dataVec[i][0];
        auto y = dataVec[i][1];
        auto z = dataVec[i][2];
        auto p = dataVec[i][3];
        int x_index = int((x - min_x) / dx);
        int y_index = int((y - min_y) / dy);
        int z_index = int((z - min_z) / dz);
        // cout<<x_index<<" ,"<<y_index<<","<<z_index<<" ,"
        //     <<x_index<<" ,"<<y_index<<","<<z_index<<endl;
        GridCell cell;
        cell.hasValue = true;
        cell.value = p;
        cell.r = 1;
        cell.intersectValues.push_back(p);
        grid[x_index][y_index][z_index] = cell;
      }

      //克里金插值
      debugLog(" start applyKrigingInterpolation");
      int variogramType = 0; // 0 表示球状模型。1 表示指数模型。2 表示高斯模型。
      applyKrigingInterpolation(grid, xSize, ySize, zSize, variogramType);
      debugLog(" end applyKrigingInterpolation");

      // 2023-12-18 4:00:00
      uint64_t fromsampTime = 1702843200000;
      //保存结果
      auto classId = 30;
      int file_type = 3;
      int constSize = 16; // x,y,z,p 16字节
      unique_ptr<char[]> pHeadData = std::make_unique<char[]>(64);
      char *pHead = pHeadData.get();
      *(double *)(pHead) = (double)fromsampTime;
      *(uint16_t *)(pHead + 8) = constSize; //

      fs::path fileName(hzi::config.dataRoot);

      fileName /= relLocFromTime(fromsampTime) / std::to_string(classId) /
                  std::to_string(fromsampTime) / std::to_string(file_type);
      auto dir = fileName.parent_path();
      if (!fs::exists(dir)) {
        fs::create_directories(dir);
      }
      std::ofstream ofs(fileName, std::ofstream::binary);
      ofs.write(pHead, 64);
      for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
          for (int k = 0; k < zSize; ++k) {
            if (!grid[i][j][k].hasValue)
              continue;
            float x = min_x + i * dx + dx / 2.0;
            float y = min_y + j * dy + dy / 2.0;
            float z = min_z + k * dz + dy / 2.0;

            unique_ptr<char[]> pGridData = std::make_unique<char[]>(constSize);
            char *pGrid = pGridData.get();
            *(uint32_t *)(pGrid) = *((int32_t *)&x);
            *(uint32_t *)(pGrid + 4) = *((int32_t *)&y);
            *(uint32_t *)(pGrid + 8) = *((int32_t *)&z);
            *(uint32_t *)(pGrid + 12) = *((int32_t *)&grid[i][j][k].value);
            //   cout<<x<<","<<y<<","<<z<<","<<grid[i][j][k].value<<endl;
            ofs.write(pGrid, constSize);
          }
        }
      }

      ofs.close();
      cout << "OK" << endl;
      autoHandleData(fromsampTime);
      response.send(Http::Code::Ok, "OK");
      return;
    }

    // Read the request body (the CSV file) into a stringstream

    // std::ifstream csv_data("test/GathEP-X.csv", std::ios::in);
    // string line;
    // if (!csv_data.is_open())
    // {
    //       return;
    // }

    std::stringstream csv_data(request.body().data());

    std::string line;

    std::vector<string> words; // 声明一个字符串向量
    string word;
    string fileHead;
    // 读取标题行
    std::getline(csv_data, fileHead);
    split_String(fileHead, ',', words);
    int chns = 0;
    int points = 0;
    float deltT = 0;
    int prepoint = 0;
    cout << " 1 fileHead = " << fileHead << endl;
    if (words.size() >= 4) {
      chns = atoi(words[0].c_str());
      points = atoi(words[1].c_str());
      deltT = atof(words[2].c_str());
      prepoint = atoi(words[3].c_str());
    }
    cout << " chns = " << chns << " points = " << points << " deltT = " << deltT
         << " prepoint = " << prepoint << endl;

    float **pData = new float *[chns];
    for (int ch = 0; ch < chns; ++ch) {
      pData[ch] = new float[points];
    }
    int index = 0;
    // 读取数据
    while (std::getline(csv_data, line)) {
      words.clear();
      split_String(line, ',', words);
      if (words.size() >= chns) {
        for (int ch = 0; ch < chns; ++ch) {
          pData[ch][index] = atof(words[ch].c_str());
          // if(index < 3){
          //     cout<<pData[ch][index]<<"  ";
          // }
        }
      }
      //  if(index < 3)cout<<endl;
      index++;
    }
    //写入微震事件
    if (0) {
      // unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
      // char* pHead = pHeadData.get();
      const float voltageCoef = 3000.0 / 8388607.0;
      // for (int ch = 0; ch < chns; ++ch) {
      //   for(int pnt = 0;pnt <points;pnt++){
      //     pData[ch][pnt] /= voltageCoef;
      //   }
      // }
      cout << " -- 101 --" << chns << "," << points << endl;
      DataFrame msDf(chns, points);
      cout << " -- 1 --" << endl;
      auto tm = nowMS();
      msDf.setSampTime(tm);
      cout << " -- 2 --" << endl;
      msDf.addDevMask(1);
      cout << " -- 3 --" << endl;
      msDf.setDevMask();
      cout << " -- 4 --" << endl;
      msDf.setClassId(2);
      cout << " -- 5 --" << endl;
      msDf.setHeadValue(19, deltT);
      cout << " -- 61 --" << endl;
      int32_t *p32 = reinterpret_cast<int32_t *>(msDf.upData.get());
      for (int ch = 0; ch < chns; ++ch) {
        for (int pt = 0; pt < points; ++pt) {
          float value = pData[ch][pt];
          int32_t originalValue = static_cast<int32_t>(value * 8388607.0 / 3.0);
          p32[ch * points + pt] = originalValue;
        }
        // std::memcpy(msDf.upData.get() + ch * points * sizeof(float),
        // pData[ch], points * sizeof(float));
      }
      msDf.save();
      //   for (int i = 0; i < 10; ++i) {
      //     std::cout << p32[i] << " ";
      // }
      response.send(Http::Code::Ok, "OK");
      return;
    }

    logInfo("start handleSignalProcess_test");
    // string filepath =
    //     test_mining(pData, points, chns, deltT, prepoint);
    string filepath =
        handleSignalProcess_test(pData, points, chns, deltT, prepoint);
    logInfo(filepath);
    string rslt("{");
    rslt += "\"ms_miningSignal\": \"";
    rslt += std::to_string(hzi::config.ms_miningSignal);
    rslt += "\",";
    rslt += " \"tm\": \"";
    rslt += filepath;
    rslt += "\" } ";
    response.headers().add<Http::Header::ContentType>(
        "application/json; charset='utf-8'");
    // cout << " rslt = " << rslt << endl;

    response.send(Http::Code::Ok, rslt);
    // std::thread(test_scan).detach();
    //  fs::path peerPath(filepath);
    //  if (fs::exists(peerPath)) {
    //      Http::serveFile(response, peerPath.c_str());
    //  } else {
    //      response.send(Http::Code::No_Content, "no_content");
    //  }
    logInfo("endl handleSignalProcess");

  } catch (std::exception &e) {
    logErr(e.what());
    response.send(Http::Code::Expectation_Failed, " uploaded failed!");
    return;
  }
  // response.send(Http::Code::Ok, " uploaded successfully!");
}

```

```cpp
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],
    "serve_for": "semt",
    "http_port": 11504,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": false,
    "ms_miningSignal": false,
    "save_full_msdata": false,
    "ms_tunnel": false,
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 0,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://192.168.74.113:3308/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/home/yzheng/workspace/yuanqu"
}
```

## 变量与表对应

| 变量                                           | 表名                                                 | 说明 |
| ---------------------------------------------- | ---------------------------------------------------- | ---- |
| hzi::viewSpace                                 | e_space                                              |      |
| hzi::densityGrays                              | p_density_grays                                      |      |
| hzi::densityColors                             | p_density_colors                                     |      |
| hzi::msEvtCnf.sampIntvl                        | p_samp_intvls                                        |      |
| hzi::msEvtCnf.msAheadPnt                       | p_points                                             |      |
| hzi::msEvtCnf.pulsWid，hzi::msEvtCnf.ringThrld | e_ms_samp_config                                     |      |
| hzi::msEvtCnf.msThrldsMap                      | e_chns_config（chn_label，ms_trig_thrld,is_ms_trig） |      |
| hzi::viewSpace                                 | e_speed                                              |      |
| hzi::viewSpace.vtispeed_vector                 | e_vti_speeds                                         |      |
| hzi::chnState                                  | e_chns_config（chn_label, state_id）                 |      |
|                                                |                                                      |      |

## 表说明

| 表名                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
|                                |                                                              |
| **参数配置**                   |                                                              |
| e_send_frm_log                 | 服务器向设备发送的命令的日志                                 |
| e_station_info                 | 基站监测，【基站检测应答帧】参数入库                         |
| e_dev_clock                    | 时间校准，【时间校准应答帧】参数入库                         |
| e_dev_config_ack               | 参数配置，【参数配置应答帧】参数入库                         |
| e_users                        | 用户名，密码                                                 |
| e_space                        | 系统-工程参数-空间参数（设定这张表中所存参数：**原点坐标/巷道xyz的范围/网格宽度**等坐标常数）。数据计算时，`getPCO_parm`函数查出存到`PureCommonOperation::PCOLocParm`变量里。 |
| e_info                         | 系统-工程参数-工程参数                                       |
| p_data_types                   | 数据类型编号说明type_id                                      |
| e_tunnel_cur_status            | 存储【掘进位置】【偏移距】【超前距离】【back_distance】【forward_distance】等巷道参数 |
|                                |                                                              |
| e_chns_config_tunnel           | 通道的配置等参数。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn` |
| e_chns_config                  | **用户输入的通道信息**。比如坐标。                           |
| e_chns_config_history          | **通道的历史信息（因为通道会移动，坐标也会改变，而历史计算需要历史的通道的数据）**。通道更新`e_chns_config`时触发器会自动更新该表。代码中用到该表都是查询。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn`变量。 |
|                                |                                                              |
| e_tunnel_serverInfo            | 服务器的ip和port                                             |
| e_tunnel_model_info            |                                                              |
|                                |                                                              |
| **干涉提取**                   |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | 9类型数据，提取图数据                                        |
| e_mining_pcodata_frm_info      | 10类型数据，偏移图数据                                       |
| e_mining_PCOSignalParm         | **实时计算参数，信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **历史计算参数，信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。 |
| e_mining_PCOLocParm            | **实时/历史计算，坐标等参数值。回采位置/回采方向/日进尺/回采位置更新日期**等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | 回采位置/回采位置对应时间戳/日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | 当前使用的通道的设备/编号/类型：0-微震采集，1-电法采集，2-电法发射，3-电磁采集，4-温度采集，5-电法B极，6-电法N极 |
| e_chns_config_history          | 从中读取通道历史信息参与历史计算                             |
|                                |                                                              |
|                                |                                                              |
| **偏移**                       |                                                              |
|                                |                                                              |
| e_data_digest                  |                                                              |
|                                |                                                              |
| **界面提取**                   |                                                              |
| e_tunnel_line_info             | 界面提取，保存从偏移图中提取的：起始点坐标，终止点坐标，与横轴夹角等信息。 |
| e_tunnel_error_info            | 保存对`e_tunnel_line_info`进行【聚类】算法后，得到的【地质异常】（即地质分层） |
|                                |                                                              |
| **预警**                       |                                                              |
| e_warningInfo_parm             | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts                  | 记录了所有的微震事件。用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value          | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info                 | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
|                                |                                                              |
| **随采**                       |                                                              |
| e_mining_surveyLines           |                                                              |
|                                |                                                              |

# 8. 登录

---

表`e_users`

## （1）验证用户名密码

```cpp
//接口
Routes::Post(RoutesManager::router, "/auth_user", Routes::bind(&cmd::authUser));


void authUser(const Rest::Request &request, Http::ResponseWriter response)
{
  Document bodyDoc;
  if (bodyDoc.Parse(request.body().c_str()).HasParseError())
  {
    response.send(Http::Code::Bad_Request, "用户认证格式错");
  }
  string userPswd = bodyDoc["user_pswd"].GetString();
  response.headers().add<Http::Header::ContentType>("text/plain");
  verifyUser(userPswd)
      .map([&](auto r)	{ response.send(Http::Code::Ok, "user_verified:ok"); })
      .map_error([&](auto err)	{ response.send(Http::Code::Unauthorized, "user_verified:failed"); });
}

bool verifyUser(string user, string pswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  auto ret = queryDb(conn, "SELECT * FROM e_users where user_name=? and password=PASSWORD(?)", user, pswd)
                 ? true : false;
  return ret;
}

tl::expected<int, string> verifyUser(string userPswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  return queryDb(conn, "SELECT FROM_BASE64(?) as user", userPswd.c_str())
      .and_then([&](ResultSet userPsw) -> tl::expected<int, string>
                {
    				auto user = string(userPsw.getString("user"));
    				auto colonPos = user.find(":");
    				if (colonPos != string::npos) 
                    {
    				  auto userName = user.substr(0, colonPos);
    				  auto psw = user.substr(colonPos + 1);
    				  return queryDb(conn,
    				                 "SELECT * FROM e_users where user_name=? and "
    				                 "password=PASSWORD(?)",
    				                 userName, psw)
    				      .and_then([&](auto r) { return tl::expected<int, string>(0); });
    				} 
                })
      .or_else([&](auto e) -> tl::expected<int, string>
               {
    			cout << "error:" << e << "\n";
    			return tl::make_unexpected(string("error verifying user:") + e); 
               });
}
```

## （2）修改密码

```cpp
//接口
Routes::Post(RoutesManager::router, "/password/:user/:pswd", Routes::bind(&cmd::changePswd));

void changePswd(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":user").as<string>();
  auto pswd = request.param(":pswd").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  try
  {
    conn.execute("UPDATE e_users set password=PASSWORD(?) where user_name=?",
                 pswd, userName);
    response.send(Http::Code::Ok, "ok");
  }
  catch (sql_exception &err)
  {
    response.send(Http::Code::Bad_Request, err.what());
  }
  // conn.close();
}
```

## （3）用户是否存在

```cpp
//接口
Routes::Get(RoutesManager::router, "/users/:name", Routes::bind(&cmd::userExists));

void userExists(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":name").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  queryDb(conn, "SELECT * from e_users where user_name=?", userName.c_str())
      .map([&](auto r)
           { response.send(Http::Code::Ok, "ok"); })
      .map_error([&](auto err)
                 {
      if (err.find("not found") != string::npos) {
        response.send(Http::Code::Not_Found, "not found");
      } else {
        response.send(Http::Code::Bad_Request, err);
      } });
  // conn.close();
}
```

## （4）用户名密码验证登录流程

```cpp
//commands.cpp
void login(const Rest::Request &request, Http::ResponseWriter response)
```

# 9. 数据采集

---

## （1）原始帧

### 命令字（cmd_id）

| **命令功能** | **命令字** | **字节数****(Byte)** |
| ------------ | ---------- | -------------------- |
| 基站检测     | **0x01**   | 1                    |
| 时间校准     | **0x02**   | 1                    |
| 采集置参     | **0x03**   | 1                    |
| 启动监测     | **0x04**   | 1                    |
| 停止监测     | **0x05**   | 1                    |
| IP地址设置   | **0x06**   | 1                    |
| 连接检测     | **0x07**   | 1                    |
| 对时         | **8**      | 1                    |
| 对时         | **9**      | 1                    |

### 原始信号类型（class_id）

| **类型**       | **通信值**  | **定义**                             |
| -------------- | ----------- | ------------------------------------ |
| 自电数据       | 0x00        | 电法通道实时监测采集信号             |
| 激电数据       | 0x01        | 主动发射引起的激发电场采集信号       |
| 微震触发数据   | 0x02        | 微震通道阈值触发引起的微震采集信号   |
| 微震极值数据   | 0x03        | 微震通道一定时窗内的背景极大值       |
| 温度数据       | 0x04        | 温度通道实时采集的信号               |
| 震电磁耦合数据 | 0x05        | 微震通道耦合阈值引起的全通道采集信号 |
| 微震背景数据   | 0x06        | 微震通道环境背景实时采集信号         |
| 伽玛传感器数据 | 0x0b （11） | 伽马传感器实时采集数据               |

### 数据区

| **字节序号** | **大小（字节）** | **功能**                         | **参数说明**                                                 |
| ------------ | ---------------- | -------------------------------- | ------------------------------------------------------------ |
| D0~D7        | 8                | 采集时间                         | 采集时间8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00 UTC |
| D8           | 1                | 数据类型classId                  | **类型**            **属性**            **说明**                  0x00            自电数据            自然电位信号                  0x01            激电数据            发射电法采集信号                  0x02            微震触发数据            微震触发信号                  0x03            微震极值数据            微震时窗极值信号                  0x04            温度数据            实时温度信号                  0x05            震电磁耦合数据            震电磁‘耦合’信号                  0x06            背景数据            实时采集的背景信号 |
| D9           | 1                | 是否包含电流通道                 | 0x0：否 0x1:是                                               |
| D10~D11      | 2                | 包含通道数                       | 数据量包含数据通道数                                         |
| D12~D15      | 4                | 每通道包含点数                   | 每通道数据点数                                               |
| D16          | 1                | 发射帧序号                       | 电法发射帧序号                                               |
| D17~D18      | 2                | 信号触发通道号                   | 用于微震的信号触发时值最大的通道                             |
| D19          | 1                | 激电发射电压                     | **发射电压**            **说明**                  24V            参考通信值约定中的电压**类型**。                  48V                  72V                  96V |
| D20          | 1                | 该帧数据采集时刻激电是否正在采集 | 0x00:否 0x01:是                                              |
| D21          | 1                | 对时模块网络状态                 | 0x00:失联  0x01:正常                                         |
| D22~D29      | 8                | 对时模块时间信息                 | 8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00  UTC |
| D30          | 1                | 激励电法发射模式                 | 0x00:单正 0x01:正负正 0x02:M序列                             |
| D31          | 1                | 触发通道数                       |                                                              |

* 数据区：电流数据+电压数据
* 电流数据：4字节表示一个电流值，第一个字节最高位为符号位!  总点数为每通道包含点
* 电压数据：4字节表示一个电压值，第一个字节最高位为符号位! 总点数为电法发射采集模式：（包含通道数-1）*每通道包含点数；其余模式：包含通道数*每通道包含点
* 温度数据：2字节表示一个温度值



## （2）数据帧DataFrame（上位机中使用的）



### 数据类型（从什么原始信号构建的数据帧）

**可看库表`p_data_types`：**

![image-20250411173017037](D:\notes\笔记Img\image-20250411173017037.png)

| df.classId() | 数据类型                                  |
| ------------ | ----------------------------------------- |
| 1            | 激电                                      |
| 2            | 微震事件                                  |
| 3            | 微震背景（采样间隔2ms，每个通道2500点）   |
| 4            | 温度数据                                  |
| 5            | 耦合数据                                  |
| 6            | 微震全时（采样间隔0.5ms，每个通道5000点） |
|              |                                           |
| 9            | 提取                                      |
| 10           | 偏移                                      |
| 9            | 界面提取                                  |

| 文件头     |            |                                           |          |                        |
| ---------- | ---------- | ----------------------------------------- | -------- | ---------------------- |
| 位置(字节) | 大小(字节) | 定义                                      | 数据类型 | 说明                   |
| 0          | 8          | 采样时间                                  | double   | 时间戳，毫秒           |
| 8          | 1          | 采样数据类型id                            | uint     | 按协议定义             |
| 9          | 1          | 是否包含电流通道                          | uint8_t  | 1:包含； 0:不包含      |
| 10         | 2          | 包含通道数                                | uint16_t | DataFrame::setChannels |
| 12         | 4          | 每通道数据点数                            | uint32_t | DataFrame::setPoints   |
| 16         | 1          | 激电发射帧序号或微震触发通道号            | uint8_t  |                        |
| 17         | 1          | 激电发射或微震触发基站ID号,主要用于多基站 | uint8_t  |                        |
| 18         | 1          | 保留                                      |          |                        |
| 19         | 4          | 采样间隔                                  | float    | 毫秒                   |
| 23         | 1          | 激电激发类型id                            | uint8_t  | 按协议定义             |
| 24         | 1          | 激电发射电压id                            | uint8_t  |                        |
| 25         | 1          | 该帧数据采集时刻激电是否正在采集          | uint8_t  | 0x00:否，0x01:是       |
| 26         | 1          | 设备拼接掩码                              | uint8_t  | 对应拼接设备ID         |
| 27         | 1          | 是否为拼接帧                              |          |                        |
| 28         | 1          | 激电电压模式                              | uint8_t  | 0:固定；1:智能         |
| 29         | 4          | 保留                                      |          |                        |

| 数据区     |                          |                                      |          |                                |
| ---------- | ------------------------ | ------------------------------------ | -------- | ------------------------------ |
| 位置(字节) | 大小(字节)               | 定义                                 | 数据类型 | 说明                           |
| 32         | 通道数x 每通道数据点数x4 | 原始采样数据值按通道、数据点顺序存放 | int      | 含电流通道时，第一道为电流数据 |

* 字节序：小字节序（高位在后，低位在前）
* 协议：指本公司《微震电法并行物理场监测系统采集通信约定》 
* 数据值： int类型的采样原始数据，未乘系数 
* 从系统页面下载数据文件名约定： yyyy_mm_dd_采集数据类型 id_采样时间戳.semt.bin 

# 10. 微震计算

---

> `ms_mining.cpp`

## （1）函数

| 函数名                                                       | 参数含义 | 函数功能说明                     |
| ------------------------------------------------------------ | -------- | -------------------------------- |
| `string handleSignalProcess(std::vector<DataFrame*> dfVec,bool flag,int dev_id)` |          | 对数据帧进行计算，保存到提取文件 |
|                                                              |          |                                  |

### handleSignalProcess

![call_graph_incoming](D:\notes\笔记Img\call_graph_incoming.svg)

![call_graph_outgoing](D:\notes\笔记Img\call_graph_outgoing.svg)

# 11.日志

---

![日志路径](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\日志路径.png)

# 12. 上传下载

---

## （1）将数据保存为指定格式文件并打包zip下载

> 指定数据保存格式：bin/csv/qtx

```cpp
Routes::Get(RoutesManager::router,
              "/download/:from_time/:to_time/:is_csv/:file_name",
              Routes::bind(&ms_comm::downloadRawDateFile));

//这里是随机生成zip临时文件名为/tmp/hzisemt.zip.XXXXXX，然后下载该文件。
//若想指定下载的zip文件名，可去掉mkstemp64按照文件名模板自动生成随机文件名的代码，而使用从request中解析出的filename
void downloadRawDateFile(const Rest::Request &request, Http::ResponseWriter response) 
{
  uint64_t fromTime = request.param(":from_time").as<uint64_t>();//起始时间
  uint64_t toTime = request.param(":to_time").as<uint64_t>();//终止时间
  auto isCsvId = request.param(":is_csv").as<int>();//文件类型
    
    
  int dev_id = 0;//写死dev_id=0
  auto conn = hzi::config.pConnPool->getConnection();
  auto rslt0 = conn.executeQuery(
      "SELECT dataFreq,dataLen,class_Id  FROM `e_mining_PCOSignalParm`");
  if (rslt0.next()) {
    hzi::miningFreq = rslt0.getInt("dataFreq");
    hzi::miningDateLen = rslt0.getInt("dataLen");
    hzi::mining_classId = rslt0.getInt("class_Id");
  }
  debugLog(" downloadRawDateFile start mergeMs1");

  mergeMs(fromTime, toTime,dev_id)
      .map([&](DataFrame df) {
        auto dftmp = std::move(df);//拼帧为dftmp
        auto chns = dftmp.channels();
        auto tmStmp = dftmp.sampTime();//采样时间
        auto deltT = dftmp.sampIntvl();
        auto points = dftmp.points();
        auto pretime = 0;

        int32_t *p32 = (int32_t *)dftmp.upData.get();
        // 开始下载数据
        struct fileNode 
        {
          string fileName;//文件名
          string filePath;//文件路径
        };

        std::vector<fileNode> files; // 下载文件列表
        fileNode file;
        file.fileName = std::to_string(tmStmp);//文件名是采样时间戳
        file.filePath = "/tmp/" + fileName;//文件路径

        float tmpf;
        vector<vector<float>> v;
        v.resize(chns);
        for (int ch = 0; ch < chns; ++ch) {
          v.at(ch).resize(points);
          for (int pt = 0; pt < points; ++pt) {
            v.at(ch).at(pt) = p32[ch * points + pt] * 3000.0 / 8388607.0;
          }
        }
        if (isCsvId == 0) //如果要下载bin格式文件
        {
          try 
          {
            file.filePath += ".bin";//加个格式后缀
            file.fileName += ".bin";
            //数据写入到文件
            std::ofstream ofs(file.filePath, std::ofstream::binary);
            ofs.write(dftmp.upHead.get(), 32);
            ofs.write((char *)dftmp.upData.get(), chns * points * 4);
            ofs.close();

          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>("text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,"保存文件失败：" + file.filePath);
            return;
          }
        }
        else if (isCsvId == 1) //下载csv格式文件
        {
          file.filePath += ".csv";
          file.fileName += ".csv";
          try 
          {
            //写数据到csv文件
            std::ofstream ofs(file.filePath);
            ofs << chns << ',' << points << ',' << deltT << ',' << (int)pretime
                << std::endl;

            for (int j = 0; j < points; ++j) {
              for (int k = 0; k < chns; ++k) {
                ofs << v.at(k).at(j) << ",";
              }
              ofs << std::endl;
            }
            ofs.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>("text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed, "保存文件失败：" + file.csvLoc);
            return;
          }
        } 
        else if (isCsvId == 2) 
        {
          file.filePath += ".qfx";
          file.fileName += ".qfx";
          STQfxFileHead fhQfx;
          STQfxTraceHead thQfx;
          fhQfx.nTraceCount = chns;
          fhQfx.nSamplePoints = points;
          fhQfx.fSampleInterval = deltT;
          fhQfx.nAdvanPoints = (int)pretime;
          if (fhQfx.nTraceCount < 1 || fhQfx.nSamplePoints < 1 ||
              fhQfx.fSampleInterval < 1e-9f) {
            response.send(Http::Code::Expectation_Failed,
                          "文本数据文件错误：" + file.csvLoc);
            return;
          }

          fhQfx.uchSurveyUnit = QFX_SSU_MV;
          std::ofstream ofsQfx(file.csvLoc);
          ofsQfx.write(reinterpret_cast<char *>(&fhQfx), sizeof(STQfxFileHead));

          thQfx.nSamplePoints = fhQfx.nSamplePoints;
          thQfx.fSampleInterva = fhQfx.fSampleInterval;

          try {
            for (int k = 0; k < chns; ++k) {
              thQfx.uchTraceType = 1;
              thQfx.nTraceNum = thQfx.nOrgTraceNum = k + 1;
              ofsQfx.write(reinterpret_cast<char *>(&thQfx),
                           sizeof(STQfxTraceHead));
              for (int j = 0; j < points; ++j) {
                ofsQfx.write((char *)&v[k][j], sizeof(float));
              }
            }
            ofsQfx.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败 2：" + file.csvLoc);
            return;
          }
        }
        files.push_back(file);//下载的所有文件集合

#pragma region 生成压缩文件
        bool failure = false;
        char zipName[] = "/tmp/hzisemt.zip.XXXXXX";
        int fd = mkstemp64(zipName);//mkstemp64会根据随机替换XXXXXX为数字并返回该文件的描述符
        int filesCnt = 0;	//成功添加到zip中的文件数
        if (files.size() > 0) 
        {
          zip_t *z = zip_open(zipName, ZIP_CREATE | ZIP_TRUNCATE, nullptr);//创建zip文件
          if (z) 
          {
            for (auto file : files) 
            {
              //打开文件为一个source(把source添加到zip中实现添加文件到zip)
              zip_source_t *source = zip_source_file(z, file.filePath.c_str(), 0, 0);
              if (source) 
              {
                //把source添加到zip中，并返回该文件在zip中的index 
                zip_int64_t index = zip_file_add(z, file.fileName.c_str(), source, ZIP_FL_ENC_RAW);
                if (-1 == index/* || -1 == zip_set_file_compression(z, index, ZIP_CM_STORE, 0)*/) 
                {
                  failure = true;
                  zip_source_free(source);//index=-1，文件保存失败，释放source，跳出循环终止后续文件的添加
                  break;
                } 
                else 
                {
                  ++filesCnt;//成功添加文件数+1
                }
              }
            }
            int ret = zip_close(z);//文件添加完毕，关闭zip
            if (-1 == ret) 
            {
              failure = true;
            }
          }
        }
        
        //失败处理
        if (failure) 
        {
          if (fs::exists(zipName)) 
          {
            remove(zipName);	//打包失败，把生成的zip删除
          }
          response.headers().add<Http::Header::ContentType>("text/plain; charset='utf-8'");
          response.send(Http::Code::Expectation_Failed, "无法生成 zip 压缩文件！");
          return;
        }
        if (0 == filesCnt) //zip内没文件
        {
          response.headers().add<Http::Header::ContentType>("text/plain; charset='utf-8'");
          response.send(Http::Code::No_Content, "此时间段内无数据！");
          return;
        }
#pragma endregion
          
        //发送zip
        response.headers().add<Http::Header::ContentType>(MIME3(Application, OctetStream, Zip));
        constexpr int MAX_BUFFER_SIZE = 512;
        char streamBuffer[MAX_BUFFER_SIZE] = {};
        auto stream = response.stream(Http::Code::Ok);
        //  cout<<" fileName22 = "<<fileName<<endl;
        std::ifstream ifs(fileName);
        ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        while (ifs.gcount() > 0) //gcount() 函数用于返回上一次输入操作（如 read、getline 等）实际读取的字符数。
        {
          stream.write(streamBuffer, ifs.gcount());
          stream << flush;
          ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        }
        ifs.close();
        stream << ends;
        close(fd);
```

# 13. 时间戳

---

## （1）unix毫秒时间戳和`YYYY-MM-DD HH:MM:SS.mmm`字符串互转

```cpp
// unix毫秒时间戳（单位ms）转YYYY-MM-DD HH:MM:SS.mmm字符串
std::string timestampToString(int64_t timestamp_ms) 
{
  // Convert milliseconds to seconds and remainder milliseconds
  std::time_t seconds = timestamp_ms / 1000;
  int milliseconds = timestamp_ms % 1000;

  //使用std::localtime函数将seconds（以秒为单位的时间）转换为本地时间，结果存储在tm结构体中
  std::tm *tm = std::localtime(&seconds);

  //存储格式化后的时间字符串（不包括毫秒部分）。大小为24，足以存储"YYYY-MM-DD HH:MM:SS"格式的字符串
  //将tm结构中的时间信息格式化为"YYYY-MM-DD HH:MM:SS"格式的字符串，并存储在buffer中
  char buffer[24];
  std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm);

  //将buffer中的字符串和毫秒部分拼接起来
  //std::setfill('0')设置填充字符为'0'，std::setw(3)设置字段宽度为3，确保毫秒部分总是三位数字，不足时前面补零。
  std::ostringstream oss;
  oss << buffer << '.' << std::setfill('0') << std::setw(3) << milliseconds;

  return oss.str();
}
```

```cpp
// Function to convert a formatted date-time string back to a timestamp in
// milliseconds
int64_t stringToTimestamp(const std::string &datetime_str) 
{
  std::tm tm = {};
  int milliseconds = 0;

  // Manually parse the string "YYYY-MM-DD HH:MM:SS.mmm"
  if (sscanf(datetime_str.c_str(), "%4d-%2d-%2d %2d:%2d:%2d.%3d", &tm.tm_year,
             &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec,
             &milliseconds) != 7) 
  {
    throw std::runtime_error("Failed to parse date-time string");
  }

  // Adjust fields for tm structure
  tm.tm_year -= 1900; // tm_year is years since 1900
  tm.tm_mon -= 1;     // tm_mon is 0-based (0 = January)

  // Convert to time_t (seconds since epoch) and add milliseconds
  std::time_t seconds = std::mktime(&tm);
  if (seconds == -1) 
  {
    throw std::runtime_error("Failed to convert to time_t");
  }

  return static_cast<int64_t>(seconds) * 1000 + milliseconds;
}
```

## （2）将yyyy-MM-dd hh:mm:ss字符串转成yyyyMMddhhmmss字符串

```cpp
std::string convertDateFormat(const std::string& date_str) 
{
    if (date_str.empty()) {
        throw std::invalid_argument("Input date string is empty");
    }

    // 检查输入长度是否符合 "YYYY-MM-DD HH:MM:SS"
    if (date_str.size() != 19) {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 提取并验证格式
    std::string year = date_str.substr(0, 4);
    std::string month = date_str.substr(5, 2);
    std::string day = date_str.substr(8, 2);
    std::string hour = date_str.substr(11, 2);
    std::string minute = date_str.substr(14, 2);
    std::string second = date_str.substr(17, 2);

    // 确保字符的位置符合标准格式
    if (date_str[4] != '-' || date_str[7] != '-' || date_str[10] != ' ' || 
        date_str[13] != ':' || date_str[16] != ':') {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 合并为目标格式
    std::string result = year + month + day + hour + minute + second;
    return result;
}
```



## （3）给定UTC获得北京时间（东八区时间）年/月/日

```cpp
fs::path relLocFromTime(uint64_t timestamp) 
{
  int64_t milli = timestamp + (int64_t)8 * 60 * 60 * 1000; // UTC时间加8h转localtime
  auto mTime = std::chrono::milliseconds(milli);
  auto tp = std::chrono::time_point<std::chrono::system_clock,
                                    std::chrono::milliseconds>(mTime);
  auto tt = std::chrono::system_clock::to_time_t(tp);
  std::tm *date = std::gmtime(&tt);
  //date->tm_year + 1900获取年，date->tm_mon + 1获取月，date->tm_mday获取日
  //构建一个年/月/日文件路径
  return fs::path(to_string(date->tm_year + 1900)) /
         to_string(date->tm_mon + 1) / to_string(date->tm_mday);
}
```



# 14. 字符串处理

---

## （1）字符分割

```cpp
//deli作为分割，从origStr中分割出子字符，保存到vals中
void splitStr(const string &origStr, char deli, std::vector<string> &vals) {
    string str = origStr;

    while (!str.empty()) {
        auto pos = str.find_first_of(deli);
        if (pos == string::npos) {
            // 如果找不到分隔符，将剩余字符串作为最后一个部分
            vals.push_back(str);
            break;
        } else {
            // 提取当前部分并更新剩余字符串
            vals.push_back(str.substr(0, pos));
            str = str.substr(pos + 1); // 更新剩余字符串
        }
    }
}
```

# 15. 数学计算

---

## （1）幂计算

```cpp
//base^power
int safePow(int base, unsigned int power) 
{
  if (power == 0) 
  {
    return 1;
  }
  int p = 1;
  for (int i = 0; i < power; i++) 
  {
    p *= base;
  }
  return p;
}
```

## （2）双精度数值格式化为保留两位小数的字符串

```cpp
// 格式化函数：将双精度数值格式化为保留两位小数的字符串
std::string formatDouble(double value, int fmat) {
  std::ostringstream oss;
  oss << std::fixed << std::setprecision(fmat) << value;
  std::string str = oss.str();

  // If the number is an integer, remove the decimal part
  if (std::fabs(value - static_cast<int>(value)) < 1e-9) {
    str.erase(str.find('.'));
  } else {
    // Remove trailing zeros
    str.erase(str.find_last_not_of('0') + 1, std::string::npos);
    // If there is a dangling decimal point, remove it
    if (str.back() == '.') {
      str.pop_back();
    }
  }

  return str;
}
```

## （3）计算字节形式存储的整数的均值

```cpp
double avg(const char *p, int from, int to) {
  int64_t sum = 0;
  for (int i = from; i < to; i++) {
    sum += *(int32_t *)(p + i * 4);
  }
  return sum / (to - from);
}
```

