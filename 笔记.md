

# 1. 系统概述与业务

---

* 传感器：基站上有根线，线的远端是1号，近端是16号。1号靠近迎头。每个传感器线上固定间距5m。

* 当前掘进里程（掘进位置）：迎头的位置（每天更新）

* 【系统-工程参数-工作面名称/工作面长度和宽度】工作面：大巷侧面是煤层，从大巷侧面垂直开的巷道叫工作面，进风面/出风面以及最后横向挖通构成一个U字形，中间很薄的一层是煤层。可能高度600米只有3米的煤层，其他是岩层。

* 掘进是什么？目的是什么？：主要判断前面有没有构造：水/断层之类的，提前知道，有相应方法处理。

* 【系统-工程参数-空间参数】将煤底层位置设为（0，0，0）

* 【系统-工程参数-通道配置】S1表示基站，GR01表示第一个传感器。（问题：矿上把传感器位置放反了，把线的近端放在了靠近迎头。代码里逻辑可能后面要修改。）

* 【采集置参】：关注**采样间隔**

* 【数据存储策略】：为了节省内存，设定不存储指定的数据。

* 【系统-随掘监测-数据提取】：【1-最小比例~1+最大比例】作为比例，乘以【平均能量时窗】内数据（背景数据）的均值。用【时窗】内数据（背景数据）进行比较，判断是否在掘进。（用背景数据进行判断。全时数据数据量太大）

  判断是否正在掘进过程：通过1h内数据，计算平均值，平均值乘以比例作为基准。后面时窗即以2min为单位计算平均值，若在范围内，则判断这个时窗内为正在掘进。

* 【系统-随掘监测-实时参数】：用全时数据，根据设定参数自动进行提取处理。（随掘地震那里的设定，是为了修改参数值，通过偏移图看效果，找到最适合的参数，填入实施参数的设定参数进行自动提取。）

  监测前方距离：超前探测距离。

  拼接数据类型：一般是微震全时，即在全时数据的基础上进行提取，得到提取图。

![image-20250606092913411](D:\notes\笔记Img\image-20250606092913411.png)

# 2. 随掘地震概述

---

【目的】：监测掘煤前方的地质结构，提前预知水/岩石/煤的存在，做好措施。

【软件系统】：通道采集原始信号，经过干涉源提取生成提取数据和【图提取】。再经过滤波/振幅均衡/反褶积/反射波提取/偏移，得到偏移数据和【偏移图】。最后，通过【界面提取】，从偏移图中提取界面的坐标点和与横轴夹角。最后通过【聚类】算法，对提取的界面进行处理，找出真正的地质异常（也就是分层面），绘制在【首页的巷道探测示意图】。

波在介质中传播，当介质的密度突然发生改变时会发生反射。使用传感器接收反射波，通过系统处理，发现不同介质的分层。随掘系统，波的震源是掘锚机，通道（传感器）打在两侧的墙壁上。掘锚机的波向后首先到达传感器，这个波叫做直达波，在提取图上表现为最左侧的一些波，提取前需要去掉；而且因为通道号越大距离掘锚机越远，直达波到达的越晚，所以各个通道的直达波波形是从左上角向右下角。向前的波经过地质遇到分层会反射回来，再次被传感器收到，这个波是我们需要的。

# 3. 测试环境搭建

---

### 数据路径

数据放入：`var/kwang/frame_data/2025/4/5`

3-背景原始数据

6-全时原始数据

9-提取数据

10-偏移数据

99-再提取数据

### 库表设置

* `var/kwang/frame_data/2025/4/5/6`和`var/kwang/frame_data/2025/4/5/3`下文件的名称需和表`e_data_frm_info`记录保持一致。
* `var/kwang/frame_data/2025/4/5/9`下文件名称要和表`e_mining_signaldata_frm_info`保持一致
* `var/kwang/frame_data/2025/4/5/10`下文件名称要和表`e_mining_pcodata_frm_info`保持一致
* `e_chn_types`
* `e_chns_config`
* `e_chns_config_history`
* `e_chns_config_tunnel`
* `e_mining_PCOLocParm`
* `e_mining_PCOSignalParm`
* `e_mining_PCOSignalParm_history`
* `e_tunnel_extractPara`

# 4. 微震参数含义

---

### 干涉提取

* 塑形：选取若干点数，在波形边缘进行，防止吉布斯效应。

* 因子道：所有道和该道进行互相关。

* 互相关：互相关函数，在频率进行。某道和因子道，取某道所有点和因子道第一个点相乘，得到所有点结果相加，再除以点数。得到和因子道第一个点的互相关结果。再和因子道第二个点……以此类推，得到某道所有点的互相关结果。

  因子道和自身自相关。

* 因子时长：`转成ms，除以采样间隔`得到`pcoParm.coeLen`。

### 滤波

> * 作用：消除50HZ的信号干扰
>
> * 原理：
>
> 

### 偏移

传感器发送信号，一来一回，时间乘以速度（速度参数里设定的：P波，S波，导波：P波算的某个网格幅值+S波算的某个网格幅值），再除以2进行画圆，若网格在圆内部，则取这个点的幅值作为这个网格的值。综合起来就是16个通道的所有**幅值的绝对值**（因为幅值有正负）相加，得到某个网格的幅值。即偏移图，通过颜色表示幅值。

折线图，偏移图Y=0那条线上的幅值。

### 叠加信号偏移

再偏移。手动取时间段，将时间段内所有的的偏移图结果（2min），相加再除（取均值）。

# 5. 配置文件

---

```json
//sys_config.kwang.json
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],

    "serve_for": "tunnel_1",
    "ms_tunnel_listen":false,
    "http_port": 11507,
    "realtime_interval": 5,
    
    "link_device": false,
    
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": true, 
    "ms_mining_type": 2,
    "ms_miningSignal": true,
    "save_full_msdata": false,
    "ms_trigger":true,
    "ms_tunnel": true,
    "warningType": 1,
    "ms_interface_type": 1,
    "digest_duration": 5,
    "optical_strain": false,
    
    // "warningTimeSync":true,//hzi::config.warningTimeSync，是否启用预警（实际有效的）
    // "warningTimeSyncIntval":5,//预警发送消息间隔（查表间隔），单位：min
    // "is_used_warning":false,//is_Used_warning接口返回值的是否使用预警（代码里实际没用它作为判断）
    // "msg_receivers":"WangKun",
    // "alarm_receivers":"GuoJinShuai",
    // "leader_receivers":"GuoJinShuai",
    
    //开发环境
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",//本地服务器数据库
    "data_root": "/var/kwang/frame_data"//本地服务器数据路径

    //园区环境
    // "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",//园区（测试）数据库
    // "data_root": "/var/yuanqu"//园区历史路径（实时：/var/frame_data）
    

    //地下坑道随掘
    // "mysql_url": "mysql://192.168.74.118:3309/semtdb1?user=hzidba&password=dzaqZHk3",//地下坑道随掘数据库
    // "data_root": "/home/kwang/workspace/kengdao_tunnel"//地下坑道随掘数据路径


    //建庄
    // "mysql_url": "mysql://192.168.74.37:3307/semtdb1?user=hzidba&password=dzaqZHk3",
    // "data_root": "/var/kwang/frame_data"
}
```

```json
{
    "devices": 
    [
        {
            "id": 1,
            "device_ip": "192.168.70.134",
            "device_port": 5086,
            "server_port": 5086
        }
    ],
    //"semt"微震系统
	//"semt_carousel"轮播图微震系统
	//"tunnel"长沙铁建
	//"tunnel_1"随掘
	//"mining"随采
    "serve_for": "semt",
    "http_port": 11507,//访问时页面端口，config.httpPort
    "realtime_interval": 1,
    
    "link_device": true,//hzi::config.linkDevice
    
    "time_sync": false,//hzi::config.timeSync，同步所有基站
    "timesync_interval": 10,//hzi::config.timeSyncIntval，每次同步所间隔的时间（单位：s）
    
 	"warningTimeSync":true,//是否启用预警（实际有效的）
    "warningTimeSyncIntval":2,//预警发送消息间隔（查表间隔），单位：min
    "tunnel_server":"192.168.72.110",
    "tunnel_port":3002,
    "warningType":0,  // warningType 异常预警计算类型（约定 1：铁建移动检波器时异常聚类  2：根据时间进行聚类提取 3：样本数量 4：提取次数）
    
    "ms_experimental": false,
    "multi_chn_trig": false,//是否设置微震事件多通道触发（多通道触发, 耗时太长，缓用）
    "ms_grid_step": 0.1,
   
    "ms_mining_type":0,    //hzi::config.ms_mining_type，随采类型：0-无随采，1-随采，2-随掘
    "ms_tunnel_listen":false,    // //hzi::config.ms_tunnel_listen，是否有tcp通讯
    
    "ms_interface_type":0, //采集页面维度类型 0-XY 1-XZ 2-XYZ 
  
    "ms_components":1,     //微震通道分量设置，默认单分量
    "ms_rate": 0.8,
    "ms_mining":true,//是否随采
    "ms_miningSignal":true,
    "ms_locating":true,
    "ms_tunnel":true,
    "save_full_msdata":true,//是否保存全时微震数据帧（入库+写文件）
    "ms_trigger":true,//是否保存微震事件
    "is_used_warning":true,//is_Used_warning接口返回值的是否使用预警（代码里实际没用它作为判断）

    "upWSData":true,//hzi::config.upWSData 
    "ftpUrl":"ftp://192.168.74.232:21/shfz/411081005643/WZ/",
    "ftpUserName":"ftpUser",
    "ftpPassWord":"testFTP123456",
    
    "enable_http":true,//hzi::config.enable_http
    
    "digest_duration": 10,
    "optical_strain":true,

    //"data_root": "/home/kwang/workspace/yuanqu",
    "project_name":"库尔勒金川煤矿",
    "msg_receivers":"WangKun",//预警运维组
    "alarm_receivers":"WangKun",//预警用户
    "leader_receivers":"GuoJinShuai",
    "probe_to":{
        "min_x":50,
        "max_x":50,
        "min_y":50,
        "max_y":50,
        "min_z":50,
        "max_z":10
    },
    
    
    //开发环境
    //"mysql_url": "mysql://218.23.107.89:3312/semtdb1?user=hzidba&password=dzaqZHk3",
    "mysql_url": "mysql://127.0.0.1:3312/semtdb1?user=hzidba&password=dzaqZHk3",//本地服务器数据库
    "data_root": "/var/kwang/frame_data"//本地服务器数据路径

    //园区环境
    // "mysql_url": "mysql://192.168.74.113:3312/semtdb1?user=hzidba&password=dzaqZHk3",//园区（测试）数据库
    // "data_root": "/var/yuanqu"//园区历史路径（实时：/var/frame_data）
    

    //地下坑道随掘
    // "mysql_url": "mysql://192.168.74.118:3309/semtdb1?user=hzidba&password=dzaqZHk3",//地下坑道随掘数据库
    // "data_root": "/home/kwang/workspace/kengdao_tunnel"//地下坑道随掘数据路径


    //建庄
    // "mysql_url": "mysql://192.168.74.37:3307/semtdb1?user=hzidba&password=dzaqZHk3",
    // "data_root": "/var/kwang/frame_data"
}
```

# 6. 系统启动初始化

---

## （0）处理程序启动参数

```cpp
#define CONSTCMDNUMBER 4
static inline std::map<const char *, const char *> helpMap = {
    {"-c", "        系统配置文件"},
    {"-l", "        取消实时微震定位计算，默认开启"},
    {"-a", "        取消实时视电阻率计算，默认开启"},
    {"-v", "        详细输出开关,默认关闭"},
    {"note:", "     指令任意可组合使用(-alc)，也可以分开使用(-a -c -l)  "
        "如需配置文件，文件名称放到最后 "}};
// 退出函数
inline void usage(int exit_value = 0)
{
    for (auto &helpdex : helpMap)
    {
        cout << helpdex.first << "  " << helpdex.second << endl;
    }
    exit(exit_value);
}

int main(int argc, const char *argv[])
{
    //程序执行参数：配置文件，3个命令参数
    //后续代码使用pcmd
    std::shared_ptr<const char *[]> pcmd(new const char *[CONSTCMDNUMBER]
                                         {
                                             "etc/sys_config.json", "verbose", "Mslocating", "AppResis"
                                         });
    /*
    * 对pcmd中存的配置文件名和3个命令参数进行操作
    */
    const char *fileName = pcmd[0];	//配置文件名
    bool b_IsContainsConfig = false;
    if (argc > 1)
    {
        for (int j = 1; j < argc; j++)//遍历每个参数
        {
            const char *pchar = argv[j];//pchar暂存各个当前参数
            switch (pchar[0]) // 确定选项类型：-h,-d,-v,-l,-o;或者其他
            { 
                case '-':	//argv[j]以'-'开头，是命令
                    {
                        for (int i = 1; i < (int)(strlen(pchar)); i++)
                        {
                            switch (pchar[i])
                            {
                                // 确定用户指定的选项：h,d,v,l,o
                                case 'l': // 处理调试：
                                    pcmd[2] = "--disableMslocating";//替换pcmd[2]
                                    break;
                                case 'v': // 处理调试：
                                    pcmd[1] = "--verbose";//替换pcmd[1]
                                    break;
                                case 'c': // 处理调试：
                                    b_IsContainsConfig = true; //表示替换配置文件
                                    break;
                                case 'a': // 处理版本请求
                                    pcmd[3] = "--disableAppResis"; //替换pcmd[3]
                                    break;
                                default: // 无法识别的选项
                                    cout << "hzi:error:unrecognition option -:" << pchar << endl;
                                    usage(-1);
                            }
                        }
                        break;
                    }
                default: // argv[j]不以'-'开头，是文件名
                    {
                        if (b_IsContainsConfig && strstr(string(pchar).c_str(), ".json"))//使用其他配置文件
                        {
                            fileName = pchar;
                            pcmd[0] = std::move(fileName);//替换pcmd[0]
                            break;
                        }
                        else
                        {
                            cout << "不以'-'开头 file name:" << pchar << endl;
                            usage(0);
                            break;
                        }
                    }
            }
        }
    }
    
    //使用pcmd决定程序执行的参数
    ...
}
```

## （1）init()

### Config::init()

```cpp
//这里argc==4，argv==pcmd
static tl::expected<int, string> init(int argc, std::shared_ptr<const char *[]> argv)
{
    if (argc == 4)
    {
        //调用Config::make(string const &jsonConf)读取配置文件json，构造Config类对象conf
        return Config::make(string(argv[0])).and_then([&](Config conf)
        {
         	config = conf;//复制给Config::config（类static变量）
         	cout << "config file: " << argv[0] << endl;
         	for (int k = 0; k < config.devicesMap.size(); k++)
         	{
         	    hzi::sysDevMask += (int)exp2(k);//hzi::sysDevMask以mask形式保存基站数量
         	}
         	if (string(argv[1]) == "--verbose")
         	    config.verbose = true;
         	if (string(argv[2]) == "--disableMslocating")//实时微震定位开关关闭
         	    config.disableMslocating = true;
         	if (string(argv[3]) == "--disableAppResis")//disable实时电阻率计算
         	    config.disableAppResis = true;
         	return initChanelsConfig().and_then([&](auto r)
         	                           { 
         	                           		return initChnLabels(); 
         	                           });
         	// .and_then([&](auto r) {
         	//     if (config.ms_locating && config.ms_experimental)
         	//         std::thread(setupMSRegression).detach();
         	//     return tl::expected<int, string>(0);
         	// });
         	// .and_then([&](auto r) { return readChnLocations(); });
    	});
    }
    return 0;
}

//使用默认配置文件初始化Config对象
static tl::expected<int, string> init(string jFile)
{
    return Config::make(jFile).and_then([&](Config conf)
	{
	    if (hzi::config.verbose)
	    {
	        cout << "Config::make ok\n";
	    }
	    for (int k = 0; k < config.devicesMap.size(); k++)
	    {
	        hzi::sysDevMask += (int)exp2(k);
	    }
	    config = conf;
	    return initChanelsConfig().and_then([&](auto r)
	                               {
	                                   if (hzi::config.verbose)
                                       {
                                           cout << "initChanelsConfig ok\n";
	                                   }
	                                   return initChnLabels(); 
	                               });
	    					     // .and_then([&](auto r) {
	    					     //   if (config.ms_locating)
	    					     //   std::thread(setupMSRegression).detach();
	    					     //   return tl::expected<int, string>(0);
	    					     // });                     
	});
}
```

| 表名          | -    |
| ------------- | ---- |
| p_chn_types   |      |
| e_chns_config |      |
|               |      |

### Config::make()

| 初始化变量                | 数据来源             | 内容                                                        |
| ------------------------- | -------------------- | ----------------------------------------------------------- |
| Config::config.devicesMap | 配置文件             | (基站id，基站类Device)                                      |
| Config::config.probeTo    | e_ms_locating_params | 微震定位范围由边缘检波器延伸(minX,maxX,minY,maxY,minZ,maxZ) |
| Config::config.msDevs     | e_chns_config        | 微震基站数量                                                |
| Config::config.eDevs      | e_chns_config        |                                                             |
|                           |                      |                                                             |

```cpp
static tl::expected<Config, string> make(string const &jsonConf)
{}
```

### Config::initChanelsConfig()

> * getSpeed()
>
> * readnoWorkHours()
>
> * initminingGeologyStructMap()
>
> * initTunnelLocInfo()
>
> * updateTunnelModelInfo()
>
>   计算采空比，入库`e_tunnel_model_info`
>
> * initTunnelGeologyStructMap()

| 初始化变量                                                   | 数据来源                 | 内容                                                         |
| ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| reChannelsLabels（vec）                                      | e_chns_config            | 电极接收通道的label，形如：R1GR01                            |
| eeChannelsLabels                                             |                          | 电极发射通道的label，形如：E1GR01                            |
| msChannelsLabels（vec）                                      |                          | 地震通道的label，形如：S1GR01                                |
| reChannelsNum                                                |                          | 电极接收通道的数量                                           |
| eeChannelsNum                                                |                          | 电极发射通道的数量                                           |
| msChannelsConfigsMap                                         |                          | (地震通道label，该通道的ChanelsConfig)                       |
| reChannelsConfigsMap                                         |                          | (电极接收通道label，该通道的ChanelsConfig)                   |
| eeChannelsConfigsMap                                         |                          | (电极发射通道label，该通道的ChanelsConfig)                   |
|                                                              |                          |                                                              |
| Config::config.devicesMap.second.dataChns                    | e_chns_config            | 该基站中对应各种类型的通道的数量，按p_data_types顺序         |
| Config::config.devicesMap.second.dataChnLabel                |                          | 该基站中各数据类型通道labels，按p_data_types顺序             |
| Config::config.devicesMap.second.minChns                     |                          | 该基站各通道类型起始通道编号，按p_chn_types顺序              |
|                                                              |                          |                                                              |
| hzi::msEvtCnf.msThrldsMap                                    | e_chns_config            | (微震通道label，微震触发阈值，是否用于微震触发)              |
|                                                              |                          |                                                              |
| **getSpeed()**                                               |                          |                                                              |
| hzi::viewSpace::xMax等                                       | e_space                  |                                                              |
| hzi::viewSpace::evenSpeed等                                  | e_speed                  |                                                              |
| hzi::viewSpace::vtispeed_vector                              | e_vti_speeds             |                                                              |
|                                                              |                          |                                                              |
| **readnoWorkHours()**，注意`is_saveFile()`函数的调用链       |                          |                                                              |
| hzi::ms_bjVec                                                | e_samp_workHours         | 不保存微震背景数据的时间段                                   |
| hzi::ms_qsVec                                                |                          | 不保存微震全时数据的时间段                                   |
| hzi::ee_jdVec                                                |                          | 不保存激励电法数据的时间段                                   |
| hzi::ms_ohVec                                                |                          | 不保存震电耦合数据的时间段                                   |
|                                                              |                          |                                                              |
| **initminingGeologyStructMap()**                             |                          |                                                              |
| hzi::miningFreq                                              | e_mining_PCOSignalParm   | 数据频度（单位时间 h)                                        |
| hzi::miningDateLen                                           |                          | 数据时长（单位时间min)                                       |
| hzi::mining_classId                                          |                          | 拼接数据类型（6 微震全时 3-微震背景）                        |
| hzi::miningGeologyStructMap                                  | e_mining_struct_vertices | 地质构造：(id，地质构造GeologyStruct)，GeologyStruct内保存按照id分组且按照`vert_no`排序的记录(按id分组，vert_no不同)。`geologymap.second.locVec[vert_no - 1][0]`存x，`geologymap.second.locVec[vert_no - 1][1]`存y。 |
|                                                              |                          |                                                              |
| **initTunnelLocInfo()**                                      |                          |                                                              |
| hzi::tunnel_mining_loc                                       | e_tunnel_locInfo         | 日掘进状态                                                   |
| hzi::heading_mil                                             |                          |                                                              |
| hzi::firstChnNO                                              |                          |                                                              |
| hzi::day_step                                                |                          |                                                              |
| hzi::firstChn_locx                                           |                          |                                                              |
| dir                                                          | e_mining_PCOLocParm      |                                                              |
| hzi::tunnel_server                                           | e_tunnel_serverInfo      | 服务器ip和端口                                               |
| hzi::tunnel_port                                             |                          |                                                              |
|                                                              |                          |                                                              |
| **initTunnelGeologyStructMap()**                             |                          |                                                              |
| 表为空则插入                                                 | e_geology_info           | 岩性id，岩性（沙灰煤泥），p波速度，s波速度                   |
| geoMap。e_tunnel_geology_info若为空，插入初始数据，否则读取到geoMap | e_tunnel_geology_info    | label：岩性符号（RCF），lithologyId：岩性ID（从1起）         |
| hzi::miningGeologyStructMap                                  | e_mining_struct_vertices | 同上，且增加了：x_max，x_min，y_max，y_min，speed_p，speed_c，speed_s的初始化。（某种岩性的分布范围？） |
|                                                              |                          |                                                              |
| **setRotationMatrix()**                                      |                          |                                                              |
| hzi::rotationMatrixZ                                         | e_model_matrix           | 局部坐标系->大地坐标系旋转矩阵，只平移和绕z轴旋转            |
|                                                              |                          |                                                              |

### initChnLabels()

| 初始化变量                                | 数据来源      | 内容                                                     |
| ----------------------------------------- | ------------- | -------------------------------------------------------- |
| hzi::config.devicemap.second.dataChnLabel | e_chns_config | 各个基站的各数据类型通道的label                          |
| hzi::chnState                             | e_chns_config | 所有通道的(label,state_id)，state_id：正常/损坏/耦合不佳 |

# 7. startReceiver()

---

| 初始化变量                       | 数据来源                                      | 内容                                                         |
| -------------------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| serverPortList                   | `hzi::config.devicesMap[i].second.serverPort` | 与每个基站通信的服务器端口号                                 |
| hzi::config.deviceConnections    | serverPortList.size()                         | 基站连接数                                                   |
| hzi::config.MaxDeviceConnections | serverPortList.size()                         |                                                              |
|                                  |                                               |                                                              |
| **startReceiver2()**             |                                               | 对每个基站的数据开一个线程调用该函数处理接收                 |
| hzi::config.devSockMap           | hzi::config.devicesMap和clientfd              | (devicemap.second.id，new_sock)基站的id和服务器分配给该基站的client sockfd |
|                                  |                                               |                                                              |
| **handle_buf()**                 |                                               | 双缓冲区处理数据接收和粘包，从接收缓冲区中查找并提取完整的数据帧，将帧交给独立线程`receive_frame`处理，剩余数据存入备用缓冲区。 |
|                                  |                                               |                                                              |
| **receive_frame()**              |                                               | 初步处理回传（下位机--->上位机服务器）原始帧数据             |
|                                  |                                               |                                                              |
| **※handleRecvCmd()**             |                                               | 根据命令字cmd_id处理各类应答帧                               |
|                                  |                                               |                                                              |
| **recvBaseStationCheck()**       |                                               | 基站检测应答帧，解析并入库                                   |
| e_station_info                   |                                               | 基站设备信息入库。（设备信息是和基站连接后，由基站设备取回的基站信息，使用过程中不可修改） |
|                                  |                                               |                                                              |
| **recvClockCalibr()**            |                                               | 时间校准应答帧，解析并入库                                   |
| e_dev_clock                      |                                               | 时间基准                                                     |
|                                  |                                               |                                                              |
| **recvConfig()**                 |                                               | 采集置参应答帧，解析并入库                                   |
| e_dev_config_ack                 |                                               | 发射板是否置参成功                                           |

> [!NOTE]
>
> 原始应答帧接收，处理。
>
> * startReceiver2()——-多线程接收基站数据：每个线程在不同port上accept接收基站连接
>
>   > * handle_buf()——双缓冲区处理TCP粘包，获得一个原始数据帧buf
>   >
>   >   > ```cpp
>   >   > /*
>   >   > * buf1：当前处理数据缓冲区
>   >   > * pBuf1：记录buf1当前数据处理位置
>   >   > * buf2：处理粘包数据缓冲区
>   >   > * pBuf2：记录buf2当前数据处理位置
>   >   > *
>   >   > * 帧头不完整时，该次处理结束，数据留在buf1缓冲区里，记录待处理数据长度在mapbytesSum[port]中
>   >   > * 数据长度不足succs时，处理同上
>   >   > * 数据长度足够succs时，将buf1中数据所有权转移到receive_frame中处理，buf1清空，等待下一次while循环
>   >   > * 处理完一帧后，如果buf1中还有数据，将剩余数据放到buf2中，记录待处理长度在mapbytesSum[port]中
>   >   > */
>   >   > ```
>   >   >
>   >   > * receive_frame()——处理完整的一个原始数据帧buf
>   >   >
>   >   >   > * handleRecvCmd()——根据`cmd_id`，分类处理原始数据帧
>   >   >   >
>   >   >   >   > * recvBaseStationCheck()——//基站检测应答
>   >   >   >   > * recvClockCalibr()——//时间校准应答
>   >   >   >   > * recvConfig()——//采集置参
>   >   >   >   > * recvData()——//监测应答

## recvData()

| 初始化变量                                    | 数据来源                         | 说明                                                         |
| --------------------------------------------- | -------------------------------- | ------------------------------------------------------------ |
| **recvData()**                                |                                  | 监测应答帧处理                                               |
| p_samp_intvls                                 |                                  | (采样间隔id，不同时长的采样间隔时间ms)                       |
| p_time_wins                                   |                                  | (时窗id，不同时长的时窗时间ms)                               |
| e_e_samp_config                               |                                  | （电法采样参数配置表）获取电法采样间隔。获取激电电压模式。   |
| e_ms_samp_config                              |                                  | （微震采样参数配置表）获取微震采样间隔。获取微震背景极值检测时窗。 |
| e_tempr_samp_config                           |                                  | （温度采样参数配置表）获取温度采样间隔。                     |
| e_coupl_samp_config                           |                                  | （耦合采样参数配置表）耦合采样间隔。                         |
| hzi::config.devicesMap[devAddr].sampling      | true                             | 发送该原始帧的【基站是否正在采集(全局变量)】置为true         |
| hzi::config.devicesMap[devAddr].lastSampTime  | df.sampTime()                    | 发送该原始帧的【基站最后采集时间(全局变量)】                 |
| hzi::serverStatus.lastSampTimes[df.classId()] | df.sampTime()                    | 该原始帧代表的【该类型数据帧最后采集时间(全局变量)】         |
| e_data_frm_info                               | DataFrame::saveIntoDataFrmInfo() | 数据帧信息（路径）入库表                                     |
| e_data_digest                                 | DataFrame::saveIntoDataDigest()  |                                                              |
|                                               |                                  |                                                              |
| **getEngDenityParm()**                        |                                  |                                                              |
| engParmList                                   | e_tunnel_pickDateTime            | 各个通道的时窗采样参数                                       |
|                                               |                                  |                                                              |
| **insertTunnelDataInfo()**                    |                                  |                                                              |
| e_tunnel_RunningDataInfo                      |                                  |                                                              |
|                                               |                                  |                                                              |
| **ms_locating()**                             |                                  |                                                              |
|                                               | e_daily_sheet_config             |                                                              |
|                                               | e_ms_locating_params             |                                                              |
|                                               | e_msevt_psoparm                  |                                                              |
|                                               | e_msevt_engparm                  |                                                              |
| e_data_frm_info                               |                                  |                                                              |
| e_msevt_1st_arrs                              |                                  |                                                              |
| e_msevt_rslts                                 |                                  |                                                              |

> [!NOTE]
>
> * DataFrame::make()——根据原始帧**构造数据帧**
>
>   > * StartMonitor::getIntvl()——根据原始帧类型获取采样间隔
>   >
>   >   > * StartMonitor::setIntvlsFromDb()
>   >   >
>   >   >   > * queryPntIntvl()——根据原始帧类型id查表获取采样间隔
>
> * is_saveFile()——根据【数据存储策略】判定**是否保存数据帧**
>
> * handleData()——数据帧入库，保存文件。**数据帧按照`df.classId()`分类处理**。
>
>   > * DataFrame::save()——**保存数据帧**
>   >
>   >   > * DataFrame::saveIntoDataFrmInfo()——根据配置文件字段将数据帧信息入库表`e_data_frm_info`
>   >   >
>   >   > * DataFrame::saveIntoDataDigest()——保存摘要（全时微震，温度，伽马，激电数据帧不保存摘要）信息入库表`e_data_digest`
>   >   >
>   >   >   > * DataFrame::chnLabels()——若是拼接数据帧，获取该df中所有基站的（该数据帧类型的）通道label拼接vector
>   >   >   > * DataFrame::isFullTimeFrame()
>   >   >   > * struct Digest——通道的数据的摘要信息（最小值，最小值索引，最大值，最大值索引，，绝对值最大值，绝对值最大值索引，所有点均值）
>   >   >   > * std::map<string, Digest> digests——label相同的通道的摘要信息（可能考虑不同基站有相同label的通道？）
>   >   >
>   >   > * DataFrame::saveFrmToFile()——保存到文件
>   >
>   > * createEngDensity()——写死只`classId==3`数据帧的数据帧中数据写入【平均能量文件】的内存映射`densityMMaps`
>   >
>   >   > * setupDensityFile()——创建摘要文件，并通过mio库映射到变量`densityMMaps`
>   >
>   > * handleTimeStamp()——写死只`classId==3`数据帧，微震背景数据帧的摘要处理（**能量密度文件**）
>   >
>   >   > * getEngDenityParm()——从表`e_tunnel_pickDateTime`读取能量密度计算用的参数
>   >   >
>   >   >   > * getWnEng()——从`digest_256.dat`文件中读取时窗内总能量和点数分别到`sumvalue`和`points`
>   >   >   >
>   >   >   > * **readEngDenity()——没看懂**
>   >   >   >
>   >   >   >   > * matchValue()
>   >   >   >   > * insertTunnelDataInfo()——入库表
>   >
>   > * handleTimeStamp_tunnel()——铁建随掘数据帧实时处理（时长10min，起止时间由ConnectServer.cpp-L231赋值）
>   >
>   >   > * mergeMs_tunnel()——铁建随掘拼帧（不同点：起止时间，还受到表`e_tunnel_RunningDataInfo`记录影响）
>   >   > * handleSignalProcess(dfvec, true, 0)——实时处理
>   >
>   > * createDensity()——写死只`classId == 0 `或` classId == 3`，自电或微震背景数据帧，数据写入**密度文件**
>   >
>   > * FrameQueue——数据帧有锁消息队列
>   >
>   > * digMsEvent()——`hzi::frameQueues`中取微震全时拼接数据帧，从中**提取微震事件**（通道处于，阈值触发），根据`hzi::config.multiChnTrig`决定调用单通道触发处理还是多通道触发处理。拿到pair，结合微震超前点数，得到**微震事件数据帧（还是DataFrame）**。
>   >
>   >   > * checkMSEvt()——单通道触发：只有一个通道触发，返回数据帧df的(最后一个触发的通道的label，第一个触发点）的pair。
>   >   >
>   >   >   > * checkChn4MSEvt()——检查指定通道中是否有微震事件点（找到微震事件点则返回点索引，否则返回传入的上次微震事件点）返回(触发的通道label，第一个触发点)的pair。
>   >   >   >
>   >   >   >   > * 判定点属于触发点：`abs(pPnts[j]) * hzi::config.voltageCoef >=hzi::msEvtCnf.msThrldsMap[chLabel].first`
>   >   >   >   > * 连续触发点数大于脉宽：`j - i + 1 >= hzi::msEvtCnf.pulsWid`
>   >   >   >   > * **voltageCoef = 3000.0 / 8388607.0——这是什么？**
>   >   >
>   >   > * checkMSEvt1()——多通道触发
>   >
>   > * setTrigChn()——微震数据帧，设置：基站号，发生微震触发的通道号，classId为2
>   >
>   > * evtFrm.save()——保存微震数据帧，**classId=2**
>   >
>   > * handleMSEvent()——处理微震事件数据帧
>   >
>   >   > * MSDataFrame类
>   >   >
>   >   > * MSDataFrame::digEventFromBg()——从微震背景生成事件（//samptime前的10秒内取3个微震背景数据帧），重新生成`MSDataFrame`帧并save()
>   >   >
>   >   > * ms_locating1()——选择微震定位算法处理`MSDataFrame`帧
>   >   >
>   >   >   > * ms_locating()——
>   >   >   >
>   >   >   >   > * getMeanValue_miningLocX()
>   >   >   >   > * STELResult类——微震事件结果
>   >   >   >   > * CalEventProperty()——计算微震结果保存于`msRslt`
>   >   >   >   > * tagEventByPArrVari()
>   >   >   >
>   >   >   > * MSDataFrame::locating()
>

# 8. syncAllDevices()

---

## （1）时间同步

* 假设基站时间不精确，偏移为offset，帧传递时间为D。

* sync1帧（主-->从）：发送sync1帧时刻主机时间t1（当sync1帧到达从的时刻，下面类推，主知道：t1；从知道：t1，t2）
* sync1应答帧（主<--从）：收到sync1帧时刻基站时间t2（主知道：t1，t2；从知道：t1，t2）
* sync2帧（主-->从）：收到sync1应答帧时刻主机时间t3（主知道：t1，t2，t3，从知道：t1，t2，t3）
* sync2应答帧（主<--从）：收到sync2帧时刻基站时间t4（主知道：t1，t2，t3，t4；从知道：t1，t2，t3，t4）

* 当sync2应答帧被主机接收到时刻：t1,t2,t3,t4，主从均知。
  $$
  (t2-offset)-t1=t2-t1=D+offset \cdots① \\
  t3-(t2-offset)=t3-t2=D-offset \cdots②（此时从已知t1,t2,t3,t4；可算出D和offset）\\
  (t4-offset)-t3=t4-t3=D+offset \cdots③（此时主已知t1,t2,t3,t4；可算出D和offset）
  $$

> [!NOTE]
>
> 遍历`devicemap`同步所有基站
>
> * sync1()——同步1个devAddr指定的基站
>
>   > * sender::sendCmd(uint8_t addr, uint8_t cmdId, const char *data)——向指定基站下发指定命令字的原始帧数据
>   >
>   >   
>   >
>   >   

# 9. start_http_server()

---

> * 基于 Pistache 库的 HTTP 服务器配置，在指定端口上，启动http服务器

```cpp
if (hzi::config.enable_http) {
    cout << "http enabled\n";
    std::thread(start_http_server).join();//在指定端口上启动http服务，函数位置：web/http_server.cpp
} else {
    cout << "http disabled\n";
    // 仅采集时启动中继置参服务
    std::thread(sse::startConfRelayer).detach();
    std::thread(sse::startSSERelayer).join();
}
```

```cpp
//routes.hpp
#ifndef ROUTES_HPP
#define ROUTES_HPP

#undef TRY
#include <pistache/endpoint.h>
#include <pistache/router.h>

using namespace Pistache;
using namespace Rest;

class RoutesManager : public Http::Endpoint
{
  Rest::Router router;

public:
  RoutesManager(Address addr);
};

#endif
```

```cpp
//routes.cpp
#include "routes.hpp"
RoutesManager::RoutesManager(Address addr) : Http::Endpoint(addr)
{
    //接口
    Routes::Get(RoutesManager::router, "/firstChnNO",Routes::bind(&ms_comm::getFirstChnNO));
    ...
    
    setHandler(router.handler());
}
```

```cpp
//ms_commands.cpp
//存放接口回调函数
namespace ms_comm 
{
    void getFirstChnNO(const Rest::Request &request,
                       Http::ResponseWriter response)
    {
        try
        {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Ok, to_string(hzi::firstChnNO).c_str());
        } 
        catch (const std::exception &e) 
        {
            response.send(Http::Code::Bad_Request, e.what());
        }
    }
}
```

```cpp
//http_server.hpp
#ifndef HTTP_SERVER_HPP
#define HTTP_SERVER_HPP

#include "routes.hpp"

void start_http_server();

#endif
```

```cpp
//http_server.cpp
#include "../Config.hpp"
#include "../common.hpp"

#undef TRY
#include "http_server.hpp"

void start_http_server() {
    RoutesManager app({Ipv4::any(), hzi::config.httpPort});//监听所有网卡，端口号config.httpPort
    logInfo("端口"+std::to_string(hzi::config.httpPort)+"上HTTP服务已启动");
    unsigned int nCores = std::thread::hardware_concurrency();//std::thread::hardware_concurrency() 获取系统支持的硬件线程数
    auto opts = Pistache::Http::Endpoint::options()//创建一个配置对象，用于设置服务器选项
        .maxRequestSize(1024 * 1024 * 5)//设置最大请求数量
        .threads(nCores/2)//设置服务器使用的线程数为系统硬件线程数的一半。
        .flags(Pistache::Tcp::Options::ReuseAddr);//设置套接字选项为 ReuseAddr，允许重新使用本地地址。
    app.init(opts);
    app.useSSL("etc/cert/xxx.pem",
               "etc/cert/xxx.key");//useSSL 方法用于配置服务器的 SSL 证书和密钥文件路径，启用 HTTPS 支持。
    app.serve();//启动http服务器，开始监听客户端请求
```

# 10. syncUpWSdata()

---

> [!NOTE]
>
> * isSaturdayMorning()——判断给定时间戳是否是10点到12点之间（flag为true时判断是否是周六的10点到12点）
>
> * writeFTPFile()——发送微震数据
>
>   > * getGeodeticPoint()——系统坐标转大地坐标
>   >   $$
>   >   Z=RX+Y\\
>   >   R为旋转变换，Y为平移变换
>   >   $$
>   >   
>   >   $$
>   >   \begin{bmatrix}
>   >   z_1\\
>   >   z_2\\
>   >   z_3
>   >   \end{bmatrix}
>   >   =
>   >   \begin{bmatrix}
>   >   r_{00} & r_{01} & r_{02}\\
>   >   r_{10} & r_{11} & r_{12}\\
>   >   r_{20} & r_{21} & r_{22}
>   >   \end{bmatrix}
>   >   \begin{bmatrix}
>   >   x_1\\
>   >   x_2\\
>   >   x_3
>   >   \end{bmatrix}
>   >   +
>   >   \begin{bmatrix}
>   >   y_1\\
>   >   y_2\\
>   >   y_3
>   >   \end{bmatrix}
>   >   $$
>   >   
>

| 库表           | 读写变量                       | 读写变量说明           | 表说明                                                       |
| -------------- | ------------------------------ | ---------------------- | ------------------------------------------------------------ |
| e_acqui_points | dataFile                       | 微震基础信息           | 微震数据基础信息表？                                         |
| e_model_matrix | geodeticOrigin，rotationMatrix | 原点大地坐标，变换矩阵 | 存储：原点的大地坐标及变换矩阵（4行，item=origin/vector_x/vector_y/vector_z） |
| e_info         | wf_name                        | 采煤工作面名称         | 工程参数表                                                   |
| e_msevt_rslts  |                                |                        | 微震事件                                                     |

# 10. sendCmd()

---



# 11. 数据采集

---

## （1）原始帧

### 命令字（cmd_id）

> **决定帧类型**
>
> 不同功能的帧数据区长度不同。

| **命令功能**      | **命令字** | **字节数****(Byte)** |
| ----------------- | ---------- | -------------------- |
| 基站检测          | **0x01**   | 1                    |
| 时间校准          | **0x02**   | 1                    |
| 采集置参          | **0x03**   | 1                    |
| 启动监测          | **0x04**   | 1                    |
| 停止监测          | **0x05**   | 1                    |
| IP地址设置        | **0x06**   | 1                    |
| 连接检测          | **0x07**   | 1                    |
| 对时（1588同步1） | **8**      | 1                    |
| 对时（1588同步2） | **9**      | 1                    |

### 原始帧格式

> [!WARNING]
>
> 监测数据应答帧，增加了【参数区】

| 起始位置                                 | 长度（字节）     | 功能                                | 说明                   |
| ---------------------------------------- | ---------------- | ----------------------------------- | ---------------------- |
| 0                                        | 4                | **帧头**                            | 固定值：**0x68696869** |
| 4                                        | 4                | **后续字节数（不包括帧头+本字段）** | 帧长度-8               |
| 8                                        | 1                | **校验标志**                        |                        |
| 9                                        | 1                | **设备标识**                        | 和设备地址什么区别？   |
| 10                                       | 1                | **设备地址**                        | 设备拼接掩码，即dev_id |
| 11                                       | 1                | **命令字**                          |                        |
| 12                                       | 4                | **命令标识**                        |                        |
|                                          |                  |                                     |                        |
| 16                                       | 32               | **参数区**                          | 监测数据应答帧才有     |
|                                          |                  |                                     |                        |
| 16(监测数据应答帧因存在参数区，从32起始) | 视原始帧类型而定 | **数据区**                          |                        |
|                                          |                  |                                     |                        |
|                                          | 4                | **校验区**                          |                        |
|                                          | 2                | **帧尾**                            | 固定值：**0x1616**     |
|                                          |                  |                                     |                        |

### 原始帧数据类型（class_id）

| **类型**       | **通信值**  | **定义**                             |
| -------------- | ----------- | ------------------------------------ |
| 自电数据       | 0x00        | 电法通道实时监测采集信号             |
| 激电数据       | 0x01        | 主动发射引起的激发电场采集信号       |
| 微震触发数据   | 0x02        | 微震通道阈值触发引起的微震采集信号   |
| 微震极值数据   | 0x03        | 微震通道一定时窗内的背景极大值       |
| 温度数据       | 0x04        | 温度通道实时采集的信号               |
| 震电磁耦合数据 | 0x05        | 微震通道耦合阈值引起的全通道采集信号 |
| 微震背景数据   | 0x06        | 微震通道环境背景实时采集信号         |
| 伽玛传感器数据 | 0x0b （11） | 伽马传感器实时采集数据               |

### 监测数据应答帧（下位机--->上位机服务器）参数区

| **字节序号** | **大小（字节）** | **功能**                         | **参数说明**                                                 |
| ------------ | ---------------- | -------------------------------- | ------------------------------------------------------------ |
| D0~D7        | 8                | 采集时间                         | 采集时间8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00 UTC |
| D8           | 1                | 原始帧类型classId                | **类型**            **属性**            **说明**                  0x00            自电数据            自然电位信号                  0x01            激电数据            发射电法采集信号                  0x02            微震触发数据            微震触发信号                  0x03            微震极值数据            微震时窗极值信号                  0x04            温度数据            实时温度信号                  0x05            震电磁耦合数据            震电磁‘耦合’信号                  0x06            背景数据            实时采集的背景信号 |
| D9           | 1                | 是否包含电流通道                 | 0x0：否 0x1:是                                               |
| D10~D11      | 2                | 包含通道数                       | 数据量包含数据通道数                                         |
| D12~D15      | 4                | 每通道包含点数                   | 每通道数据点数                                               |
| D16          | 1                | 发射帧序号                       | 电法发射帧序号                                               |
| D17~D18      | 2                | 信号触发通道号                   | 用于微震的信号触发时值最大的通道                             |
| D19          | 1                | 激电发射电压                     | **发射电压**            **说明**                  24V            参考通信值约定中的电压**类型**。                  48V                  72V                  96V |
| D20          | 1                | 该帧数据采集时刻激电是否正在采集 | 0x00:否 0x01:是                                              |
| D21          | 1                | 对时模块网络状态                 | 0x00:失联  0x01:正常                                         |
| D22~D29      | 8                | 对时模块时间信息                 | 8字节，到毫秒，当前时间以毫秒为单位自1970年1月1日00:00:00  UTC |
| D30          | 1                | 激励电法发射模式                 | 0x00:单正 0x01:正负正 0x02:M序列                             |
| D31          | 1                | 触发通道数                       |                                                              |

### 监测数据应答帧数据区

* 数据区：电流数据+电压数据
* 电流数据：4字节表示一个电流值，第一个字节最高位为符号位!  总点数为每通道包含点
* 电压数据：4字节表示一个电压值，第一个字节最高位为符号位! 总点数为电法发射采集模式：（包含通道数-1）×每通道包含点数；
* 其余模式：包含通道数*每通道包含点
* 温度数据：2字节表示一个温度值



## （2）数据帧DataFrame

### 数据类型（构建数据帧的原始帧类型）

![image-20250411173017037](D:\notes\笔记Img\image-20250411173017037.png)

| DataFrame类型id：df.classId() | 数据类型                                  |
| ----------------------------- | ----------------------------------------- |
| 1                             | 激电                                      |
| 2                             | 微震事件                                  |
| 3                             | 微震背景（采样间隔2ms，每个通道2500点）   |
| 4                             | 温度数据                                  |
| 5                             | 耦合数据                                  |
| 6                             | 微震全时（采样间隔0.5ms，每个通道5000点） |
|                               |                                           |
| 9                             | 提取                                      |
| 10                            | 偏移                                      |
| 99                            | 再提取                                    |

| 文件头     |            |                                                              |          |                        |
| ---------- | ---------- | ------------------------------------------------------------ | -------- | ---------------------- |
| 位置(字节) | 大小(字节) | 定义                                                         | 数据类型 | 说明                   |
| 0          | 8          | 采样时间                                                     | double   | 时间戳，毫秒           |
| 8          | 1          | 采样数据类型id                                               | uint     | 原始帧类型             |
| 9          | 1          | 是否包含电流通道                                             | uint8_t  | 1:包含； 0:不包含      |
| 10         | 2          | 包含通道数                                                   | uint16_t | DataFrame::setChannels |
| 12         | 4          | 每通道数据点数                                               | uint32_t | DataFrame::setPoints   |
| 16         | 1          | 激电发射帧序号或**微震触发通道号（用于微震的信号触发时值最大的通道）** | uint8_t  |                        |
| 17         | 1          | 激电发射或**微震触发基站ID号**,主要用于多基站                | uint8_t  |                        |
| 18         | 1          | 保留                                                         |          |                        |
| 19         | 4          | 采样间隔                                                     | float    | 毫秒                   |
| 23         | 1          | 激电激发类型id                                               | uint8_t  | 按协议定义             |
| 24         | 1          | 激电发射电压id                                               | uint8_t  |                        |
| 25         | 1          | 该帧数据采集时刻激电是否正在采集                             | uint8_t  | 0x00:否，0x01:是       |
| 26         | 1          | 设备拼接掩码                                                 | uint8_t  | 对应拼接设备ID         |
| ***27***   | ***1***    | ***是否为拼接帧***                                           | uint8_t  | 若是则为1              |
| 28         | 1          | 激电电压模式                                                 | uint8_t  | 0:固定；1:智能         |
| 29         | 4          | 保留                                                         |          |                        |

| 数据区     |                          |                                      |          |                                |
| ---------- | ------------------------ | ------------------------------------ | -------- | ------------------------------ |
| 位置(字节) | 大小(字节)               | 定义                                 | 数据类型 | 说明                           |
| 32         | 通道数x 每通道数据点数x4 | 原始采样数据值按通道、数据点顺序存放 | int      | 含电流通道时，第一道为电流数据 |

* 字节序：小字节序（高位在后，低位在前）
* 协议：指本公司《微震电法并行物理场监测系统采集通信约定》 
* 数据值： int类型的采样原始数据，未乘系数 
* 从系统页面下载数据文件名约定： yyyy_mm_dd_采集数据类型 id_采样时间戳.semt.bin 

## （3）多基站拼帧

* dev_id表示基站数量：dev_id采用mask表示拼接的基站号，uint8_t，从右往左每个bit表示一个基站，只有1号时dev_id=1, 只有2号时dev_id=2，都有时dev_id=3。

* 拼帧（原始帧拼接为数据帧）是采集时后端实时完成：

  只有双基站同时段都有数据帧时才能拼接，此时`dev_id=3`

  只有一个基站有数据时就不拼了，直接保存，`dev_id=1 or 2`

* 若基站1有16个通道，基站2有16个通道，那么双基站时，拼出的数据帧的通道数将为32

# 10. 干涉提取+再提取+偏移

---

> * 实时计算：干涉源提取+再提取+偏移成图。
> * 历史计算：干涉源提取+偏移成图。再提取需要手动点执行。
>
> * 所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
>
> > 若用【背景】原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。（读表到类型变量`hzi::mining_classId`）
> >
> > 若用【全时】原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。

| -                    | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| `getPCO_parm(true)`  | 读取实时计算参数表`e_mining_PCOSignalParm`到`pcoParm`        |
| `setPCOLocParm()`    | 读取参数到`pcoLocParm`，根据日进尺计算回采位置仅用于计算，不入库 |
| `setPCOCalChn()`     | 读取参数到`pcoCalChnParms`                                   |
| `setSignalChnInfo()` | 读取参数到`pcoExtractChnParms`。自相关/互相关。              |

### 库表

| 表名                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | **9类型数据**。提取图数据                                    |
| e_mining_pcodata_frm_info      | **10类型数据。**偏移图数据                                   |
|                                |                                                              |
| e_mining_PCOSignalParm         | **实时计算参数，信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **历史计算参数，信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。`Notch_jobs`是陷波滤波类型，0-奇偶倍，1-奇数倍，2-偶数倍，3-一倍。`notchF`是陷波频率，目前实时计算时陷波频率还是写死50hz。 |
| e_mining_PCOLocParm            | **实时/历史计算，坐标等参数值。回采位置/回采方向/日进尺/回采位置更新日期**等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | 回采位置/回采位置对应时间戳/日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | 当前使用的通道的设备/编号/类型                               |
| e_chns_config_history          | 从中读取通道历史信息参与历史计算                             |
|                                |                                                              |
|                                |                                                              |

## （0）所有用到提取+再提取流程算法的函数汇总

> [!TIP]
>
> 在这里总结一下所有会用到这些流程的函数，方便后续增/改算法时，不会遗漏

| `ms_mining.cpp-handleSignalProcess` | 调用该函数的                                                 |
| ----------------------------------- | ------------------------------------------------------------ |
|                                     | `/handerSignal/:from_time/:to_time/:time_len/:devId`         |
|                                     | `/handerSignalMining/:from_time/:to_time/:time_len/:devId`   |
|                                     | `/handerTunnelSignal/:start_loc/:end_loc/:time_len`          |
|                                     |                                                              |
|                                     | `threadHanleData`                                            |
|                                     | `threadHanleData_tunnel`，这个函数被`handleTimeStamp_tunnel`调用。这个函数被很多地方调用。 |

| `ms_mining.cpp--getPCO_parm()` | -    |
| ------------------------------ | ---- |
|                                |      |
|                                |      |
|                                |      |
|                                |      |

### 道内均衡

代码中所有保存道内均衡参数的类型：

```cpp
//PCOSignalProcess.hpp
struct PCOSignalParm
    
//ms_mining.hpp
struct PCODeAGC
```

| 道内均衡 | 用到的地方                                                   | 函数功能                                                    | 上层调用                                                     |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
|          | `ms_mining.cpp--getPCO_parm()`                               | 从库表读参数                                                |                                                              |
|          | `PCOSignalProcess.cpp--L241`，并行计算函数`ParallelCorrelation::operator()` | 实时计算                                                    | `ms_mining.cpp--handleSignalProcess()`                       |
|          |                                                              |                                                             |                                                              |
|          | `ms_mining.cpp--handleExtSignalData_pianyi()`                | 读取指定时间段内的提取文件（9），生成偏移文件（10）         | 被接口`/handerExtSignalPianYi/:from_time/:to_time`调用。     |
|          | `ms_mining.cpp--parseDeAGC()`                                | `parseDeAGC()`从`methods`中解析json格式的算法参数参与计算。 | 被接口`/handerExtSignal/:samp_time/:typeId`调用。调用`processMethods()`进行再提取计算，写文件到99。`processMethods()`中调用`parseDeAGC()` |
|          | `PCOSignalProcess.cpp--PureCommonOperation::handleSignalData` | ` PureCommonOperation::handleSignalData`执行再提取算法。    | 被接口`/handerExtSignalParm/:samp_time/:typeId`调用。`handerExtSignalParm`，调用`handleExtSignalData`，调用`PureCommonOperation::handleSignalData` |
|          |                                                              |                                                             |                                                              |
|          | `PCOSignalProcess.cpp--L3232，handleDataFrameVec_test()`     | 测试用                                                      | `ms_mining.cpp--handleSignalProcess_test()`                  |
|          |                                                              |                                                             |                                                              |
|          |                                                              |                                                             |                                                              |



## （1）实时代码流程

> [!IMPORTANT]
>
> 实时：自动进行【提取+再提取+偏移】，保存提取文件9，保存偏移文件10，但不保存文件99（历史重算保存）。
>
> * `main.cpp--realTimeCal()`开个线程。
> * `ConnectServer.cpp--realTimeCal()`线程执行函数`while(1)`循环。
> * `ms_mining.cpp--threadHanleData()`循环执行。
>
> * 拼帧：`ms_mining.cpp--mergeMs()`：时间段内的1炮数据，拼成一个帧。多炮数据的多个帧存在`dfvec`里。
>
> * 提取+再提取：`ms_mining.cpp--handleSignalProcess(dfvec, true)`：先读表取计算参数。根据入参flag确定再提取若干操作的标志位，flag==true，则进行再提取；flag==false，不进行再提取。`handleSignalProcess`调用：
>
> > * `ms_miining.cpp--PureCommonOperation::handleDataFrameVec_signal`：并行计算函数，其中包含的操作依次有：【预处理】、【信号加窗】、【相关计算】、【滑动时窗】、【一维频域滤波】、【反褶积】、【一维频域滤波】、【道内均衡】（AGC、指数增益）、【道间均衡】、【反射波提取】，这些操作都有标志位决定是否执行。
> >
> >   结果存于`pOutSignal`。
> >
> > * 计算偏移图数据：`isUseCSP=0`【无CSP道集提取】，其中调用`PureCommonOperation::CalMigration(pOutSignal,pOut_tmp)`，计算偏移图数据。
> >
> >   结果存于`pOut_tmp`。
> >
> > * 保存偏移图数据文件10类型：`saveResult(true)`，传入`true`表示进行异常提取。将`pOut_tmp`中数据保存于10类型文件。入库表`e_mining_pcodata_frm_info`。
> >
> > * 保存提取数据文件9类型：将`pOutSignal`中数据保存为9类型文件。入库表`e_mining_signaldata_frm_info`。
>
> 

### ※拼帧

> [!NOTE]
>
> * `ms_mining.cpp`中`mergeMs()`。
> * `MergeMs`是把指定时间段内的（若干次采样）若干个6/3原始数据文件的数据拼成1个帧。
> * 每个6/3原始数据文件，只包含1次采样时间内的数据。
> * 每个6/3原始数据文件都包含了所有通道1次采样的数据。

```cpp
if (dev_id == 0)
{
    int devId = hzi::sysDevMask;
    //按channels分组，按各组条数降序排列。取1条记录，即channels条数最多。
    auto rslt0 = conn.executeQuery(
        "select channels,count(1) as number from e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?) and dev_id = ? GROUP BY channels ORDER BY "
        "count(1) desc limit 1",
        hzi::mining_classId, fromtime, endtime, devId);
    if (rslt0.next())
    {
        chns0 = rslt0.getInt("channels");   //获取通道数
    }

    auto rslt = conn.executeQuery(
        "SELECT samp_time,channels,ch_pnts, frm_loc FROM e_data_frm_info  "
        " where class_id= ?  AND samp_time > FROM_UNIXTIME(?) "
        "  AND samp_time < FROM_UNIXTIME(?)  AND channels = ?  and dev_id = ? ORDER BY "
        "samp_time ASC",
        hzi::mining_classId, fromtime, endtime, chns0, devId);

    while (rslt.next())
    {
        pnts0 = rslt.getInt("ch_pnts");		//获取1次采样的点个数
        auto pathstr = rslt.getString("frm_loc");	//数据文件路径
        pnts += pnts0;  //[fromtime,endtime]时间段内一个通道的所有点数之和
        pathVector.push_back(pathstr);  //每个数据文件的路径
    }
    if (pnts0 == 0 || pnts == 0 || chns0 == 0)
        return tl::make_unexpected("DataFrame::merge: The data for that time period is empty");
   
    DataFrame newDF(chns0, pnts); // 所有通道在时间段内的所有点，拼一个大的帧，帧数据大小chns0*pnts*4B
    string path = Config::dataRoot + "/";
    for (int i = 0; i < pathVector.size(); i++)
    {
        auto filePath = path + pathVector[i];	//原始数据文件路径
        if (!fs::exists(filePath))
            return tl::make_unexpected("DataFrame::merge: file Path error");
        std::ifstream ifs(filePath);
        auto fileSize = fs::file_size(filePath);
        DataFrame fileDF(chns0, pnts0);	//保存一个数据文件的小帧
        ifs.read(fileDF.upHead.get(), 32); //从数据文件读数据头到fileDF帧
        // ifs.seekg(0);
        ifs.read(fileDF.upData.get(), fileSize - 32);   //从数据文件读数据体到fileDF帧
        ifs.close();
        
        //把fileDF帧中数据拷贝到大的数据帧里
        if (i == 0)	//第一次拷贝时，需要把小帧的头拷贝到大帧的头，改下点数为大帧存的点数
        {
            memcpy(newDF.upHead.get(), fileDF.upHead.get(), 32); 
            newDF.setPoints(pnts); // fileDF在memcpy时把newDF原本的pnts改成了pnts0，这里重新设置回来
        }

        //把每次采样的数据文件中的数据，遍历通道，拷贝到newDF中（外面i循环是数据文件数，ch循环对每个数据文件的通道数）
        for (int ch = 0; ch < chns0; ch++)
        {
            memcpy(newDF.upData.get() + ch * pnts * 4 + i * pnts0 * 4,
                   fileDF.upData.get() + ch * pnts0 * 4, pnts0 * 4);
        }
    }

    //返回拼好的大帧
    return std::move(newDF);
```

### ※提取+再提取

> [!NOTE]
>
> * 函数`handleSignalProcess(dfvec, true)`，传入false只进行提取。传入true时，才会提取+再提取。`dfvec`中存储多炮的数据，即多个拼帧得到的大帧。
>
> * 读表获取参数
>
>   | -                    | 说明                                                  |
>   | -------------------- | ----------------------------------------------------- |
>   | `getPCO_parm(true)`  | 读取实时计算参数表`e_mining_PCOSignalParm`到`pcoParm` |
>   | `setPCOLocParm()`    | 读取参数到`pcoLocParm`                                |
>   | `setPCOCalChn()`     | 读取参数到`pcoCalChnParms`                            |
>   | `setSignalChnInfo()` | 读取参数到`pcoExtractChnParms`。自相关/互相关。       |
>
> * `pOutSignal`用于保存并行计算处理结果。
> * `PureCommonOperation::handleDataFrameVec_signal`并行计算，对每一炮数据开个线程异步计算，依次执行：【加窗，预处理】，【信号加窗】，【滑动时窗】，【相关计算】，【一维滤波】，【反褶积】，【一维滤波】，【道内均衡】，【道间均衡】，【反射波提取】。
> * `pOut_tmp`用于保存偏移计算结果。

```cpp
/*
* 多炮数据处理
* 实时计算（flag=true）：
* 历史重算（flag=false）：只进行干涉源提取，不进行其他计算
*/
string handleSignalProcess(std::vector<DataFrame *> dfVec, bool flag, int dev_id)
{
    auto deltT = dfVec[0]->sampIntvl();//采样间隔
    auto tmStmp = dfVec[0]->sampTime();//采样时间（跟踪一下拼帧后的帧的采样时间是什么含义）
    auto devId = dfVec[0]->devMask();
    float speed_p, speed_s = 0;
    bool is_evenSpeed = 0;
    auto pntss = dfVec[0]->points();
    int useVType = 0; // 默认使用P波偏移，偏移类型（0-P波 ，1-S波 2-PS波)

    PureCommonOperation::PCOLocParm pcoLocParm;
    PureCommonOperation::PCOSignalParm pcoParm;
    bool outType = 0;
    int outSurLineId = 0; // 随采输出测线id 使用测线数量
    int isUseCSP = 0;
    bool ret = getPCO_parm(pcoParm, pcoLocParm, deltT, flag, outType, outSurLineId, isUseCSP, useVType, is_evenSpeed, speed_p, speed_s);

    auto conn = hzi::config.pConnPool->getConnection();

    double dateTime = (double)tmStmp / 1000.0;
    auto coal_z = 0.0;     // 煤层位置
    auto layer_from = 0.0; // 坐标开始位置

    auto rslt12 = conn.executeQuery(
        "SELECT y_min,y_max,z_min,z_max,coal_z,layer_from FROM `e_space` ");
    if (rslt12.next())
    {
        pcoLocParm.m_dYMax = rslt12.getDouble("y_max");
        pcoLocParm.m_dYMin = rslt12.getDouble("y_min");
        pcoLocParm.m_dZMax = rslt12.getDouble("z_max");
        pcoLocParm.m_dZMin = rslt12.getDouble("z_min");
        coal_z = rslt12.getDouble("coal_z");
        layer_from = rslt12.getDouble("layer_from");
    }
    if (!setPCOLocParm(tmStmp, pcoLocParm))
        return "e_mining_PCOLocParm表 数据为空";

    if (!hzi::config.ms_tunnel_listen)
    {
        hzi::tunnel_mining_loc = pcoLocParm.m_locx;
    }

    if (hzi::config.verbose)
        cout << " 回采位置：" << pcoLocParm.m_locx << endl;

    if (pcoLocParm.m_dir == 0)
    {
        pcoLocParm.m_dXMin = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMin = pcoLocParm.m_locx - 100;
        }
        pcoLocParm.m_dXMax = pcoLocParm.m_locx + pcoLocParm.mark_len;
    }
    else
    {
        pcoLocParm.m_dXMax = pcoLocParm.m_locx;
        if (hzi::config.ms_mining_type == 2)
        {
            // 随掘
            pcoLocParm.m_dXMax = pcoLocParm.m_locx + 100;
        }
        pcoLocParm.m_dXMin = pcoLocParm.m_locx - pcoLocParm.mark_len;
    }
    if (hzi::config.ms_interface_type == 0)
    {
        pcoLocParm.m_iZGrdNum = 1;
        pcoLocParm.m_dZMax = 1;
        pcoLocParm.m_dZMin = 0;
        pcoLocParm.m_dZGrdLen = 1;
    }
    if (hzi::config.ms_interface_type == 1)
    {
        pcoLocParm.m_iYGrdNum = 1;
        pcoLocParm.m_dYMax = 1;
        pcoLocParm.m_dYMin = 0;
        pcoLocParm.m_dYGrdLen = 1;
    }

    pcoParm.ms_components = hzi::config.ms_components;
    pcoLocParm.out_type = 1;

    pcoLocParm.interface_type = hzi::config.ms_interface_type;
    pcoLocParm.m_iZGrdNum =
        int((pcoLocParm.m_dZMax - pcoLocParm.m_dZMin) / pcoLocParm.m_dZGrdLen);

    pcoLocParm.m_iXGrdNum =
        int((pcoLocParm.m_dXMax - pcoLocParm.m_dXMin) / pcoLocParm.m_dXGrdLen);
    pcoLocParm.m_iYGrdNum =
        int((pcoLocParm.m_dYMax - pcoLocParm.m_dYMin) / pcoLocParm.m_dYGrdLen);

    vector<PureCommonOperation::PCOCalChn> pcoCalChnParms;
    // 先找出所有通道，进行分量和测线配置，然后删除不需要的通道  devId
    setPCOCalChn(pcoCalChnParms, hzi::sysDevMask, tmStmp, flag);

    for (int i = 0; i < 3; i++)
    {
        pcoParm.dataChnNO[i] = pcoParm.chnno;
    }

    if (pcoParm.ms_components > 1)
    {
        // 多分量 给pcoCalChnParms 分配分量属性
        auto rslt_comp = conn.executeQuery(" SELECT * FROM `e_comp_info` ");
        while (rslt_comp.next())
        {
            auto id = rslt_comp.getInt("id");
            auto enb = rslt_comp.getInt("enb"); // 输出分量结果
            auto chnsList = rslt_comp.getString("chnsList");
            auto chn_no = rslt_comp.getInt("chn_no");
            auto chn_no_history = rslt_comp.getInt("chn_no_history");
            auto is_out = rslt_comp.getInt("is_out");
            if (is_out)
                pcoLocParm.out_type = id;
            if (flag)
            {
                // 实时计算
                pcoParm.dataChnNO[id - 1] = chn_no;
            }
            else
            {
                // 历史计算
                pcoParm.dataChnNO[id - 1] = chn_no_history;
            }
            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].flag = id; // 分量id
                    pcoCalChnParms[num - 1].enb = (pcoCalChnParms[num - 1].enb & enb);
                    //  cout<<" 通道号："<<num<<" 分量："<<id<<" enb = "<<pcoCalChnParms[num-1].enb <<endl;
                }
            }
        }
    }

    // auto surveyLineCount = 1;//测线数量 1-机载式，2-双巷式，3-混合式
    // systemeType = 0 系统类型：0-双巷式，1-机载式，2-组合式'
    int lineArry[3] = {0};
    //  int mining_singalCount = 0;
    if (hzi::config.ms_mining_type == 1)
    {
        auto rslt_surveyLine = conn.executeQuery(" SELECT * FROM `e_mining_surveyLine` where type_id = 0 ");
        while (rslt_surveyLine.next())
        {
            auto id = rslt_surveyLine.getInt("id");
            // surveyLineCount = (id > surveyLineCount) ? id : surveyLineCount;
            auto chnsList = rslt_surveyLine.getString("chnsList");

            // std::vector<int> result
            auto chns_List = parseString(chnsList);
            lineArry[id - 1] = chns_List.size();
            for (int num : chns_List)
            {
                if (num <= pcoCalChnParms.size())
                {
                    pcoCalChnParms[num - 1].id = id; //测线id
                    // cout<<" 通道号："<<num<<" 测线："<<id<<endl;
                }
            }
        }
        // mining_singalCount = getSignalChnCount(pcoParm.systemeType ,pcoParm.ImageType,lineArry[0],lineArry[1],lineArry[2],hzi::config.ms_components);

        for (int i = 0; i < 3; i++)
        {
            if (dev_id != 0)
            {
                if (lineArry[i] != 0 && dev_id == i + 1)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
            else
            {
                if (lineArry[i] != 0)
                    pcoParm.lineCountVec.push_back(lineArry[i]);
            }
        }
    }

    //随掘
    if (hzi::config.ms_mining_type == 2)
    {
        //  pcoLocParm.hasFouce = true;
        //  pcoLocParm.is_exclude_directWaves = true;
        if (pcoParm.ms_components > 1)
        {
            auto chnno_tmp = pcoParm.dataChnNO[0];
            pcoLocParm.fx = pcoCalChnParms[chnno_tmp - 1].x;
            pcoLocParm.fy = pcoCalChnParms[chnno_tmp - 1].y;
            pcoLocParm.fz = pcoCalChnParms[chnno_tmp - 1].z;
        }
        else
        {
            pcoLocParm.fx = pcoCalChnParms[pcoParm.chnno - 1].x;
            pcoLocParm.fy = pcoCalChnParms[pcoParm.chnno - 1].y;
            pcoLocParm.fz = pcoCalChnParms[pcoParm.chnno - 1].z;
        }
    }

    if (dev_id != 0)
    {
        // 指定测线数据处理 取对应基站的坐标 默认基站号与测线号对应
        pcoCalChnParms.erase(
            std::remove_if(
                pcoCalChnParms.begin(),
                pcoCalChnParms.end(),
                [dev_id](const PureCommonOperation::PCOCalChn &elem)
                {
                    return elem.id != dev_id;
                }),
            pcoCalChnParms.end());
    }
    // 在此区分随掘和随采的信号提取通道数量 随采根据测线来决定

    int vecSize = dfVec.size();//炮数
    auto chns = dfVec[0]->channels();//

    PureCommonOperation::PCOExtractChn pcoExtractChnParms;
    setSignalChnInfo(pcoExtractChnParms, pcoCalChnParms, pcoParm, chns);
    // cout<<" count = "<<pcoExtractChnParms.count
    //     <<" , chnno = "<<pcoExtractChnParms.chnNoVec.size()
    //     <<" , coechnno = "<<pcoExtractChnParms.coeChnNoVec.size()<<",chns = "<<chns<<endl;

    auto valChnns = pcoExtractChnParms.count;
    // auto valChnns =(hzi::config.ms_mining_type == 1) ? mining_singalCount : chns;
    auto valNum = valChnns * vecSize;//通道数*炮数
    // cout<<" valNum = "<<valNum<<endl;
    auto iGrdNum =
        pcoLocParm.m_iXGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    pcoParm.mining_fx = pcoLocParm.fx;
    pcoParm.mining_fy = pcoLocParm.fy;
    pcoParm.mining_fz = pcoLocParm.fz;
    pcoParm.chns_Count = valChnns;
    pcoParm.chns = chns;
    // // 历史重算 只进行干涉源提取
    // if (!flag)
    // {
    //     pcoParm.isCut = 0;
    //     pcoParm.isCalRandon = false;
    //     pcoParm.isSpikeDeconvolution = false;
    //     pcoParm.deAGCtype = 0;
    //     isUseCSP = 0;
    //     pcoParm.interChnAmpEqual_type = 0;
    // }
    // 采煤机定位 随采采煤机定位
    int sumCount_jh = 170;
    float dis = 1.75;
    if (hzi::config.ms_mining_type == 1 && hzi::start_jh != 0 && hzi::end_jh != 0)
    {
        //  float dis_y = (pcoLocParm.m_dYMax - pcoLocParm.m_dYMin)/100;
        float y = pcoLocParm.m_dYMin + hzi::start_jh * dis;
        float dis_y = (hzi::end_jh - hzi::start_jh) * dis / vecSize;

        pcoLocParm.fx = pcoLocParm.m_locx;
        pcoLocParm.fy = y;
        pcoLocParm.fz = pcoLocParm.fz;
        pcoLocParm.dis_y = dis_y;
    }
    // cout<<"size = "<<dfVec.size()<<" , 通道："<<dfVec[0]->channels()<<", 时间戳"<<std::to_string(dfVec[0]->sampTime())
    //     <<"震源位置："<<pcoLocParm.fx<<" ,"<<pcoLocParm.fy<<", 间隔："<<pcoLocParm.dis_y<<endl;;


    /*
    * 对每炮数据进行处理：加窗，预处理，滑动时窗，相关，一维滤波，反褶积，道内均衡，道间均衡，反射波提取
    */
    float **pOutSignal = new float *[valChnns * vecSize];
    for (int dex = 0; dex < vecSize; dex++)
    {
        for (int ch = 0; ch < valChnns; ++ch)
        {
            pOutSignal[ch + dex * valChnns] = new float[pcoParm.outLen];
            memset(pOutSignal[ch + dex * valChnns], 0,
                   sizeof(float) * pcoParm.outLen);
        }
    }

    if (!flag)// 历史重算 只进行干涉源提取
    {
        pcoParm.isCut = 0;//无滤波
        pcoParm.isCalRandon = false;//无反射波提取
        pcoParm.isSpikeDeconvolution = false;//无反褶积
        pcoParm.deAGCtype = 0;//无道内均衡
        isUseCSP = 0;// 无CSP道集提取
        pcoParm.interChnAmpEqual_type = 0;//无道间均衡
    }
    PureCommonOperation::handleDataFrameVec_signal(
        std::move(dfVec), pcoParm, &pcoCalChnParms[0], pOutSignal, pcoExtractChnParms);
    logInfo(" handleDataFrameVec_signal  endl ");
    //上面：结果存于pOutSignal：实时--提取+再提取，历史--提取


    bool isSavePianyi = true;
    // CSP道集提取 已经生成了偏移图，不用进行偏移了
    if (isUseCSP != 0)
    {
        // 随采 散射 CSP道集提取
        isSavePianyi = false;
        if (hzi::config.ms_mining_type == 1 && pcoParm.ImageType == 0)
        {
            PureCommonOperation::CSPTraceParm cspParm;
            cspParm.nComponentCount = hzi::config.ms_components;
            cspParm.iCalTraces = pcoExtractChnParms.count;
            cspParm.nSamplePoints = pcoParm.outLen - pcoParm.coefBegPt;
            cspParm.fSampleInterval = deltT;
            cspParm.nAdvanPoints = 0;
            cspParm.fPV = speed_p;
            cspParm.fSV = speed_s;
            int surLineNum = (pcoParm.systemeType == 0) ? 2 : ((pcoParm.systemeType == 1) ? 1 : 3);

            float **pSignal = new float *[valChnns * vecSize];
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < valChnns; ++ch)
                {
                    // pSignal[ch + dex * valChnns] = new float[cspParm.nSamplePoints];
                    pSignal[ch + dex * valChnns] = new float[static_cast<int>(cspParm.nSamplePoints)];
                    for (int i = 0; i < cspParm.nSamplePoints; i++)
                    {
                        pSignal[ch + dex * valChnns][i] = pOutSignal[ch + dex * valChnns][i + pcoParm.coefBegPt];
                    }
                }
            }

            getCSPTrace(tmStmp, pSignal, pcoCalChnParms, cspParm, pcoLocParm,
                        pcoExtractChnParms, surLineNum);
        }
    }
    else
    {
        // 三分量需要叠加时使用
        //  float* pOut = new float[iGrdNum];
        //  memset(pOut, 0, sizeof(float) * iGrdNum);
        // 多分量分别设置
        for (int com = 0; com < pcoParm.ms_components; com++)
        {

            auto pretime = pcoParm.coefBegPt;

            pcoLocParm.is_evenspeed = is_evenSpeed;

            float *pOut_tmp = new float[iGrdNum];
            memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

            if (useVType < 2)//P波偏移或S波偏移
            {
                // float* pOut_tmp = new float[iGrdNum];
                // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);

                float *pSpeedBtr = new float[iGrdNum];
                memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                for (int i = 0; i < iGrdNum; i++)
                {
                    if (useVType == 0)
                    {
                        pSpeedBtr[i] = speed_p;
                    }
                    else
                    {
                        pSpeedBtr[i] = speed_s;
                    }
                }
                getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, useVType, speed_p, speed_s,
                             coal_z, layer_from, is_evenSpeed);

                auto pretime2 = pretime * deltT;
                if (hzi::config.ms_mining_type == 1)//随采
                {
                    if (pcoParm.ImageType == 2)
                    {
                        PureCommonOperation::CalMigration_mining(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                            com + 1, pcoExtractChnParms, outSurLineId);
                    }
                    else
                    {
                        isSavePianyi = false;
                    }
                }
                else//随掘
                {
                    PureCommonOperation::CalMigration(
                        pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                        pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm, pcoParm.ampType,
                        com + 1);
                }

                if (hzi::config.verbose)
                {
                    cout << " CalMigration endl " << endl;
                }
            }
            else if (useVType == 2)//PS波偏移
            {
                for (int type = 0; type < useVType; type++)
                {
                    // float* pOut_tmp = new float[iGrdNum];
                    // memset(pOut_tmp, 0, sizeof(float) * iGrdNum);
                    float *pSpeedBtr = new float[iGrdNum];
                    memset(pSpeedBtr, 0, sizeof(float) * iGrdNum);
                    for (int i = 0; i < iGrdNum; i++)
                    {
                        if (type == 0)
                        {
                            pSpeedBtr[i] = speed_p;
                        }
                        else
                        {
                            pSpeedBtr[i] = speed_s;
                        }
                    }

                    getSpeedArry(iGrdNum, pSpeedBtr, pcoLocParm, type, speed_p, speed_s,
                                 coal_z, layer_from, is_evenSpeed);
                    auto pretime2 = pretime * deltT;
                    if (hzi::config.ms_mining_type == 1)
                    {
                        if (pcoParm.ImageType == 2)
                        {
                            PureCommonOperation::CalMigration_mining(
                                pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                                pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                                pcoParm.ampType, com + 1, pcoExtractChnParms, outSurLineId);
                        }
                        else
                        {
                            isSavePianyi = false;
                        }
                    }
                    else
                    {
                        //随掘
                        PureCommonOperation::CalMigration(
                            pOutSignal, pOut_tmp, &pcoCalChnParms[0], chns, vecSize, deltT,
                            pcoParm.outLen, pretime2, pSpeedBtr, &pcoLocParm,
                            pcoParm.ampType, com + 1);
                    }
                }
            }
            //上面：pOutSignal中结果经过偏移计算，结果存于pOut_tmp

            //保存偏移图，pOut_tmp
            bool is_save = true;//true表示进行异常提取，false表示不进行异常提取
            if (isSavePianyi)
                bool ret = saveResult(tmStmp, devId, iGrdNum, pcoLocParm, pOut_tmp, com, is_save, outType);
        }
    }

    // 写9类型文件
    if (hzi::config.ms_miningSignal)
    {
        // auto pretime = 0;
        unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
        char *pHead2 = pHeadData2.get();
        *(double *)(pHead2) = (double)tmStmp;
        // 19 代表随采，9是随掘
        auto classId2 = 9;
        // auto classId2 = (hzi::config.ms_mining_type == 1) ? 19 : 9;
        *(uint8_t *)(pHead2 + 8) = classId2;
        *(float *)(pHead2 + 9) = deltT;
        *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
        *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
        *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
        *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
        *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
        if (hzi::config.ms_mining_type == 1)
        {
            *(uint8_t *)(pHead2 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
            *(uint8_t *)(pHead2 + 29) = pcoParm.ImageType;   //'随采成像方式:0-散射，1-透射，2-爆炸成像'
        }
        auto conn21 = hzi::config.pConnPool->getConnection();
        conn21.execute(
            "INSERT INTO "
            "e_mining_signaldata_frm_info "
            "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
            "loc,fx,fy,fz,dis)"
            "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
            " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
            "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
            (uint8_t)devId,  // dev_id
            tmStmp / 1000.0, // samp_time
            classId2,        // class_id
            deltT,           // curt_ch
            valNum,          // channels
            vecSize,
            pcoParm.outLen, // ch_pnts
            (relLocFromTime(tmStmp) / std::to_string(classId2) /
             std::to_string(tmStmp))
            .c_str(), // frm_loc
            pcoLocParm.fx,
            pcoLocParm.fy,
            pcoLocParm.fz,
            pcoLocParm.dis_y);

        fs::path outSignalfileName(hzi::config.dataRoot);

        outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
            std::to_string(tmStmp);
        try
        {
            auto dir = outSignalfileName.parent_path();
            if (!fs::exists(dir))
            {
                fs::create_directories(dir);
            }
            std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
            ofs_Signal.write(pHead2, 32);
            for (int dex = 0; dex < vecSize; dex++)
            {
                for (int ch = 0; ch < valChnns; ++ch)
                {
                    int32_t *p32Signal = (int32_t *)pOutSignal[ch + dex * valChnns];
                    // if (!pcoCalChnParms[ch].enb)
                    //     continue;
                    ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
                }
            }
            ofs_Signal.close();
        }
        catch (std::exception &e)
        {
            string msg("error while writing to file:");
            msg += outSignalfileName.string();
            msg += ":";
            msg += e.what();
            if (hzi::config.verbose)
                cout << "msg = " << msg << endl;
            debugErr(msg);
            return "error";
        };
    }

    return std::to_string(tmStmp);
}
```

#### 加窗+预处理

![image-20250429111239334](D:\notes\笔记Img\image-202504291112393341)

* 加窗

  

* 预处理

#### 相关计算

对1炮数据：

* 取通道号，以及该通道号对应的因子道号，将因子道数据暂存到`coefData`。

  index遍历所有因子道（遍历通道号更好吧？），同一个index对应的某个通道号和其使用的因子道号。

  ![image-20250429140811344](D:\notes\笔记Img\image-202504291408113443)

##### 滑动时窗

若`pcoParm.isUseSlideWn==true`，则进行滑动时窗后，再相关计算。

否则直接相关计算。

`pcoParm.outLen`为输出点数。

**这1通道的相关计算结果在`tmpResult`中。**

再拷贝到到`tmpOut`中暂存供后续计算，`tmpOut`为记录了所有炮数的所有通道的计算结果。

![image-20250429141332632](D:\notes\笔记Img\image-202504291413326325)

![image-20250429141212378](D:\notes\笔记Img\image-202504291412123784)

![image-20250429141437245](D:\notes\笔记Img\image-202504291414372455)

![image-20250429142151631](D:\notes\笔记Img\image-202504291421516316)

##### 相关









#### 一维滤波

![image-20250429143704862](D:\notes\笔记Img\image-20250429143704862611)

遍历通道。

`pcoParm.isCut`为0-不滤波，1-时域滤波，2-频域滤波。

对`tmp_out`中暂存相关结果进行计算，`tmp_out[ch+dex*chns_Count]`中`ch+dex*chns_Count`为当前炮数的当前通道。

`Filter1dFD`进行频域滤波，`pcoParm.isStop`：false带通滤波，true带阻滤波。

`pcoParm.isNotchCut`是否进行陷波，调用`NotchFilter1dFD`陷波滤波。

* 频域滤波

  

* 带通滤波/带阻滤波

#### 陷波

* `getPCO_parm`从库表取参数时，`pcoParm.notchF`为陷波频率，从表`e_mining_PCOSignalParm`和`e_mining_PCOSignalParm_history`中读取。**`ms_mining.cpp-2066行`和`ms_mining.cpp-3215行`**，对于陷波频率的处理修改了，之前库表里存的是【50n】字符串，现在改为该字段直接存数值。至于50可以做奇偶倍，125不做奇偶倍只做一倍，由用户自己决定。

* 测试方法：只保留陷波，陷波带宽设定20。频域滤波，低截频：1，高截频：500；道内均衡：无；反褶积：无；反射波提取：无。点击执行。

  ![image-20250520163105526](D:\notes\笔记Img\image-20250520163105526.png)

```cpp
/*
	* 陷波
	* Notch_jobs ：陷波时剔除50hz的奇偶倍数：0-50hz的整数倍，0-奇偶倍（整数倍）1-奇数倍 2-偶数倍 3-一倍
	* NotchWn ：陷波时剔除范围宽度（陷波带宽）
	* int NotchType :（陷波修正方法）处理类型，0-剔除赋值0，1-线性差值
	*/
void NotchFilter1dFD(float* pData, int dataLen, float deltT, int Notch_jobs, float NotchWn, int NotchType, int NotchFreq) 
{
    if (pData == nullptr || dataLen < 1) {
        return;
    }

    float smpFreq_cy = 1000.0f / deltT;  // 采样频率
    int transPt = GetNextPower2(dataLen);
    float smpFreq = smpFreq_cy / transPt;
    // int NotchFreq = 50;  // 初始陷波频率
    int notchEdgePt = static_cast<int>(NotchWn / smpFreq);

    std::unique_ptr<float[]> pRe(new float[transPt]());
    std::unique_ptr<float[]> pIm(new float[transPt]());

    std::copy(pData, pData + dataLen, pRe.get());
    DataFFT(pRe.get(), pIm.get(), transPt, true);

    std::vector<float> pCoef_notch(2 * notchEdgePt + 1);
    GenWindowSeries(pCoef_notch.data(), pCoef_notch.size(), WFF_HAMMING);

    for (int multiplier = 1; NotchFreq * multiplier < smpFreq_cy / 2; ++multiplier) {
        bool applyNotch = (Notch_jobs == 0) ||
            (Notch_jobs == 1 && multiplier % 2 == 1) || 
            (Notch_jobs == 2 && multiplier % 2 == 0) ||
            (Notch_jobs == 3 && multiplier == 1);
        if (!applyNotch) continue;

        int notchIdx = static_cast<int>(NotchFreq * multiplier / smpFreq);
        for (int pt = -notchEdgePt; pt <= notchEdgePt; ++pt) {
            int idx = std::clamp(notchIdx + pt, 0, transPt / 2);
            if (NotchType == 0) {  // 删除频率成分
                pRe[idx] = 0;
                pIm[idx] = 0;
            } else if (NotchType == 1) {  // 插值
                pRe[idx] *= pCoef_notch[notchEdgePt + pt];
                pIm[idx] *= pCoef_notch[notchEdgePt + pt];
            }
        }
    }

    for (int ipt = transPt / 2 + 1; ipt < transPt; ++ipt) {
        pRe[ipt] = pRe[transPt - ipt];
        pIm[ipt] = -pIm[transPt - ipt];
    }

    DataFFT(pRe.get(), pIm.get(), transPt, false);
    std::copy(pRe.get(), pRe.get() + dataLen, pData);
}
```



#### 反褶积

![image-20250429155438319](D:\notes\笔记Img\image-2025042915543831971)

若启用滤波，则反褶积后，会再次进行滤波，且写死为带通滤波。

#### 道内均衡

* 指数增益：

  ![image-20250520163549425](D:\notes\笔记Img\image-20250520163549425.png)

  测试方法：选取提取图某个时间点（横坐标），查看所有通道的幅值，记录增益前的幅值。然后执行增益，再增益后的图中，相同时间点查看所有通道的幅值。比较点的幅值增大是不是符合`pData[i] *= expf(alpha * (i - ptBegId) * deltT_s)`关系。

  ![image-20250520164943164](D:\notes\笔记Img\image-20250520164943164.png)

  ![image-20250520165008364](D:\notes\笔记Img\image-20250520165008364.png)

#### 道间均衡

![image-20250429155753889](D:\notes\笔记Img\image-2025042915575388981)

#### 反射波提取

![image-20250429155950576](D:\notes\笔记Img\image-2025042915595057691)

计算结果存在`vtOutPut`中，`pcoParm.bNegtiveV`为提取类型：正速度/负速度。

![image-20250429164256173](D:\notes\笔记Img\image-202504291642561731)

把计算结果从`vtOutPut`拷贝到`tmp_out`（按照通道）

#### 自相关谱图

* 原理：

  

```cpp
cout<<"11111"<<endl;
        /*
        *   自相关谱图：时域+自相关+正fft
        */
        bool generateSelfCorrSpectrum = true;//是否生成自相关谱图
        const int pOutSignalSize = valChnns * vecSize;
        auto myDeleter = [pOutSignalSize](float** ptr)
        {
            for(int chIndex=0;chIndex<pOutSignalSize;chIndex++)
            {
                delete[] ptr[chIndex];
            }
            delete[] ptr;
        };
        unique_ptr<float*[], decltype(myDeleter)> pOutSelfCorrSpectrum(new float*[pOutSignalSize], myDeleter);
        for(int chIndex=0;chIndex<pOutSignalSize;chIndex++)
        {
            pOutSelfCorrSpectrum[chIndex] = new float[pcoParm.outLen];
            memset(pOutSelfCorrSpectrum[chIndex], 0, sizeof(float)*pcoParm.outLen);
        }

       
        // if(generateSelfCorrSpectrum && pcoParm.extractMethod == 0 && pcoParm.CorrType == 0) //时域+自相关：干涉谱图，11类型
        if(false)
        {
            cout<<"22222"<<endl;
            //对时域自相关信号执行fft
            unique_ptr<float[]> pChDataR = make_unique<float[]>(pcoParm.outLen);//暂存一个通道的数据
            unique_ptr<float[]> pChDataI = make_unique<float[]>(pcoParm.outLen);

            for(int dex=0;dex<vecSize;dex++)
            {
                cout<<"vecsize="<<dex<<endl;

                for(int ch=0;ch<valChnns;ch++)
                {
                    cout<<"ch="<<ch<<endl;

                    memset(pChDataR.get(), 0, sizeof(float)*pcoParm.outLen);
                    memset(pChDataI.get(), 0, sizeof(float)*pcoParm.outLen);
                    memcpy(pChDataR.get(), pOutSignal[ch + dex*valChnns], sizeof(float)*pcoParm.outLen);
                    PureCommonOperation::DataFFT(pChDataR.get(), pChDataI.get(), pcoParm.outLen, true);
                    for(int pt=0;pt<pcoParm.outLen;pt++)
                    {
                        // float frequencyPt = pt / deltT * pcoParm.outLen;  //横轴-频率：k*采样频率/采样点数
                        float AmplitudePt = sqrt(safePow(pChDataR[pt], 2) + safePow(pChDataI[pt], 2));//纵轴-幅值:实部虚部平方和的平方根
                        pOutSelfCorrSpectrum[ch+dex*valChnns][pt] = AmplitudePt;
                    }
                }
            }

            
            // 保存自相关谱图
            //  构造11文件头
            classId2 = 11;
            *(uint8_t*)(pHead2 + 8) = classId2;    //同类型9相比，文件头除了classId不同其他均相同

            auto conn21 = hzi::config.pConnPool->getConnection();
            conn21.execute(
                "INSERT INTO "
                "e_mining_selfcorrdata_frm_info "
                "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
                "loc,fx,fy,fz,dis)"
                "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
                " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
                "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
                (uint8_t)devId,  // dev_id
                tmStmp / 1000.0, // samp_time
                classId2,        // class_id
                deltT,           // curt_ch
                valNum,          // channels
                vecSize,
                pcoParm.outLen, // ch_pnts
                (relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp)).c_str(), // frm_loc
                pcoLocParm.fx,
                pcoLocParm.fy,
                pcoLocParm.fz,
                pcoLocParm.dis_y);

            cout<<"33333"<<endl;

            fs::path outClassId11FileName(hzi::config.dataRoot);
            outClassId11FileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                                 std::to_string(tmStmp);
            try
            {
                auto dir = outClassId11FileName.parent_path();
                if (!fs::exists(dir))
                {
                    fs::create_directories(dir);
                }
                std::ofstream ofs_Signal(outClassId11FileName, std::ofstream::binary);
                ofs_Signal.write(pHead2, 32);
                for (int dex = 0; dex < vecSize; dex++)
                {
                    for (int ch = 0; ch < valChnns; ++ch)
                    {
                        // if (!pcoCalChnParms[ch].enb)
                        //     continue;

                        int32_t* p32SelfCorrSpectrumEachChn = reinterpret_cast<int32_t*>(pOutSelfCorrSpectrum[ch+dex*valChnns]);
                        ofs_Signal.write((char*)p32SelfCorrSpectrumEachChn, pcoParm.outLen * 4);
                    }
                }
                ofs_Signal.close();
                cout<<"44444"<<endl;
            }
            catch (std::exception &e)
            {
                string msg("error while writing to file:");
                msg += outClassId11FileName.string();
                msg += ":";
                msg += e.what();
                if (hzi::config.verbose)
                    cout << "msg = " << msg << endl;
                debugErr(msg);
                return "error";
            };
        }
```

### ※计算偏移图数据

>  [!NOTE]
>
> * `PureCommonOperation::CalMigration`

#### 





### ※保存10数据类型

> [!NOTE]
>
> * 函数`saveResult()`中保存
>
> * 10的数据存在`pOut`。
>
>   为了`outType`可指定【偏移图】或【反射界面输出】，调用`PureCommonOperation::ReflactPlane`，进行反射提取。`pOut`中数据经过反射波提取，数据存于`pOut_2`。
>
> * 异常提取：通过fg判断是否进行异常提取。调用函数`saveLine()`
>
> * 截取偏移图数据，将`pOut`数据处理后存于`pOut_0`
>
> * 插入库表，保存偏移图数据文件路径
>
> * 调用`ofstream::write()`写入数据，默认的打开模式是 `std::ios::out`，它会清空文件内容并从头开始写入。
>
>   > - 如果文件 `fileName` 已经存在，文件的内容会被清空。
>   > - 如果文件不存在，会创建一个新文件。
>
> * 调用`writeSvg(pOut_0)`保存svg文件（配置文件）

```cpp
/*
* 保存偏移图的10类型数据文件
* fg：是否是实时计算，历史计算异常不提取结果。从偏移数据，提取异常调用函数saveLine()
* typeId：用于分量类型 0-X 1-Y 2-Z
* outType：输出类型，0-偏移图 1-反射界面输出
*/
bool saveResult(uint64_t tmStmp,
                int devId,
                int iGrdNum,
                PureCommonOperation::PCOLocParm pcoLocParm,
                float *&pOut,
                int typeId,
                bool fg, bool outType)
{
    bool flag = false;

    auto conn = hzi::config.pConnPool->getConnection();

    if (hzi::config.ms_mining_type == 2)
    { 
        // hzi::config.ms_mining_type == 2
        // 异常提取

        std::unique_ptr<float[]> pOut_2(new float[iGrdNum]);
        memset(pOut_2.get(), 0, sizeof(float) * iGrdNum);

        std::vector<PureCommonOperation::ELINE> lineVec;
        int flNum = 1;
        PureCommonOperation::EXTRACTPARA m_extractPara;
        m_extractPara.Reset();

        auto rslt_ext = conn.executeQuery(
            "SELECT * FROM e_tunnel_extractPara WHERE is_init = 0");
        if (!rslt_ext)
        {
            std::cerr << "Query returned no results." << std::endl;
            //  return;
        }
        if (rslt_ext.next())
        {
            m_extractPara.fAmpleScale = rslt_ext.getDouble("fAmpleScale");
            m_extractPara.fOverlapScale = rslt_ext.getDouble("fOverlapScale");
            m_extractPara.iMaxPlanes = rslt_ext.getInt("iMaxPlanes");
            m_extractPara.bExtAmple = rslt_ext.getInt("bExtAmple");
            m_extractPara.bExtNum = rslt_ext.getInt("bExtNum");
            m_extractPara.iAmpExtType = rslt_ext.getInt("iAmpExtType");
            m_extractPara.iNumExtType = rslt_ext.getInt("iNumExtType");
            m_extractPara.inputMaxEng = rslt_ext.getDouble("inputMaxEng");
        }

        //pOut中数据经过反射波提取，数据存于pOut_2
        PureCommonOperation::ReflactPlane(pOut, pOut_2.get(), flNum, &pcoLocParm,
                                          m_extractPara, &lineVec);

        //若成图：反射界面图，则把pOut_2拷贝到pOut。
        //若成图：偏移图，不拷贝，直接用pOut中数据进行后续写文件操作。
        if (outType)
        {
            memcpy(pOut, pOut_2.get(), sizeof(float) * iGrdNum);
        }

        float gLen = (pcoLocParm.m_dYGrdLen > pcoLocParm.m_dZGrdLen)
                         ? pcoLocParm.m_dYGrdLen
                         : pcoLocParm.m_dZGrdLen;
        if (hzi::config.verbose)
        {
            cout << "当前回采位置： " << pcoLocParm.m_locx
                 << " Y/Z 精度：" << gLen << ";异常提取结果：" << endl;
            for (int i = 0; i < lineVec.size(); i++)
            {
                // 先按照X Y 面计算

                cout << "   第 " << i + 1 << "个：起点坐标：(" << lineVec[i].fBeginTime << ","
                     << lineVec[i].nBeginTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fBeginTime << " ; " << lineVec[i].fXPos << " ; "
                     << "终点坐标:(" << lineVec[i].fEndTime << ","
                     << lineVec[i].nEndTrace * gLen + pcoLocParm.m_dZMin
                     << "); 实际位置：" << pcoLocParm.m_locx + lineVec[i].fEndTime << "; " << lineVec[i].fEndTime << endl;
            }
        }

        //异常提取
        if (fg)
        {
            saveLine(tmStmp, lineVec, pcoLocParm, fg);
        }
    }

    int XGrdNum =
        int(pcoLocParm.mark_len / pcoLocParm.m_dXGrdLen);
    int YGrdNum = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_iZGrdNum : pcoLocParm.m_iYGrdNum;

    auto iGrdNum_out =
        XGrdNum * pcoLocParm.m_iYGrdNum * pcoLocParm.m_iZGrdNum;

    std::unique_ptr<float[]> pOut_0(new float[iGrdNum_out]);
    memset(pOut_0.get(), 0, sizeof(float) * iGrdNum_out);
    cout << "pcoLocParm.m_dir = " << pcoLocParm.m_dir << ",XGrdNum = " << XGrdNum << " pcoLocParm.m_iXGrdNum = " << pcoLocParm.m_iXGrdNum
         << ",YGrdNum = " << YGrdNum << endl;
    // 截取偏移图数据
    for (int j = 0; j < YGrdNum; ++j)
    {
        for (int k = 0; k < pcoLocParm.m_iXGrdNum; ++k)
        {
            if (pcoLocParm.m_dir == 0)
            {
                // 取后面的数据
                if (k >= pcoLocParm.m_iXGrdNum - XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k - pcoLocParm.m_iXGrdNum + XGrdNum;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
            else
            {
                if (k < XGrdNum)
                {
                    auto iCurGrdPos1 = j * pcoLocParm.m_iXGrdNum + k;
                    auto iCurGrdPos2 = j * XGrdNum + k;
                    pOut_0[iCurGrdPos2] = pOut[iCurGrdPos1];
                }
            }
        }
    }
    float minpOut = *std::min_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    float maxpOut = *std::max_element(pOut_0.get(), pOut_0.get() + iGrdNum_out);
    // 有异常的位置拉起来能量
    cout << " XGrdNum = " << XGrdNum << " m_iYGrdNum = " << pcoLocParm.m_iYGrdNum << " pcoLocParm.m_iZGrdNum = " << pcoLocParm.m_iZGrdNum << endl;

    float dX = pcoLocParm.m_dXGrdLen;
    float dY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZGrdLen : pcoLocParm.m_dYGrdLen;
    float minY = (pcoLocParm.m_iYGrdNum == 1) ? pcoLocParm.m_dZMin : pcoLocParm.m_dYMin;
    //  cout<<"dX =  "<<dX<<",dy= "<<dY<<",minY = "<<minY<<endl;

    int32_t *p32 = (int32_t *)pOut_0.get();
    unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
    char *pHead = pHeadData.get();
    *(double *)(pHead) = (double)tmStmp;
    auto classId = *(uint8_t *)(pHead + 8) = 10;//classid置10，偏移图
    *(uint8_t *)(pHead + 9) = devId;
    *(uint16_t *)(pHead + 10) = XGrdNum;
    // *(uint16_t*)(pHead + 10) = pcoLocParm.m_iXGrdNum;
    *(uint16_t *)(pHead + 12) = pcoLocParm.m_iYGrdNum;
    *(uint16_t *)(pHead + 14) = pcoLocParm.m_iZGrdNum;
    *(int32_t *)(pHead + 16) = *((int32_t *)&minpOut);
    *(int32_t *)(pHead + 20) = *((int32_t *)&maxpOut);
    *(int32_t *)(pHead + 24) = *((int32_t *)&dX);

    // auto conn3 = hzi::config.pConnPool->getConnection();
    
    
    /*
    * 插入库表，保存偏移图数据文件路径
    */
    conn.execute(
        "INSERT INTO "
        "e_mining_pcodata_frm_info "
        "(dev_id,samp_time,class_id,XGrdNum,YGrdNum,ZGrdNum,frm_loc)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE XGrdNum= values(XGrdNum),YGrdNum= "
        "values(YGrdNum)",
        (uint8_t)devId,        // dev_id
        tmStmp / 1000.0,       // samp_time
        classId,               // class_id
        XGrdNum,               // curt_ch  pcoLocParm.m_iXGrdNum XGrdNum
        pcoLocParm.m_iYGrdNum, // channels
        pcoLocParm.m_iZGrdNum, // ch_pnts
        (relLocFromTime(tmStmp) / std::to_string(classId) /
         std::to_string(tmStmp))
            .c_str() // frm_loc
    );

    
    /*
    * 写到文件
    */
    auto classId2 = (typeId == 0) ? 10 : (100 + typeId);//单分量文件名类型写10，多分量写100+typeId

    //10类型文件文件名
    fs::path fileName(hzi::config.dataRoot);
    fileName /= relLocFromTime(tmStmp) / std::to_string(classId2) /
                std::to_string(tmStmp);

    //写10类型文件
    try
    {
        auto dir = fileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs(fileName, std::ofstream::binary);
        ofs.write(pHead, 32);
        ofs.write((char *)p32, iGrdNum_out * 4);
        //  ofs.write((char*)p32, iGrdNum * 4);
        ofs.close();
        flag = true;
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += fileName.string();
        msg += ":";
        msg += e.what();
        debugErr(msg);
        cout << msg << endl;
        return flag;
    };

    //配置文件中读取字段，是否保存偏移图svg文件到目录下
    if (hzi::config.ms_rslt_to_image)
    {
        //   cout<<" writeSvg "<<minpOut<<" , "<<maxpOut<<endl;
        string path = fileName.string() + ".svg";

        if (std::filesystem::exists(path))
        {
            fs::remove(path);
        }
        writeSvg(path, pOut_0.get(), XGrdNum, YGrdNum, dX, dY, pcoLocParm.m_dXMin, minY);
        //  cout<<" end writeSvg "<<path <<endl;
    }
    return flag;
}
```



### ※保存9数据类型

> [!NOTE]
>
> 没有函数，而是下面这段代码。
>
> `pOutSignal`中保存提取+再提取数据，写入到文件。
>
> 调用`ofstream::write()`写入数据，默认的打开模式是 `std::ios::out`，它会清空文件内容并从头开始写入。
>
> > - 如果文件 `fileName` 已经存在，文件的内容会被清空。
> > - 如果文件不存在，会创建一个新文件。

```cpp
// 写9类型文件
if (hzi::config.ms_miningSignal)//配置文件中字段
{
    // auto pretime = 0;
    
    //文件头pHead2
    unique_ptr<char[]> pHeadData2 = std::make_unique<char[]>(32);
    char *pHead2 = pHeadData2.get();
    *(double *)(pHead2) = (double)tmStmp;	//第一炮数据的第一个数据文件的采样时间
    
    auto classId2 = 9;	// 19 代表随采，9是随掘
    // auto classId2 = (hzi::config.ms_mining_type == 1) ? 19 : 9;
    *(uint8_t *)(pHead2 + 8) = classId2;
    *(float *)(pHead2 + 9) = deltT;
    *(uint32_t *)(pHead2 + 13) = valNum;            // 可用通道总数
    *(uint16_t *)(pHead2 + 17) = vecSize;           // 数据分组数
    *(uint32_t *)(pHead2 + 19) = pcoParm.outLen;    // 数据长度
    *(uint32_t *)(pHead2 + 23) = pcoParm.coefBegPt; // 超前点数
    *(uint8_t *)(pHead2 + 27) = devId;              // 基站ID
    if (hzi::config.ms_mining_type == 1)	//随采
    {
        *(uint8_t *)(pHead2 + 28) = pcoParm.systemeType; // 系统类型：0-双巷式，1-机载式，2-组合式'
        *(uint8_t *)(pHead2 + 29) = pcoParm.ImageType;   //'随采成像方式:0-散射，1-透射，2-爆炸成像'
    }
    
    //9文件路径入库表e_mining_signaldata_frm_info
    auto conn21 = hzi::config.pConnPool->getConnection();
    conn21.execute(
        "INSERT INTO "
        "e_mining_signaldata_frm_info "
        "(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
        "loc,fx,fy,fz,dis)"
        "values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "
        " ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
        "values(valNum) , vecSize= values(vecSize),outLen= values(outLen)",
        (uint8_t)devId,  // dev_id
        tmStmp / 1000.0, // samp_time
        classId2,        // class_id
        deltT,           // curt_ch
        valNum,          // channels
        vecSize,
        pcoParm.outLen, // ch_pnts
        (relLocFromTime(tmStmp) / std::to_string(classId2) /
         std::to_string(tmStmp))
        .c_str(), // frm_loc
        pcoLocParm.fx,
        pcoLocParm.fy,
        pcoLocParm.fz,
        pcoLocParm.dis_y);

    //写文件
    fs::path outSignalfileName(hzi::config.dataRoot);
    outSignalfileName /= relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp);
    try
    {
        auto dir = outSignalfileName.parent_path();
        if (!fs::exists(dir))
        {
            fs::create_directories(dir);
        }
        std::ofstream ofs_Signal(outSignalfileName, std::ofstream::binary);
        //写文件头到文件
        ofs_Signal.write(pHead2, 32);	
        //写数据到文件
        for (int dex = 0; dex < vecSize; dex++)//vecSize为炮数
        {
            for (int ch = 0; ch < valChnns; ++ch)//valChnns为通道数，在setSignalChnInfo里赋值的
            {
                //数据体p32Signal
                int32_t *p32Signal = (int32_t *)pOutSignal[ch + dex * valChnns];
                // if (!pcoCalChnParms[ch].enb)
                //     continue;
                ofs_Signal.write((char *)p32Signal, pcoParm.outLen * 4);
            }
        }
        ofs_Signal.close();
    }
    catch (std::exception &e)
    {
        string msg("error while writing to file:");
        msg += outSignalfileName.string();
        msg += ":";
        msg += e.what();
        if (hzi::config.verbose)
            cout << "msg = " << msg << endl;
        debugErr(msg);
        return "error";
    };
}
```

## （2）历史重算代码流程

> [!IMPORTANT]
>
> 重算所得文件名（时间戳）入库表`e_mining_pcodata_frm_info`。
>
> | 用到的接口                                           | 功能                                                         |
> | ---------------------------------------------------- | ------------------------------------------------------------ |
> | `/handerSignal/:from_time/:to_time/:time_len/:devId` | 只提取+偏移，写文件9和10                                     |
> | `/handerExtSignalParm/:samp_time/:typeId`            | 读9文件，执行再提取算法流程，写99文件。进行偏移计算，写10文件。 |
> |                                                      |                                                              |
>
> * 调用链：
>
>   ```cpp
>   handerSignalProcess<--/handerSignal/:from_time/:to_time/:time_len/:devId
>                                                               
>   setPCOLocParm,setPCOCalChn,setSignalChnInfo,<--processMethods<--handerExtSignal<-- /handerExtSignal/:samp_time/:typeId
>                                                                 
>   getPCO_parm,setPCOLocParm,setPCOCalChn,setSignalChnInfo,handleSignalData<--handleExtSignalData
>       <--/handerExtSignalParm/:samp_time/:typeId,/handerExtSignalPianYi/:from_time/:to_time
>   ```
>

### 点击【干涉源提取】

只做提取，这一步**只显示【提取图+偏移图】（只做提取基础上的偏移图）**

使用上方设定的时间范围，左侧【干涉源提取】条目下的参数。

会调用接口：

```cpp
//handerSignal/1743789660000/1743789720000/1/0
/handerSignal/:from_time/:to_time/:time_len/:devId
ms_commands.cpp--handerSignalProcess()
调用`mergeMs`拼帧
调用`handleSignalProcess(false)`只提取+偏移，写文件9和10，返回的时间戳作为response
    
//table/e_mining_pcodata_frm_info/frm_loc:str/class_id=10 order by samp_time
/table/:tblName/:cols/:where?


//data_file/2025/4/5/9/1743789665000
/data_file/:year/:month/:day/:type/:timestamp
获取9文件


//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id = 0
type_id前有个/没找到这个接口

//data_file/2025/4/5/99/1743789665000
/data_file/:year/:month/:day/:type/:timestamp  
获取99文件（注意：如果该99文件存在的话，也就是这个时间已经点击过执行做过再提取的话，就会有99。若是第一次进行历史重算就没有，会返回204 No Content）


//getLocInfo/1743789665000/mark_XLen,mining_locx,mining_dir,dXGrdLen,dYGrdLen
/getLocInfo/:timestamp/:cols


//data_file/2025/4/5/10/1743789665000
/data_file/:year/:month/:day/:type/:timestamp
获取10文件
```

### 点击【保存】

```cpp
//POST：config/e_mining_PCOSignalParm_history

//POST：update_columns/e_mining_PCOLocParm/1=1

//POST：config/e_tunnel_extractPara
```

### 点击【执行】

使用左侧设定参数，在提取文件的基础上，进行再提取。显示【提取图+再提取图+偏移图（提取+再提取上的偏移图）】

根据设定好的计算参数对当前选中时间戳的提取数据，进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`，并在再提取数据和再提取波形图的基础上，得到新的偏移图（提取+再提取的偏移图）。

会调用接口：

```cpp
//POST：config/e_mining_PCOSignalParm_history
//payload为页面左侧设定的参数值
//写参数到库表
/config/:tblName
    
//POST：update_columns/e_mining_PCOLocParm/1=1
//payload为e_mining_PCOLocParm中要更新的参数
/update_columns/:tblName/:condition

//POST：config/e_tunnel_extractPara
//payload为e_tunnel_extractPara中更新参数
/config/:tblName

//POST：/handerExtSignalParm/1747152060100/9
/handerExtSignalParm/:samp_time/:typeId
调用`ms_mining.cpp--handleExtSignalData(samp_time, typeId)`，typeId传文件类型9，读取9类型文件。
和`ms_mining.cpp--handleSignalProcess`类似，先通过4个取参数函数取参数，但读取历史参数表`e_mining_PCOSignalParm_history`。
读9文件数据保存到pData。
调用`PureCommonOperation::handleSignalData(pData, pOutSignal)`，pData数据经过处理得到再提取数据存于pOutSignal。
调用`PureCommonOperation::CalMigration()`把pOutSignal数据进行偏移计算，存于pOut_tmp。
调用`saveResult(pOut_tmp)`保存偏移图文件10。
pOutSignal中数据写文件到99。



//data_file/2025/5/14/99/1747152060100
获取99文件。

//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//getLocInfo/1747152060100/mark_XLen%2Cmining_locx%2Cmining_dir%2CdXGrdLen%2CdYGrdLen

//data_file/2025/5/14/10/1747152060100
获取10文件。

//table/e_tunnel_imgSetting/ampScale,scaleRatio

//data_file/2025/5/14/101/1747152060100
获取101文件？

//data_file/2025/5/14/102/1747152060100
获取102文件？
```

### ※保存99数据类型

* 接口：`/handerExtSignalParm`（点击【执行】）
* 接口：`/handerExtSignal`（没遇到过）

```cpp
auto classId2 = 99;
```

### 点击【同步】

```cpp
//POST：config/e_mining_PCOSignalParm_history

//POST：update_columns/e_mining_PCOLocParm/1=1

//POST：config/e_tunnel_extractPara

//POST：config/e_mining_PCOSignalParm
```

### 点击【树形图】

```cpp
//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//data_file/2025/5/14/99/1747152060100
获取99文件

//table/e_chns_config/chn_label:str,state_id,is_ms_trig/type_id%20=%200

//getLocInfo/1747152060100/mark_XLen%2Cmining_locx%2Cmining_dir%2CdXGrdLen%2CdYGrdLen

//data_file/2025/5/14/10/1747152060100
获取10文件

//table/e_tunnel_imgSetting/ampScale,scaleRatio

//data_file/2025/5/14/101/1747152060100

//data_file/2025/5/14/102/1747152060100
```

# 11. 数据文件类型及格式

---

> [!IMPORTANT]
>
> | 文件类型 | 功能                  |
> | -------- | --------------------- |
> | 3        | 原始数据：背景        |
> | 6        | 原始数据：全时        |
> |          |                       |
> | 9        | 干涉提取数据：        |
> | 10       | 偏移图数据            |
> | 99       | 9经过再提取流程后数据 |
> |          |                       |
> | 11       |                       |
>
> 



## （1）9文件头格式

> [!WARNING]
>
> 数据文件的头格式和`DataFrame`不同。

| 总长32B | 长度（单位bit） | 说明                                                    |
| ------- | --------------- | ------------------------------------------------------- |
| 0       | 8               | tmStmp。*(double *)(pHead2) = (double)tmStmp            |
| 8       | 8               | classId=9，类型                                         |
| 9       | 32              | deltT，采样间隔（单位ms）                               |
| 13      | 32              | valNum，可用通道总数                                    |
| 17      | 16              | vecSize，数据分组数（这个文件里有几组数据，也就是炮数） |
| 19      | 32              | outLen，数据长度（点数）                                |
| 23      | 32              | coefBegPt，超前点数                                     |
| 27      | 8               | devId，基站ID                                           |
| 28      | 8               | systemeType（系统类型：0-双巷式，1-机载式，2-组合式'）  |
| 29      | 8               | ImageType（'随采成像方式:0-散射，1-透射，2-爆炸成像'）  |
|         |                 |                                                         |



## （2）99文件头格式

> `ms_mining.cpp--handleExtSignalData`

| 总长32B | 长度（单位bit） | 说明                                         |
| ------- | --------------- | -------------------------------------------- |
| 0       | 8               | 时间戳。*(double *)(pHead2) = (double)tmStmp |
| 8       | 8               | 9                                            |
| 9       | 8               | deltT。*(float *)(pHead2 + 9) = deltT;       |
| 13      | 32              | valNum                                       |
| 17      | 16              | vecSize                                      |
| 19      | 32              | outLen                                       |
| 23      | 32              | coefBegPt                                    |
| 27      | 8               | devId                                        |
| 28      | 8               | sysType                                      |
| 29      | 8               | imageType                                    |
|         |                 |                                              |

## （3）11文件头格式

| 总长32B | 长度（单位bit） | 说明                                                         |
| ------- | --------------- | ------------------------------------------------------------ |
| 0       | 8               | 时间戳。*(double *)(pHead2) = (double)tmStmp                 |
| 8       | 8               | classId11=11                                                 |
| 9       | 8               | 1000.0 / (deltT*pcoParm.outLen);  //频率分辨率frequencyResolution |
| 13      | 32              | 可用通道总数                                                 |
| 17      | 16              | 数据分组数                                                   |
| 19      | 32              | 数据长度outLen                                               |
| 23      | 32              | 0                                                            |
| 27      | 8               | 基站IDdevId                                                  |
| 28      | 8               | sysType                                                      |
| 29      | 8               | imageType                                                    |
|         |                 |                                                              |

## （4）10文件头格式

| 总长32B | 长度（单位bit） | 说明                                         |
| ------- | --------------- | -------------------------------------------- |
| 0       | 8               | tmStmp。*(double *)(pHead) = (double)tmStmp; |
| 8       | 8               | classid=10                                   |
| 9       | 8               | devId                                        |
| 10      | 16              | XGrdNum                                      |
| 12      | 16              | pcoLocParm.m_iYGrdNum                        |
| 14      | 16              | pcoLocParm.m_iZGrdNum                        |
| 16      | 32              | minpOut                                      |
| 20      | 32              | maxpOut                                      |
| 24      | 32              | dX                                           |
|         |                 |                                              |

# 12. 自干涉谱图

---

> 原始信号-->corrFD自相关-->DataFFT进行fft
>
> `ms_mining.cpp--selfCorrSpectrum()`

* 自相关：因子道-通道号相同，做相关。调用`handleDataFrameVec_signal`并行计算得到相关数据，存在`pCorrResult`

* 对相关数据执行fft，实部保存在`pChDataR`，虚部保存在`pChDataI`

* 对实部和虚部的平方和求平方根，得到幅值`AmplitudePt`。所有点的幅值存于`pOutSelfCorrSpectrum`

* 谱图左右对称，因此只显示一半的点即可。

* 按照文件9的格式，保存到11文件。

  9字节：频率分辨率。19字节：数据长度，`pcoParm.outLen / 2`。23字节：超前点数，为0。

* 前端读11文件，显示幅值谱（频谱）。纵轴是幅值，横轴是频率。频率=k*频率分辨率，k是点的index。

  `频率分辨率=采样频率/采样点数=（1/deltT）/ pcoParm.outLen`。

* 前端可以选定【1个频率范围】（频段）进行显示。后面可以选定【若干频段】进行显示

# 13. 速度曲线

---



# 14. 异常预测

---

### 库表

| -                  | -                                                            |
| ------------------ | ------------------------------------------------------------ |
| e_tunnel_lineInfo  |                                                              |
| e_tunnel_threshold |                                                              |
| e_tunnel_errorinfo | 由表`e_tunnel_lineInfo`和表`e_tunnel_threshold`共同得出表`e_tunnel_errorinfo`记录 |
|                    |                                                              |
|                    |                                                              |

### 代码

实时计算。对每次计算得到的偏移图中异常进行保存，保存到表`e_tunnel_lineInfo`。

`ms_mining.cpp-366-saveResult()`中先通过函数`saveLine()`保存提取异常结果到表`e_tunnel_lineInfo`。

**`ms_mining.cpp-5476-getWarningInfo()`**中通过查表`e_tunnel_threshold`和表`e_tunnel_lineInfo`，进行【k-mean聚类】得到【异常预测】结果（也即预测的地质分层面位置与夹角），保存到表`e_tunnel_errorinfo`。

**查询表`e_tunnel_errorinfo`绘制到【巷道探测示意图】。**

# 15. 预警

### 配置文件

```json
"warningTimeSyncIntval":2,//预警发送消息间隔（查表间隔），单位：min
"is_used_warning":false,//is_Used_warning接口返回值的是否使用预警（代码里实际没用它作为判断）
"warningTimeSync":false,//启用预警（实际有效的）
```

### 库表

| 表名                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| e_warningInfo_parm    | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts         | **记录了所有的微震事件。**用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info        | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
| e_warning_parm        | 暂时未用                                                     |
|                       |                                                              |

### 代码

`main.cpp-syncWarningInfo()`在子线程循环运行下面逻辑，线程每隔`hzi::config.warningTimeSyncIntval`时间休眠一次：

* 为了兼容之前代码`getWarningMsg()`函数名未修改，其中只做根据当前时间获取预警时间段的功能。调用`doWarningMsgProcess()`。

* `doWarningMsgProcess()`中，地震和电法分开。

  有地震，则查表`e_warning_level_value`获取：`msFrequency 微震频次`，`highEnergyNum 大能量事件`，`msLocation 异常区域个数`，这3个预警变量的蓝橙红等级阈值，存在`warningLevelMapMS`。**若只有地震，则表中只存地震的等级阈值，作为异常处理依据，若缺少，则抛出异常。电法同理。**

  有电法，则查表获取`e_sp_variation 自电变化量`，`ee_p_variation 视电阻率变化量`，这2个预警变量的蓝橙红等级阈值，存在`warningLevelMapEE`。**若只有电法，则表中只存电法的等级阈值。**

  若两者耦合都有，则表中需都存。

  而后分别按照下面计算各自的预警变量。

* 这5个量的值是计算得来。查表`e_msevt_rslts`（记录所有微震事件）和表`e_warningInfo_parm`（通过微震事件记录的参数计算得到5个预警变量时的一些阈值）。

* 遍历表`e_msevt_rslts`中每条记录，计算得到5个预警变量的值，代码中实际只计算了：微震频次，大能量，异常区域个数。

* 构造msg信息。`msLevelVec`分别保存：【微震频次，大能量，异常区域个数】的预警等级，计算：大于对应预警变量的阈值即为蓝橙红。

  `getMsWarningLevel()`通过`msLevelVec`中保存的【微震频次，大能量，异常区域个数】3个预警等级，综合计算，返回0/1/2/3到**【`msLevel`微震预警等级】，作为微震3个参数计算得到的预警等级**。若为1则蓝色，不为1则橙色，保存到`warningType`。

* 然后，根据电法信息，得到【电法预警等级`leveL_sp`】，作为电法2个参数计算得到的预警等级。

  再通过一定逻辑，`warningType`中已有的微震预警等级，结合电法预警等级`leveL_sp`，得到最终的【综合预警等级`warningType`】，以及【最终的msg信息】。

  `warningType`，`msLevel`，`leveL_sp`，`msg`入库表`e_warning_Info`。

* 最后，预警发送逻辑：给用户组(msg)发送蓝色和处理后的非蓝色，同时运维组也发一份(告知已发送给用户)

  ```mysql
  string sqlQuery = "SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`=1 AND `is_sent_user`=0 
  UNION 
  SELECT tm, `warningType` AS wt, `msg` FROM e_warning_Info WHERE `warningType`> 1 AND `is_handle`= 1 AND `is_sent_user`= 0 "; // 取最新的一条
  ```

  蓝色（`warningType`=1）且未发送给用户，非蓝色（`warningType`> 1）且已被运维处理（`is_handle`= 1）且未发送给用户（`is_sent_user`= 0 ），这些信息发送给用户（alarm）和运维（msg)。

  ```cpp
  string cmdMsg("./send_message.sh \"msg\" \"" + string(" 【预警已发送给用户】 ") + msgTmp + "\"");// 发运维
  string cmdAlarm = "./send_message.sh \"alarm\" \"" +  msgTmp + "\""; // 发用户
  ```

  发送成功，则将表`e_warning_Info`中字段`is_sent_user`置1，表示已发送给用户。

### 预警重算

从表`e_msevt_rslts`中重新查询该时间段的微震事件，进行预警的逻辑计算，得到新的预警记录update入库表`e_warning_Info`。（工程人员会修改表`e_msevt_rslts`中的微震记录，之前的记录是系统自动判别的。）

## 接口

### 获取预警列表

> ## GET 预警列表
>
> ```cpp
> /table/:tblName/:cols/:where?
> 参数tblName：e_warning_Info
> 参数cols：查询字段名
> 参数where：WHERE查询条件
> ```
>
> ### 调用举例：
>
> * 查询已处理的10条记录：
>
>   `GET https://ahhzi.com.cn:7001/table/e_warning_Info/tm,warningType,ms_warning,ee_warning,msg:str,is_handle?is_handle=1 limit 10`
>
> ### 字段说明
>
> | 字段名      | 类型    | 说明                                       |
> | ----------- | ------- | ------------------------------------------ |
> | tm          | bigint  | 预警事件时间戳                             |
> | warningType | tinyint | 综合预警类型：0-无，1-黄色，2-橙色；3-红色 |
> | ms_warning  | tinyint | 微震预警等级：1-蓝色，2-橙色，3-红色       |
> | ee_warning  | tinyint | 电法预警等级：1-蓝色，2-橙色，3-红色       |
> | msg         | varchar | 预警信息                                   |
> | is_handle   | tinyint | 该预警是否已被运维处理：0-未处理，1-已处理 |
>
> ### 返回结果
>
> | 状态码 | 状态码含义                                                   | 说明                 | 数据模型 |
> | ------ | ------------------------------------------------------------ | -------------------- | -------- |
> | 200    | OK                                                           | 请求成功             |          |
> | 204    | [No Content](https://tools.ietf.org/html/rfc7231#section-6.3.5) | 空表或存在字段为null | Inline   |
> | 400    | Bad_Request                                                  | sql错误              |          |
> |        |                                                              |                      |          |
>
> > 返回示例
>
> > 204 Response
>
> ```json
> "not found"
> ```
>
> ### 返回数据结构
>
> json格式
>
> ```json
> {
>     "code": 0,
>     "data": [
>         {
>             "tm": 1727719200000,
>             "warningType": 2,
>             "ms_warning": 2,
>             "ee_warning": 0,
>             "msg": "微震：该时间范围内,总频次为 18,总能量为955121.000000J大能量事件 16 次且主要分布在 范围：1020.119995<x<1020.119995,280.125000<y<280.125000,730.375000<z<730.375000;微震预警橙色渗流电场:正常;视电阻率:稳定;综合预警：蓝色;",
>             "is_handle": 1
>         }
>     ]
> }
> ```



# 16. 观测系统

> [!IMPORTANT]
>
> 通道坐标，掘进里程，偏移距，掘进方向，日进尺
>
> 日进尺+掘进方向--->掘进里程
>
> 偏移距+掘进方向--->通道坐标

> 目的：迎头每天都在向前移动，可以通过【当前掘进里程-偏移距】得到传感器的坐标。
>
> 根据偏移距等计算偏移图。
>
> **现场流程：**
>
> * 自动更新：
>
>   【掘进里程】每天根据日进尺自动增加，此时传感器若未挪动，会导致【偏移距】也跟着更新增大
>
> * 手动修改：
>
>   现场的人会同时**填写**【掘进里程】和【偏移距】
>
>   【掘进里程】：当实际每日进尺和设定不一致时需要手动修正掘进里程，并**更新平均日进尺（自动更新掘进里程不重算日进尺）**。若传感器未挪动，偏移距也会跟着变化，计算出新的偏移距（如增大）
>
>   【偏移距】的**数值不会每天改**，但每天改的时候都会一起填入。只有当偏移距过大的时候，会挪动一组传感器到距离迎头一定位置处，然后**改小偏移距的数值填入**。不管【偏移距】数值变不变，都会重算传感器坐标并更新，假设【偏移距】填入数值没变，传感器坐标更新为0
>
> * `hzi::mining_locx`掘进里程，全局变量
>
> * `hzi::heading_mil`偏移距，全局变量
>
>   ![image-20250605155042299](D:\notes\笔记Img\image-20250605155042299.png)

## （1）库表

| -                     | -                                                            |
| --------------------- | ------------------------------------------------------------ |
| p_chn_types           | 通道type_id和工作类型。type_id=0是微震工作类型。             |
| e_chns_config         | 所有工作类型通道配置显示的表。保存用户输入的通道坐标。有update触发器，更新到`e_chns_config_history`。 |
| e_chns_config_history | 保存`e_chns_config`修改历史。                                |
| e_chns_config_tunnel  | （**该表已废弃**）只存微震通道。修改偏移距后，先根据delta，修改该表中通道坐标。再更新到`e_chns_config`。 |
|                       |                                                              |
| e_tunnel_cur_status   | （**已废弃**）基准通道，偏移距，掘进里程。前端发送的掘进里程和偏移距，存到全局变量后，直接入库该表。根据日进尺的自动计算也入库该表。 |
| e_mining_PCOLocParm   | 点击【当前掘进里程，修正】，只保存该按钮点击后前端发来的：掘进方向（0-x正向，1-负向），日进尺，掘进里程，修改参数的时间戳 |
| e_tunnel_locInfo      | 时间戳，日进尺，掘进里程历史和最新                           |
|                       |                                                              |
|                       |                                                              |

## （2）函数

| -                       | -                           |
| ----------------------- | --------------------------- |
| updateTunnelModelInfo() | 更新表`e_tunnel_model_info` |
| updateTunnelCurStatus() | 更新当前掘进状态            |
|                         |                             |
|                         |                             |





## （3）初始化

### `Config.hpp-initChanelsConfig()`，被`Config.hpp-init()`调用初始化通道设置。

### `Config.hpp-initChanelsConfig()`中调用了`Config.hpp-initTunnelCurStatus()`：

* 从表`e_tunnel_cur_status`读取【掘进里程】【偏移距】等。若表为空则直接对赋值`hzi::tunnel_mining_loc = 100; hzi::heading_mil = 5;auto back_distance = hzi::tunnel_mining_loc - 100;auto forward_distance = hzi::tunnel_mining_loc + 50;`，然后入库表`e_tunnel_cur_status`。

* 从`e_chns_config`中读取【基准通道坐标】。

* 若表`e_chns_config_tunnel`为空，则从表`e_chns_config`读取【`type_id=0`，微震通道】的所有记录插入表`e_chns_config_tunnel`。

### `Config.hpp-initChanelsConfig()`中调用了`Config.hpp-updateTunnelModelInfo()`：

* 从表`e_info`读取工作面长度

* 若`ms_tunnel_listen`为true，从表`e_tunnel_cur_status`读取回采位置

  为false，从表`e_mining_PCOLocParm`读取【掘进方向】，【回采位置】，【日进尺】，【时间戳`timestamp`（修改参数表当日0时刻）】。（若表`e_tunnel_locInfo`非空，则读取回采位置和日进尺覆盖）

* 根据当前时间戳`sampTime`和`timestamp`计算时间段，乘以日进尺，计算新的回采位置，再计算新的偏移距。调用函数`updateTunnelCurStatus`入库表`e_tunnel_cur_status`
* 计算采空率并入库表`e_tunnel_model_info`

### `Config.hpp-initChanelsConfig()`中调用了`Config.hpp-initTunnelGeologyStructMap()`：

* 判断表`e_geology_info`（岩性，p波s波速度）是否为空，若为空则插入若干固定值

* 判断表`e_tunnel_geology_info`（位置id，岩性）是否为空，若为空则插入若干固定值

  

## （2）自动更新掘进里程

### 位置1（`ms_mining.cpp-L1225`）

> [!NOTE]
>
> `setPCOLocParm()`，这里只是取参数进行计算，根据日进尺和偏移方向计算回采位置，而不入库`e_tunnel_locInfo`。
>
> **但`ms_mining.cpp-L5972`，若`!hzi::config.ms_tunnel_listen`则将重算出的回采位置赋值给全局变量，虽没入库但也更新了全局**

### 位置2（`client_handle_data.cpp-L185`）

> [!NOTE]
>
> * 函数`updateTunnelModelInfo`自动更新。
>
> * `hzi::config.ms_tunnel_listen`从配置文件中读取，false则根据日进尺计算新的【掘进里程】。
>
> * 调用`updateTunnelCurStatus`更新掘进里程和偏移距到表`e_tunnel_cur_status`。（改为updateTunnelLocInfo）。
>
> * 根据【掘进里程】计算采空率。

每天【掘进里程】和【偏移距】自动增加：

```cpp
auto sampTime = nowMS();

//从e_mining_PCOLocParm取掘进位置和掘进方向
auto rslt = conn.executeQuery(
    "SELECT mining_locx,mining_dir,"
    "UNIX_TIMESTAMP(mining_date)AS tm ,day_step"
    " FROM `e_mining_PCOLocParm`  ORDER BY mining_date DESC "
    "LIMIT 1");
if (rslt.next())
{
    auto m_dir = rslt.getInt("mining_dir");
    mining_locx = rslt.getDouble("mining_locx");

    auto dayStep = rslt.getDouble("day_step");

    auto timestamp = rslt.getDouble("tm");

    //若e_tunnel_locInfo中有记录，用它的掘进位置和日进尺
    auto rslt2 = conn.executeQuery(
        "SELECT mining_loc,day_step  FROM `e_tunnel_locInfo`"
        " WHERE tmstamp <= ? ORDER BY tmstamp DESC LIMIT 1",(double)sampTime);
    if (rslt2.next())
    {
        mining_locx = rslt2.getDouble("mining_loc");
        dayStep = rslt2.getDouble("day_step");
    }

    int days = floor((sampTime / 1000.0 - timestamp) / 24 / 3600);
    // 根据时间戳在当日时刻，在细分进尺量
    mining_locx = (m_dir == 0) ? (mining_locx + days * dayStep) : (mining_locx - days * dayStep);
    hzi::heading_mil = mining_locx - hzi::firstChn_locx;//计算偏移距
    auto ret1 = updateTunnelCurStatus(mining_locx, hzi::heading_mil, hzi::isConnected,hzi::isRunning, "更新掘进位置", false);
}
```

## （3）手动修改偏移距

> **点击【当前掘进里程-->修正】**，调用接口`config/e_mining_PCOLocParm`，修改表`e_mining_PCOLocParm`中【掘进里程和日进尺】。只是保存参数到`e_mining_PCOLocParm`，不更新表`e_tunnel_cur_status`，因此不保存到回采历史表`e_mining_locx_history`。
>
> **点击【偏移距，修改】**，调用接口`/setHeadingMil/:typeId/:isWarning`**，调用函数`updateTunnelCurStatus`，update表`e_tunnel_cur_status`，**将前端发送的掘进里程和偏移距保存到全局变量`hzi::heading_mil`和`hzi::tunnel_mining_loc`，并入库表`e_tunnel_cur_status`（因此需要保存到回采历史表`e_mining_locx_history`）。再调用函数`updateChanelsLoc`，根据新的掘进里程和偏移距计算通道移动距离，更新表`e_chns_config_tunnel`中通道坐标。表`e_chns_config_tunnel`内容更新到表`e_chns_config`，让通道设置的显示改变。
>
> 再通过触发器将表`e_chns_config`内容更新到历史表`e_chns_config_history`
>
> 总结表更新：`e_tunnel_cur_status`，`e_chns_config_tunnel`--->`e_chns_config`--->`e_chns_config_history`

* 偏移距就是新的传感器距离迎头距离了，手动修改【偏移距】：

  `client_handle_data.cpp-433`

  ```cpp
  auto constDic = hzi::tunnel_mining_loc - hzi::heading_mil - hzi::firstChn_locx;
  //此时偏移距hzi::heading_mil是更新过的，减小了的。hzi::tunnel_mining_loc - hzi::heading_mil是挪过来的检波器和迎头的距离。即新的hzi::firstChn_locx。再减去旧的hzi::firstChn_locx，就是新旧传感器（最靠近迎头）距离迎头距离的差值。
  ```

  `client_handle_data.cpp-472`

  ```cpp
  //把e_chns_config_tunnel里每个检波器的坐标都加constDic
  "values(loc_x) + ?, loc_y=values(loc_y),loc_z=values(loc_z)";
  conn.execute(sql.c_str(), (double)localtime, (double)ts,constDic);
  //e_chns_config_tunnel坐标更新到e_chns_config
  hzi::firstChn_locx = hzi::tunnel_mining_loc - hzi::heading_mil;//经过前面的更新，将hzi::firstChn_locx更新为新的
  ```

## （4）回采位置历史记录

* 手动修改偏移距：增加表`e_mining_PCOLocParm_history`，在表`e_mining_PCOLocParm`上增加触发器，当【手动修改偏移距】时表`e_mining_PCOLocParm`新增一条记录，在history表INSERT一条记录。当修改一条记录时，在history表修改该记录。时间戳统一为当天0点。
* 自动和手动，都会调用`updateTunnelCurStatus`将当前回采位置入库到`e_tunnel_cur_status`，只有修改了表`e_tunnel_cur_status`时才会将回采位置记录到回采历史表`e_mining_locx_history`。

## （5）使用通道坐标的地方

### `handleSignalProcess()`

* 函数`setPCOLocParm()`

  从表`e_mining_PCOLocParm`读取【回采位置】【日进尺】【掘进方向】等

  若表`e_tunnel_locInfo`有【回采位置】【日进尺】则覆盖

  根据当前时刻和日进尺计算回采位置，没有入库表`e_tunnel_cur_status`，只是作为参数参加计算。（自动计算在函数`updateTunnelModelInfo`中完成，这里可能是为了提高计算精度）

  

* 函数`setPCOCalChn()`

  从表`e_chns_config_history`读取(指定时间戳前，某类型通道)的所有坐标。

  若表`e_chns_config_history`为空，则从表`e_chns_config_tunnel`读取。

## （6）会变更回采位置或偏移距的地方

* 改回采位置：`updateTunnelModelInfo`
* `initTunnelCurStatus`
* 偏移距：`ConnectServer.cpp-client_receive_frame`

## （7）会读取基准通道坐标的地方

* `initTunnelCurStatus`自动计算处

* `updateChanelsLoc`读取基准坐标计算Δx，计算通道坐标变更

* `initTunnelCurStatus`初始化基准通道坐标

* `ConnectServer.cpp-client_receive_frame`，若原始帧第9字节的【回采位置】和系统中的全局变量【回采位置】不一致时：

  调用`insertTunnelLocInfo()`将【回采位置】入库表`e_tunnel_locInfo`

  调用`updateTunnelCurStatus()`重新计算【偏移距】，入库表`e_tunnel_cur_status`

  调用`updateTunnelModelInfo()`使用表`e_tunnel_locInfo`中【回采位置】【日进尺】自动计算

# 17. 页面

---

## （1）首页

### 里程状态与偏移距

![image-20250409154122217](D:\notes\笔记Img\image-20250409154122217.png)

> 基准传感器（之前代码里写死为通道1，后面改为在挪动的时候可指定通道n）距离迎头距离。4个传感器一组，距离过远把最远那一组移到迎头处。

打开页面，调用接口`/samp_conf/:tblName/:itmNames/:fromInit?`从表`e_tunnel_cur_status`中读取。

点击【修正】调用接口`config/e_mining_PCOLocParm`

点击【修改】调用接口`/setHeadingMil/:typeId/:isWarning`

### 巷道探测示意图

> 显示预测的地质异常（地质分层的位置和角度）

![image-20250422131919742](D:\notes\笔记Img\image-2025042213191974211)

## （2）系统

### 工程参数

#### 停止监测

下发命令字:5,设备地址:1,字节数:22,命令标识:101327

#### 启动监测

250408 09:12:50 下发命令字:2,设备地址:1,字节数:54,命令标识:101328
250408 09:12:50 下发命令字:5,设备地址:1,字节数:22,命令标识:101329
250408 09:12:55 下发命令字:3,设备地址:1,字节数:278,命令标识:101330
250408 09:13:15 下发命令字:4,设备地址:1,字节数:38,命令标识:101331

#### 通道配置

> * 用户修改指定基站连接的通道配置信息。
> * 显示的是表`e_chns_config`。

* 修改【工程位】（location2）/【地层位】（location1）/【状态】（state_id），调用接口`/table/`，载荷为`dev_id`，`chn_no`+`location2`/`location1`/`state_id`，修改库表`e_chns_config`中字段。

  其中state_id中状态从库表`p_chn_states`读取。

#### 采集置参

| 库表             | 微震采集参数                                                 | 说明 |
| ---------------- | ------------------------------------------------------------ | ---- |
| e_ms_samp_config | 采样间隔，采样点数，超前点数，触发方式，微震触发脉宽，背景采样间隔（微震背景极值检测时窗），（背景上传时窗）微震背景极值上传时窗，（振铃阈值）微震背景振铃检测阈值 |      |
| e_ms_trig_params | 触发通道智能剔除，触发通道剔除判断时间，微震背景数据类型，触发通道数，触发时窗 |      |
|                  |                                                              |      |

| 微震采集参数                         | 库表                            | 说明 |
| ------------------------------------ | ------------------------------- | ---- |
| 采样间隔                             | e_ms_samp_config，p_samp_intvls |      |
| 采样点数                             | e_ms_samp_config，p_points      |      |
| 超前点数                             | e_ms_samp_config，p_points      |      |
| 触发方式                             | e_ms_samp_config，p_ms_trigs    |      |
| 触发通道智能剔除                     | e_ms_trig_params                |      |
| 触发通道剔除判断时间（s)             | e_ms_trig_params                |      |
| 微震背景数据类型                     | e_ms_trig_params                |      |
| 触发通道数                           | e_ms_trig_params                |      |
| 触发时窗                             | e_ms_trig_params                |      |
| 微震触发脉宽                         | e_ms_samp_config                |      |
| 背景采样间隔（微震背景极值检测时窗） | e_ms_samp_config，p_time_wins   |      |
| 背景上传时窗（微震背景极值上传时窗） | e_ms_samp_config，p_time_wins   |      |
| 振铃阈值（微震背景振铃检测阈值）     | e_ms_samp_config                |      |

点击【保存】后，调用接口`/cmds/:cmd_id/:dev_id?`3次，`cmd_id`分别为2/5/3，其中3时带payload：

```json
{
    "ms_samp_intvl_id": 2,//修改采样间隔为0.20ms
    "ms_samp_pnts_id": 8,
    "ms_ahead_pnts_id": 6,
    "ms_trig_id": 1,
    "ms_default_thrshld": 5,
    "ms_trig_puls_wid": 3,
    "ms_bg_chk_win_id": 13,
    "ms_bg_up_win_id": 9,
    "ms_ring_thrshld": 200,
    "trig_chn_judgWn": 600,
    "msDateType": 1,
    "trig_chns": 3,
    "trig_time_win": 300,
    "ee_type_id": 1,
    "ee_pw_time_id": 6,
    "ee_voltage_id": 3,
    "ee_m_order_id": 0,
    "ee_m_wid_id": 0,
    "ee_time_schm": 0,
    "ee_times_id": 3,
    "ee_timetable": [
        0,
        7200,
        14400,
        21600,
        28800,
        37200,
        43200,
        50400,
        57600,
        64800,
        72000,
        79200
    ],
    "ee_time_intvl": 30,
    "ee_samp_intvl_id": 8,
    "ee_samp_pnts": 25,
    "ee_voltage_schm": 0,
    "ee_start_atonce": 0,
    "sp_samp_intvl_id": 8,
    "sp_samp_pnts": 250,
    "tmpr_samp_intvl_id": 13,
    "tmpr_up_win_id": 9,
    "coupl_threshold": 201,
    "coupl_samp_intvl_id": 1,
    "coupl_samp_pnts_id": 7,
    "coupl_ahead_pnts_id": 4,
    "auto_gain": 1,
    "gain_id": 3
}
```

#### 微震计算参数







### 随掘监测

#### 实时参数

* 将参数保存到表`e_mining_PCOSignalParm`和`e_mining_PCOLocParm`。

| 页面参数                   | 库表参数`e_mining_PCOSignalParm` | 参数说明                                                     |
| -------------------------- | -------------------------------- | ------------------------------------------------------------ |
| 用户参数->【拼接数据类型】 | `class_id`                       | 实时计算取用的数据类型，是【全时/背景】。`threadHanleData()` |
| 用户参数->【监测频度】     | `dataFreq`                       |                                                              |
| 干涉源提取->【数据时长】   | `dataLen`                        | 数据时长（单位时间min)（`时间段/数据时长=炮数`），历史计算代码里是`time_len`即页面上的【分段时长】，实时计算代码里用的是`hzi::miningDateLen` |
| 干涉源提取->【因子时长】   | `coeLen`                         | 因子系数长度(时间单位：min)                                  |
| 干涉源提取->【超前点数】   | `coefBegPt`                      | CSP道集提取用到。                                            |
| 干涉源提取->【输出点数】   | `outLen`                         | 输出及其长度(时间单位ms)                                     |
| 干涉源提取->【因子道】     | `chn_no`                         | 选用因子通道号                                               |
|                            |                                  |                                                              |
|                            |                                  |                                                              |
|                            |                                  |                                                              |

#### 





## （3）监测

### ①实时数据

#### 微震全时

![image-20250417103359063](D:\notes\笔记Img\image-202504171033590631)

### ②历史数据

#### 微震全时

点击【刷新】后，调用接口：

`table/e_data_frm_info/frm_loc:str/class_id=6 and round(unix_timestamp(samp_time),3)>=1747678200 and round(unix_timestamp(samp_time),3)<1747678320 order by samp_time`

多个`data_file/2025/5/20/6/1747678317500`，把`1747678200 ~ 1747678320 `时间范围之间的文件都取过来。

`table/e_chns_config/chn_label:str,state_id/dev_id=1 and type_id=(select ch_type_id from p_data_types where type_id=6)`（表`e_chns_config`中`type_id`：通道工作类型id）



## （4）随掘

### 随掘地震

> **该页面上属于历史重算。**
>
> **历史重算目的：通过偏移图进行验证输入的参数的效果。把效果好的参数填入实时参数内，然后进行自动处理，并保存为文件。**

#### 树形图

> **查询表`e_mining_pcodata_frm_info`获取数据时间戳。**表`e_mining_pcodata_frm_info`若没记录，表`e_mining_signaldata_frm_info`即使有记录树形图也不会有选项。

* 点击树形图的时间戳后：调用接口`/data_file/:year/:month/:day/:type/:timestamp`

![image-20250415161308369](D:\notes\笔记Img\image-20250415161308369.png)

* 参照园区试验系统->监测->微震事件，解决需求【自动干涉后记录有效标记，无效删除】，在表【e_mining_signaldata_frm_info】中增加字段【isValid】，让用户自己给树形图中项目增加是否有效的标记。

#### 干涉源提取

> * 点击黄色按钮【干涉源提取】。
>
> * 页面上的干涉源提取属于历史重算。只做干涉源提取+偏移（干涉提取图+干涉提取基础上的偏移图），再提取+偏移需手动执行。
>
> * 手动选择时间段，进行干涉（互相关或自相关）得到`提取数据(class_id=9)`和`干涉提取波形图`。并在提取数据和提取图的基础上，按照左侧设定的偏移参数进行偏移得到`偏移数据(class_id=10)`的`偏移图`。
>
> * 重算所得文件名（时间戳）入库表：`e_mining_signaldata_frm_info`
>
>   > 若用背景原始数据计算，提取数据时间戳为时间段**开始时间加上5s**。
>   >
>   > 若用全时原始数据计算，提取数据时间戳为时间段**开始时间加上2.5s**。
>
> 时间段不要选太大，一般几分钟，否则数据太多响应很慢。
>
> 分段时长，一般设置和时间段一样大。

* 分段时长：`时间段/分段时长=炮数`。代码逻辑中，时间戳转ms，（开始-结束）/分段时长，得到`dataSize`，即炮数。若干炮数的数据叠加（简单的幅值叠加）。

  ![image-20250416141111347](D:\notes\笔记Img\image-20250416141111347.png)

* 调用接口`/handerSignal/:from_time/:to_time/:time_len/:devId`（time_len即分段时长），回调`handleSignalProcess(dfvec, false,dev_id)`，只进行干涉提取。

* 从表`e_mining_PCOSignalParm_history`中查询`hzi::miningFreq`，`hzi::miningDateLen`，`hzi::mining_classId`。

* 内部调用`mergeMs`拼接帧数据，再调用`handleSignalProcess`进行处理。

* 调用`handleSignalProcess(dfvec, false,dev_id)`，其中`false`表示进行历史计算。

* **但页面上，和【实时参数-数据时长】会写入库表`dataLen`不同的是。历史计算的【分段时长】并没有入库。**

#### 再提取

> * 属于历史计算。
>
> 根据设定好的计算参数对当前选中时间戳的提取数据，**进行滤波/振幅均衡/反褶积/反射波提取等操作。生成处理后的`再提取数据(class_id=99)`和`再提取波形图`**，并在再提取数据和再提取波形图的基础上，得到新的偏移图。
>
> * **需手动点击【执行】，调用接口`/handerExtSignalParm/:samp_time/:typeId`，回调`handerExtSignalParm`，调用函数`handleExtSignalData`根据时间戳读取上面干涉源提取得到的类型9文件，使用提取文件再次进行后续处理。在`handleExtSignalData`里调用了`PureCommonOperation::handleSignalData`**

![image-20250415161001067](D:\notes\笔记Img\image-20250415161001067.png)

* 点击【执行】后会依次调用接口`/config/:tblName`，回调`setConfig`，将页面上的参数写入表`e_mining_PCOSignalParm_history`。

* 接口`/handerExtSignalParm/:samp_time/:typeId`，回调handleExtSignalData`读取类型9文件进行除干涉提取以外的计算处理。

  ![image-20250415161431325](D:\notes\笔记Img\image-20250415161431325.png)

![image-20250415161517845](D:\notes\笔记Img\image-20250415161517845.png)

![image-20250415161559236](D:\notes\笔记Img\image-20250415161559236.png)

#### 提取图上选项

![image-20250509111846311](D:\notes\笔记Img\image-20250509111846311-1746760727617-1.png)

## （5）分析

### 日报发布

### 日报查询

| -                                    | -                                                            |
| ------------------------------------ | ------------------------------------------------------------ |
| /daily_sheet_dates                   | 获取日报pdf文件文件名的json。                                |
| /post_daily_sheet/:name              | 将日报pdf文件以【年-月-日.pdf】的名称作为参数name，重命名文件，二进制类型，发送到后端。 |
| /daily_sheet/:year/:month/:day/:file | 从服务器获取日报pdf文件。                                    |

前端页面里在代码里拼的url，使用的`daily_sheet`获取的pdf，使用`iframe`打开：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test pdf</title>
</head>

<body>
    <iframe src="../daily_sheet/2022/3/15/DailySheet.pdf" frameborder="0"></iframe>
</body>

</html>
```

# 18. 通道类型

---

| type_id | 数据类型                  | 通道数                              | 通道label           |
| ------- | ------------------------- | ----------------------------------- | ------------------- |
| 0       | 微震采集                  | datachns[2/3/6]                     | dataChnLabel[2/3/6] |
| 1       | 电法采集                  | datachns[0/1]                       | dataChnLabel[0/1]   |
| 2       | 电法发射eeChannel（激电） |                                     |                     |
| 3       | 电磁采集                  |                                     |                     |
| 4       | 温度采集                  | datachns[4]                         |                     |
| 5       | 电法B极                   | datachns[0]+datachns[2]+datachns[4] | dataChnLabel[5]     |
| 6       | 电法N极                   |                                     |                     |

# 19. 接口

---

> 接口名：routes.cpp
>
> 回调函数：commands.cpp，ms_commands

## 接口模板

```cpp
//GET请求 
Routes::Get(RoutesManager::router, "/devices",
              Routes::bind(&cmd::getDevices));

//POST请求 
Routes::Post(RoutesManager::router, "/save_devices",
              Routes::bind(&cmd::saveDevices));

//request解析
if(!request.hasParam(":from_time") || !request.hasParam(":to_time"))//判断参数是否存在
{
  response.send(Http::Code::Bad_Request, "缺少参数：起止时间");
  return;
}
uint64_t fromTime = request.param(":from_time").as<uint64_t>();
uint64_t endTime = request.param(":to_time").as<uint64_t>();

//response相关
response.headers().add<Http::Header::ContentType>(MIME(Text, Plain));//设定response响应头

//发送
response.send(Http::Code::Expectation_Failed, "重算失败");//直接传字符串
string err = "error";
response.send(Http::Code::Expectation_Failed, "重算失败：" + err); //传字符串+string
response.send(Http::Code::Expectation_Failed, err.c_str());//只传string要转char*
```

```cpp
  void getDevices(const Rest::Request &request, Http::ResponseWriter response)
  {
    try
    {
      response.headers().add<Http::Header::ContentType>("application/json");
      //string devices = "{";
      string devices="{\"devices\":[";
      string id;
      string device_ip;
      string device_port;
      string server_port;
      auto iter = hzi::config.devicesMap.begin();
      for (; iter != hzi::config.devicesMap.end(); iter++)
      {
        id = std::to_string(iter->second.id);
        device_ip = iter->second.devIp;
        device_port = std::to_string(iter->second.devPort);
        server_port = std::to_string(iter->second.serverPort);
        std::ostringstream oss;
        oss << "{" << "\"id\":" << id << ",\"device_ip\":\"" << device_ip << "\",\"device_port\":" + device_port + ",\"server_port\":" + server_port + "}";
        string device = oss.str();
        // string device = std::format("{id: {0}, device_ip: {1}, device_port: {2}, device_port: {3}}",id,device_ip,device_port,sever_port);
        devices += device;
        devices += ",";
      }
      devices.pop_back();
      devices += "]}";
      response.send(Http::Code::Ok, devices.c_str());
    }
    catch(const std::exception &e)
    {
      response.send(Http::Code::Bad_Request, e.what());
    }
  }
```

## apifox测试接口

```url
https://192.168.74.37:11507/devices
https://192.168.74.37:11507/save_devices/sys_config.json
```

## 状态码

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | 成功                                                         |
| 405    | 接口的方法类型搞错了。比如一个接口是POST方法，发了GET请求    |
| 204    | 成功响应但是没有返回内容，No Content                         |
| 413    | HTTP 状态码 **413 Content Too Large**（内容过大）表示客户端发送的请求实体超过了服务器定义的大小限制。服务器可能会关闭连接或返回一个 *Retry-After* 头字段 |
| 417    | HTTP 417 错误，即**“Expectation Failed”**                    |
|        |                                                              |



## 接口汇总

| 我写的或修改过的接口                | 功能                                                         | 用法                                              |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| /upload_save_warningImg/:name       | 上传图片并入库                                               | name传图片名称，包括后缀名                        |
| /upload_doc/:mime/:name             | 文件上传：图片，pdf，xlsx，csv，zip                          | mime传后缀名，name传文件名包括后缀名              |
| /download_doc/:mime/:name           | 下载文件：图片，pdf，xlsx，csv，zip                          |                                                   |
| /configFilePath                     | 获取配置文件路径                                             |                                                   |
| /firstChnNO                         | 获取基准通道号                                               |                                                   |
| /devices                            | 获取配置文件中devices字段信息                                |                                                   |
| /update_devices/:jsonName           | 修改配置文件中devices字段信息                                | jsonName传配置文件名，包括etc/                    |
| /semt                               | 用户登录。改了`verifyUser`函数。                             |                                                   |
| /nopswd                             |                                                              |                                                   |
| /warning_recalc/:from_time/:to_time | 预警历史重算：e_warning_info表删除指定时间段内已有预警信息，从e_msevt_rslts中重新筛选记录经过计算入库。 |                                                   |
| /table/:tblName/:delCondition?      |                                                              | 我增加了：function类型，用于传SQL函数作为插入值。 |
|                                     |                                                              |                                                   |

| 接口汇总                                                     | 功能                                                         | 使用方法                                                     | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| MySQL增删改查                                                |                                                              |                                                              |                                                              |
| /update_columns/:tblName/:condition                          | 修改已有记录的字段值                                         |                                                              |                                                              |
| /table/:tblName/:cols/:where?                                | 查询表。                                                     | `table/e_chns_config/chn_label:str,state_id/dev_id=1 and type_id=(select ch_type_id from p_data_types where type_id=6)` | 查询的列，若存在任一列值为null则返回`No_Content`。cols存要查询的列名。**cols若写成`列名:str`，则字段值用字符串形式输出。**where写查询条件。**查询结果**整体方括号，每条记录花括号，若值是字符串用引号包裹：[{"chn_label":"S1GR01","state_id":0},{"chn_label":"S1GR02","state_id":0}] |
| /table/:tblName/:delCondition?                               | 插入（修改）记录或删除记录                                   | delCondition传入true为【删除所有记录】，若传入查询条件则【删除条件筛选】出来的记录；然后再插入。若想不清空表，则delCondition不要填入值。values中传值，schema中传值对应的类型type，有：string,float,double,int64等。传入null时，代码里没有类型没有处理其类型，直接传入会报错，为null的字段不传即可。 | delCondition传"true"则清空表，传其他字符串则会作为删除WHERE后的条件。                                                                                                                                                                                 若payload传json，则会继续执行插入（修改）操作：`schema`字段为数组`{"schema":[ {"name":"mining_date", "type":"string"}, {"name":"mining_locx", "type":"float"}, {"name":"day_step", "type":"float"}],"values":[["2025-04-27 00:00:00.0000", 1300, 10],["2025-04-28 00:00:00.0000", 1300, 11]]}`，传表所有字段名`name`和类型`type`（string，float，double，int64）；`values`传字段的对应值。注意：datetime类型字段，后台没专门写，type写string。我增加了：function类型，用于传SQL函数作为插入值。 |
|                                                              |                                                              |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
| /setHeadingMil/:typeId/:isWarning                            | 修改偏移距                                                   |                                                              |                                                              |
| /config/:tblName                                             |                                                              |                                                              | 根据传入json的`is_init`字段：为true时，先删除指定表中`is_init==1`的记录。为false时，先`TURNCATE`清空表。最后，把记录值`INSERT`插入表，is_init置1。 |
| /handerSignal/:from_time/:to_time/:time_len/:devId           | 历史计算                                                     |                                                              |                                                              |
| /handerSignalMining/:from_time/:to_time/:time_len/:devId     | 历史计算（mining？）                                         |                                                              |                                                              |
| /download/:from_time/:to_time/:is_csv/:file_name             | 选中时间段内原始数据（根据hzi::mining_classId决定类型3/6）拼帧并打包为zip下载 | is_csv=0-bin文件/1-csv文件/2-qfx文件。file_name未用。        |                                                              |
| /download/:type_id/:from_time/:to_time/:is_csv/:file_name/:only_ms_valid? |                                                              |                                                              |                                                              |
| /samp_conf/:tblName/:itmNames/:fromInit?                     |                                                              |                                                              |                                                              |
| /daily_sheet/:year/:month/:day/:file                         | 从data_root下获取文件                                        |                                                              |                                                              |
| /daily_sheet_dates                                           | 以json形式返回data_root下的年月日的pdf文件，文件名类似2025-5-1.pdf。json形式是年字段下数组为月数组，月数组下为日字段对应文件的路径。 |                                                              |                                                              |
| /post_daily_sheet/:name                                      |                                                              |                                                              |                                                              |
| /data_file/:year/:month/:day/:type/:timestamp                |                                                              |                                                              |                                                              |
| /handerExtSignal/:samp_time/:typeId                          | 回调：`handerExtSignal`，回调调用`processMethods`，这个函数。使用提取信号再次进行后续的再提取和偏移。 |                                                              |                                                              |
| /handerExtSignalParm/:samp_time/:typeId                      | 回调：`handerExtSignalParm`，回调调用`handleExtSignalData`   |                                                              |                                                              |
| /handerExtSignalPianYi/:from_time/:to_time                   | 用指定时间段的提取文件（9），调用saveResult()生成偏移文件（10） |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
| **日报**                                                     |                                                              |                                                              |                                                              |
| /daily_sheet_dates                                           | 获取日报pdf文件文件名的json。                                |                                                              | 遍历`data_root`下所有目录（看作年份目录），再遍历年份目录下的目录（看作月份目录），再遍历月份目录下的目录（看作日目录），将年-月-日.pdf作为文件名。最后将年，月，日写为json的树状结构，日作为字段，文件名作为值。json字符串发送给前端。json形如：`{2025: {5: {1: "2025-5-1.pdf", 2: "2025-5-2.pdf"}}}` |
| /post_daily_sheet/:name                                      | 将日报pdf文件以【年-月-日.pdf】的名称作为参数name，重命名文件，二进制类型，发送到后端。 |                                                              |                                                              |
| /daily_sheet/:year/:month/:day/:file                         | 从服务器获取日报pdf文件。                                    |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
| /ms_mining                                                   | 无随采返回false，有随采返回true                              |                                                              |                                                              |
| /latest/:type/:lastTime                                      | 查询表`e_data_frm_info`中，lastTime时间之后最新的记录的对应的文件。若lastTime传0，则直接返回最新的一条。 |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |





# 20. 数据库

---

> * 使用开源库`libzdb`
>
> * 凡是查表，一定要考虑表为空的情况，增加查不到记录时的边界条件判断，增加软件健壮性。
>
> ```cpp
> Connection conn = hzi::config.pConnPool->getConnection();
> ```

> [!NOTE]
>
> ```cpp
> auto rslt = conn.executeQuery(
>     "SELECT mining_locx,mining_dir,mark_XLen,"
>     "dXGrdLen,dYGrdLen,dZGrdLen,UNIX_TIMESTAMP(mining_date)AS tm ,day_step"
>     " FROM `e_mining_PCOLocParm`  ORDER BY mining_date DESC "
>     "LIMIT 1");
> auto rslt2 = conn.executeQuery("SELECT `mining_loc`,`day_step` FROM e_tunnel_locInfo ORDER BY tmstamp DESC LIMIT 1");
> if (rslt.next())
> {
>     //这里
> }
> ```
>
> 

## 查询

```cpp
//zdbpp.h
int columnCount() {
    return ResultSet_getColumnCount(t_);
}

const char *columnName(int columnIndex) {
    except_wrapper( RETURN ResultSet_getColumnName(t_, columnIndex) );
}

long columnSize(int columnIndex) {
    except_wrapper( RETURN ResultSet_getColumnSize(t_, columnIndex) );
}

void setFetchSize(int prefetch_rows) {
    ResultSet_setFetchSize(t_, prefetch_rows);
}

int getFetchSize() {
    return ResultSet_getFetchSize(t_);
}

bool next() {
    except_wrapper( RETURN ResultSet_next(t_) );
}

bool isnull(int columnIndex) {
    except_wrapper( RETURN ResultSet_isnull(t_, columnIndex) );
}

const char *getString(int columnIndex) {
    except_wrapper( RETURN ResultSet_getString(t_, columnIndex) );
}

const char *getString(const char *columnName) {
    except_wrapper( RETURN ResultSet_getStringByName(t_, columnName) );
}

int getInt(int columnIndex) {
    except_wrapper( RETURN ResultSet_getInt(t_, columnIndex) );
}

int getInt(const char *columnName) {
    except_wrapper( RETURN ResultSet_getIntByName(t_, columnName) );
}

long long getLLong(int columnIndex) {
    except_wrapper( RETURN ResultSet_getLLong(t_, columnIndex) );
}

long long getLLong(const char *columnName) {
    except_wrapper( RETURN ResultSet_getLLongByName(t_, columnName) );
}

double getDouble(int columnIndex) {
    except_wrapper( RETURN ResultSet_getDouble(t_, columnIndex) );
}

double getDouble(const char *columnName) {
    except_wrapper( RETURN ResultSet_getDoubleByName(t_, columnName) );
}

template <typename T>
std::tuple<const void*, int> getBlob(T v) {
    int size = 0;
    const void *blob = nullptr;
    if constexpr (std::is_integral<T>::value)
        except_wrapper( blob = ResultSet_getBlob(t_, v, &size) );
    else
        except_wrapper( blob = ResultSet_getBlobByName(t_, v, &size) );
    return {blob, size};
}

//返回时间戳，（time_t是时间戳epoch到现在的seconds)
time_t getTimestamp(int columnIndex) {
    except_wrapper( RETURN ResultSet_getTimestamp(t_, columnIndex) );
}

time_t getTimestamp(const char *columnName) {
    except_wrapper( RETURN ResultSet_getTimestampByName(t_, columnName) );
}

//返回datetime，（tm是结构体存有年月日时分秒）
struct tm getDateTime(int columnIndex) {
    except_wrapper( RETURN ResultSet_getDateTime(t_, columnIndex) );
}

struct tm getDateTime(const char *columnName) {
    except_wrapper( RETURN ResultSet_getDateTimeByName(t_, columnName) );
}

struct tm
{
    int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
    int tm_min;			/* Minutes.	[0-59] */
    int tm_hour;			/* Hours.	[0-23] */
    int tm_mday;			/* Day.		[1-31] */
    int tm_mon;			/* Month.	[0-11] */
    int tm_year;			/* Year	- 1900.  */
    int tm_wday;			/* Day of week.	[0-6] */
    int tm_yday;			/* Days in year.[0-365]	*/
    int tm_isdst;			/* DST.		[-1/0/1]*/

    # ifdef	__USE_MISC
    long int tm_gmtoff;		/* Seconds east of UTC.  */
    const char *tm_zone;		/* Timezone abbreviation.  */
    # else
    long int __tm_gmtoff;		/* Seconds east of UTC.  */
    const char *__tm_zone;	/* Timezone abbreviation.  */
    # endif
};
```

```cpp
string sqlQuery="";
Connection conn = hzi::config.pConnPool->getConnection();
ResultSet rslt = conn.executeQuery(sqlQuery.c_str(),val,val,val);
if(!rslt)
{
    cout<<"查询结果为空"<<endl;
}
//或是直接写字符串
auto rslt = conn.executeQuery("",val,val,val);
if(!rslt)
{
    cout<<"查询结果为空"<<endl;
}

//常用获取字段函数
rslt.getInt("field");
rslt.getDouble("field");
rslt.getString("field");

//封装executeQuery
template <typename... Args>
tl::expected<ResultSet, std::string> queryDb(Connection &conn, const char *sql, Args... args) 
{
  try 
  {
    ResultSet result = conn.executeQuery(sql, args...);
    if (result.next()) 
    {
      return result;
    } 
    else 
    {
      return tl::make_unexpected("not found in query: " + std::string(sql));
    }
  } 
  catch (zdb::sql_exception &e) 
  {
    return tl::make_unexpected("sql error for " + std::string(sql) + ": " + std::string(e.what()));
  }
}
bool ret = queryDb(conn,"SELECT * FROM e_users where user_name=? and password=PASSWORD(?)",user, pswd)?true:false;

queryDb(conn, sql.c_str()) 
    .map([&](ResultSet set)
     {
         
     }
    .map_error([&](auto err)
     {
         
     }
```

```cpp
//查询有记录则返回，否则返回字符串异常
template <typename... Args>
tl::expected<ResultSet, std::string> queryDb(Connection &conn, const char *sql, Args... args) 
{
  try 
  {
    ResultSet result = conn.executeQuery(sql, args...);
    if (result.next()) 
    {
      return result;
    } 
    else 
    {
      return tl::make_unexpected("not found in query: " + std::string(sql));
    }
  } 
  catch (zdb::sql_exception& e) //sql_exception定义在zdbpp.h中
  {
    return tl::make_unexpected("sql error for " + std::string(sql) + ": " + std::string(e.what()));
  }
  catch (std::exception& e) 
  {
    return tl::make_unexpected(std::string(e.what()));
  }
}
```

```cpp
//方法的作用是检查指定列索引的值是否为 SQL 空值（NULL）。如果该列的值为 NULL，则返回 true；否则返回 false
//columnIndex从1开始
bool ResultSet::isnull(int columnIndex);

//下一条记录
bool ResultSet::next();

const char* ResultSet::getString(int columnIndex);//columnIndex从1开始
const char* ResultSet::getString(const char* columnName);
```



## 插入/删/改（若存在则更新）

> [!NOTE]
>
> * INSERT 和 UPDATE 触发器都可能被触发
>
> * **自增ID**：即使执行的是 UPDATE，自增ID也会增加
>
> * `ON DUPLICATE KEY UPDATE`语句中：
>
>     **明确列在 `UPDATE` 部分的字段**：会被更新为新值（使用 `VALUES(column_name)` 或指定的值）
>
>   **未列在 `UPDATE` 部分的字段**：会保持原来的值不变

```cpp
string sql = "INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)";
conn.execute(sql.c_str(), val,val,val);

//或
conn.execute("INSERT INTO  "
" e_tunnel_model_info "
"(label_1,label_2,label_3,label_4,label_5,ratio,is_init) "
" values(?,?,?,?,?,?,?) "
" ON DUPLICATE KEY UPDATE label_1 = values(label_1),"
"label_2 = values(label_2),label_3 = values(label_3),"
"label_4 = values(label_4),label_5 = values(label_5),ratio = "
"values(ratio)", val1,val2,val3,val4,val5,val6,val7);
```

## 存储过程

```cpp
//prepareStatement的sql语句需要直接在括号内写字符串，不能先定义为string再传值
Connection conn = hzi::config.pConnPool->getConnection();
PreparedStatement prp = conn.prepareStatement("INSERT INTO e_tunnel_locInfo (mining_loc,tmstamp) values(?,?) ON DUPLICATE KEY UPDATE tmstamp = values(tmstamp)");
conn.beginTransaction();
prp.bind(1, mining_locx);
prp.bind(2, (double)tmstamp);//时间戳转成double再存
prp.execute();
conn.commit();
```

```cpp
function "zdb::PreparedStatement::bind(int, int)" (declared at line 394)
function "zdb::PreparedStatement::bind(int, long long)" (declared at line 398)
function "zdb::PreparedStatement::bind(int, double)" (declared at line 402)
function "zdb::PreparedStatement::bind(int, time_t)" (declared at line 406)
```

## 表更新

```cpp
//where?表示where可选，可不传值
//SELECT [cols冒号左侧为字段名field1,field2,...] FROM [tblName] [where];
//response：{"code":0,"data":[{"field1":"field1Val"},{"field2":"field2Val"},...]}
Routes::Get(RoutesManager::router, "/table/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData));//表查询
Routes::Get(RoutesManager::router, "/table1/:tblName/:cols/:where?",
              Routes::bind(&cmd::queryTblData1));//queryTblData1用的是pTempConnPool
```

```cpp
//UPDATE tblName set [请求体updates字段值] where [condition]
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));

//
Routes::Post(RoutesManager::router, "/update/:tblName/:refCol/:updateCol",
               Routes::bind(&cmd::updateColumnRef));

//delCondition传true：delete from [tblName]
//传where语句：delete from [tblName] where ...
//若请求体中有schema和values，遍历json数组schema获取要更新的字段名，遍历json数组value获取要更新的字段的值。请求体中还应有type，指明字段值的类型是string/float/double/int64：insert into [tblName] (field1, field2,...)values('value11','value12',...),('value21','value22',...) on duplicate key update field1=values(value1),field2=values(value2)...;插入多条记录，若有主键相同的记录改为update修改(on duplicate key)
Routes::Post(RoutesManager::router, "/table/:tblName/:delCondition?",
               Routes::bind(&cmd::updateTable));//表增删改


//UPDATE [tblName] set [请求体updates字段值] where [condition].
Routes::Post(RoutesManager::router, "/update_columns/:tblName/:condition",
               Routes::bind(&cmd::updateColumns));
```

* `response.headers().add<Http::Header::ContentType>("text/plain; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `text/plain`。这表示服务器返回的内容是纯文本格式
* `response.headers().add<Http::Header::ContentType>("application/json; charset='utf-8'");` 这行代码的作用是向HTTP响应头中添加一个 `Content-Type` 字段，并将其值设置为 `application/json; charset='utf-8'`。这表示服务器返回的内容是JSON格式，并且使用UTF-8字符集进行编码。

## 上传图片

```cpp
Routes::Post(RoutesManager::router, "/upload_image/:name",
               Routes::bind(&cmd::uploadImage));

void uploadImage(const Rest::Request &request, Http::ResponseWriter response) {
  response.headers().add<Http::Header::ContentType>(
      "text/plain; charset='utf-8'");
  string name = request.param(":name").as<string>();
  if (request.body().empty() || name == "undefined") {
    response.send(Http::Code::No_Content, "没有传入图片！");
    return;
  } // 理论上，严谨的写法，还需要判断传入的 MIME type 是不是图片

  try {
    string path = "assets/images/" + name;
    std::ofstream fout(path);
    fout.write(request.body().data(), request.body().size());
    fout.close();
  } catch (std::exception &e) {
    string reason = "图片 " + name + " 写入目录错误：" + e.what();
    logErr(reason);
    response.send(Http::Code::Expectation_Failed, reason);
    return;
  }
  response.send(Http::Code::Ok, "图片 " + name + " 上传成功！");
}
```

## 上传数据文件

```cpp
Routes::Post(RoutesManager::router, "/upload_DateFile/:name",
               Routes::bind(&ms_comm::uploadDateFile));


void uploadDateFile(const Rest::Request &request,
                    Http::ResponseWriter response) {
  if (request.body().empty()) {
    response.send(Http::Code::No_Content, "The request body is empty");
    return;
  }
  string name = request.param(":name").as<string>();
  cout << " name = " << name << endl;
  try {
    if (0) {
      //电法反演数据处理
      string fileName2 = "test/1111.dat";
      std::ifstream dat_data("test/1111.dat", std::ios::in);
      string line_dat;

      if (!dat_data.is_open()) {
        return;
      }

      char deli = (fileName2.find(".dat") != std::string::npos) ? '\t' : ',';

      std::vector<string> words_dat; // 声明一个字符串向量
      std::vector<vector<float>> dataVec;

      // 读取数据
      while (std::getline(dat_data, line_dat)) {
        words_dat.clear();
        split_String(line_dat, deli, words_dat);
        //  cout<<" words_dat.size() = "<<words_dat.size()<<endl;
        if (words_dat.size() == 4) {
          vector<float> tmpData;
          tmpData.push_back(atof(words_dat[0].c_str()));
          tmpData.push_back(atof(words_dat[1].c_str()));
          tmpData.push_back(atof(words_dat[2].c_str()) - 720);
          tmpData.push_back(atof(words_dat[3].c_str()));
          dataVec.push_back(tmpData);
          // cout<<atof(words_dat[0].c_str())<<","
          //     <<atof(words_dat[1].c_str())<<","
          //     <<atof(words_dat[2].c_str())<<","
          //     <<atof(words_dat[3].c_str())<<endl;
        }
      }

      float dx = 5;
      float dy = 4;
      float dz = 20;
      float max_x, min_x, max_y, min_y, max_z, min_z;
      max_x = 960;
      min_x = 0;
      max_y = 510;
      min_y = 0;
      max_z = -575;
      min_z = -820;

      int xSize = int((max_x - min_x) / dx);
      int ySize = int((max_y - min_y) / dy);
      int zSize = int((max_z - min_z) / dz);
      cout << " size = " << dataVec.size() << " ," << xSize << " ," << ySize
           << "," << zSize << endl;
      //初始化网格
      vector<vector<vector<GridCell>>> grid;
      initializeGrid(grid, xSize, ySize, zSize);

      for (int i = 0; i < dataVec.size(); i++) {
        auto x = dataVec[i][0];
        auto y = dataVec[i][1];
        auto z = dataVec[i][2];
        auto p = dataVec[i][3];
        int x_index = int((x - min_x) / dx);
        int y_index = int((y - min_y) / dy);
        int z_index = int((z - min_z) / dz);
        // cout<<x_index<<" ,"<<y_index<<","<<z_index<<" ,"
        //     <<x_index<<" ,"<<y_index<<","<<z_index<<endl;
        GridCell cell;
        cell.hasValue = true;
        cell.value = p;
        cell.r = 1;
        cell.intersectValues.push_back(p);
        grid[x_index][y_index][z_index] = cell;
      }

      //克里金插值
      debugLog(" start applyKrigingInterpolation");
      int variogramType = 0; // 0 表示球状模型。1 表示指数模型。2 表示高斯模型。
      applyKrigingInterpolation(grid, xSize, ySize, zSize, variogramType);
      debugLog(" end applyKrigingInterpolation");

      // 2023-12-18 4:00:00
      uint64_t fromsampTime = 1702843200000;
      //保存结果
      auto classId = 30;
      int file_type = 3;
      int constSize = 16; // x,y,z,p 16字节
      unique_ptr<char[]> pHeadData = std::make_unique<char[]>(64);
      char *pHead = pHeadData.get();
      *(double *)(pHead) = (double)fromsampTime;
      *(uint16_t *)(pHead + 8) = constSize; //

      fs::path fileName(hzi::config.dataRoot);

      fileName /= relLocFromTime(fromsampTime) / std::to_string(classId) /
                  std::to_string(fromsampTime) / std::to_string(file_type);
      auto dir = fileName.parent_path();
      if (!fs::exists(dir)) {
        fs::create_directories(dir);
      }
      std::ofstream ofs(fileName, std::ofstream::binary);
      ofs.write(pHead, 64);
      for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
          for (int k = 0; k < zSize; ++k) {
            if (!grid[i][j][k].hasValue)
              continue;
            float x = min_x + i * dx + dx / 2.0;
            float y = min_y + j * dy + dy / 2.0;
            float z = min_z + k * dz + dy / 2.0;

            unique_ptr<char[]> pGridData = std::make_unique<char[]>(constSize);
            char *pGrid = pGridData.get();
            *(uint32_t *)(pGrid) = *((int32_t *)&x);
            *(uint32_t *)(pGrid + 4) = *((int32_t *)&y);
            *(uint32_t *)(pGrid + 8) = *((int32_t *)&z);
            *(uint32_t *)(pGrid + 12) = *((int32_t *)&grid[i][j][k].value);
            //   cout<<x<<","<<y<<","<<z<<","<<grid[i][j][k].value<<endl;
            ofs.write(pGrid, constSize);
          }
        }
      }

      ofs.close();
      cout << "OK" << endl;
      autoHandleData(fromsampTime);
      response.send(Http::Code::Ok, "OK");
      return;
    }

    // Read the request body (the CSV file) into a stringstream

    // std::ifstream csv_data("test/GathEP-X.csv", std::ios::in);
    // string line;
    // if (!csv_data.is_open())
    // {
    //       return;
    // }

    std::stringstream csv_data(request.body().data());

    std::string line;

    std::vector<string> words; // 声明一个字符串向量
    string word;
    string fileHead;
    // 读取标题行
    std::getline(csv_data, fileHead);
    split_String(fileHead, ',', words);
    int chns = 0;
    int points = 0;
    float deltT = 0;
    int prepoint = 0;
    cout << " 1 fileHead = " << fileHead << endl;
    if (words.size() >= 4) {
      chns = atoi(words[0].c_str());
      points = atoi(words[1].c_str());
      deltT = atof(words[2].c_str());
      prepoint = atoi(words[3].c_str());
    }
    cout << " chns = " << chns << " points = " << points << " deltT = " << deltT
         << " prepoint = " << prepoint << endl;

    float **pData = new float *[chns];
    for (int ch = 0; ch < chns; ++ch) {
      pData[ch] = new float[points];
    }
    int index = 0;
    // 读取数据
    while (std::getline(csv_data, line)) {
      words.clear();
      split_String(line, ',', words);
      if (words.size() >= chns) {
        for (int ch = 0; ch < chns; ++ch) {
          pData[ch][index] = atof(words[ch].c_str());
          // if(index < 3){
          //     cout<<pData[ch][index]<<"  ";
          // }
        }
      }
      //  if(index < 3)cout<<endl;
      index++;
    }
    //写入微震事件
    if (0) {
      // unique_ptr<char[]> pHeadData = std::make_unique<char[]>(32);
      // char* pHead = pHeadData.get();
      const float voltageCoef = 3000.0 / 8388607.0;
      // for (int ch = 0; ch < chns; ++ch) {
      //   for(int pnt = 0;pnt <points;pnt++){
      //     pData[ch][pnt] /= voltageCoef;
      //   }
      // }
      cout << " -- 101 --" << chns << "," << points << endl;
      DataFrame msDf(chns, points);
      cout << " -- 1 --" << endl;
      auto tm = nowMS();
      msDf.setSampTime(tm);
      cout << " -- 2 --" << endl;
      msDf.addDevMask(1);
      cout << " -- 3 --" << endl;
      msDf.setDevMask();
      cout << " -- 4 --" << endl;
      msDf.setClassId(2);
      cout << " -- 5 --" << endl;
      msDf.setHeadValue(19, deltT);
      cout << " -- 61 --" << endl;
      int32_t *p32 = reinterpret_cast<int32_t *>(msDf.upData.get());
      for (int ch = 0; ch < chns; ++ch) {
        for (int pt = 0; pt < points; ++pt) {
          float value = pData[ch][pt];
          int32_t originalValue = static_cast<int32_t>(value * 8388607.0 / 3.0);
          p32[ch * points + pt] = originalValue;
        }
        // std::memcpy(msDf.upData.get() + ch * points * sizeof(float),
        // pData[ch], points * sizeof(float));
      }
      msDf.save();
      //   for (int i = 0; i < 10; ++i) {
      //     std::cout << p32[i] << " ";
      // }
      response.send(Http::Code::Ok, "OK");
      return;
    }

    logInfo("start handleSignalProcess_test");
    // string filepath =
    //     test_mining(pData, points, chns, deltT, prepoint);
    string filepath =
        handleSignalProcess_test(pData, points, chns, deltT, prepoint);
    logInfo(filepath);
    string rslt("{");
    rslt += "\"ms_miningSignal\": \"";
    rslt += std::to_string(hzi::config.ms_miningSignal);
    rslt += "\",";
    rslt += " \"tm\": \"";
    rslt += filepath;
    rslt += "\" } ";
    response.headers().add<Http::Header::ContentType>(
        "application/json; charset='utf-8'");
    // cout << " rslt = " << rslt << endl;

    response.send(Http::Code::Ok, rslt);
    // std::thread(test_scan).detach();
    //  fs::path peerPath(filepath);
    //  if (fs::exists(peerPath)) {
    //      Http::serveFile(response, peerPath.c_str());
    //  } else {
    //      response.send(Http::Code::No_Content, "no_content");
    //  }
    logInfo("endl handleSignalProcess");

  } catch (std::exception &e) {
    logErr(e.what());
    response.send(Http::Code::Expectation_Failed, " uploaded failed!");
    return;
  }
  // response.send(Http::Code::Ok, " uploaded successfully!");
}

```

```cpp
{
    "devices": [
        {
            "id": 1,
            "device_ip": "192.168.70.131",
            "device_port": 5021,
            "server_port": 5021
        }
    ],
    "serve_for": "semt",
    "http_port": 11504,
    "realtime_interval": 5,
    "link_device": false,
    "time_sync": false,
    "timesync_interval": 20,
    "ms_rate": 0.8,
    "ms_locating": true,
    "ms_experimental": false,
    "ms_grid_step": 0.1,
    "ms_mining": false,
    "ms_miningSignal": false,
    "save_full_msdata": false,
    "ms_tunnel": false,
    "warningType": 1,
    "ms_interface_type": 1,
    "ms_mining_type": 0,
    "digest_duration": 5,
    "optical_strain": false,
    "mysql_url": "mysql://192.168.74.113:3308/semtdb1?user=hzidba&password=dzaqZHk3",
    "data_root": "/home/yzheng/workspace/yuanqu"
}
```

## 变量与表对应

| 变量                                           | 表名                                                 | 说明 |
| ---------------------------------------------- | ---------------------------------------------------- | ---- |
| hzi::viewSpace                                 | e_space                                              |      |
| hzi::densityGrays                              | p_density_grays                                      |      |
| hzi::densityColors                             | p_density_colors                                     |      |
| hzi::msEvtCnf.sampIntvl                        | p_samp_intvls                                        |      |
| hzi::msEvtCnf.msAheadPnt                       | p_points                                             |      |
| hzi::msEvtCnf.pulsWid，hzi::msEvtCnf.ringThrld | e_ms_samp_config                                     |      |
| hzi::msEvtCnf.msThrldsMap                      | e_chns_config（chn_label，ms_trig_thrld,is_ms_trig） |      |
| hzi::viewSpace                                 | e_speed                                              |      |
| hzi::viewSpace.vtispeed_vector                 | e_vti_speeds                                         |      |
| hzi::chnState                                  | e_chns_config（chn_label, state_id）                 |      |
|                                                |                                                      |      |

## 表说明

| 表名                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
|                                |                                                              |
| **参数配置**                   |                                                              |
| e_send_frm_log                 | 服务器向设备发送的命令的日志                                 |
| e_station_info                 | 基站监测，【基站检测应答帧】参数入库                         |
| e_dev_clock                    | 时间校准，【时间校准应答帧】参数入库                         |
| e_dev_config_ack               | 参数配置，【参数配置应答帧】参数入库                         |
| e_users                        | 用户名，密码                                                 |
| e_space                        | 系统-工程参数-空间参数（设定这张表中所存参数：**原点坐标/巷道xyz的范围/网格宽度**等坐标常数）。数据计算时，`getPCO_parm`函数查出存到`PureCommonOperation::PCOLocParm`变量里。 |
| e_info                         | 系统-工程参数-工程参数                                       |
| p_data_types                   | 数据类型编号说明type_id                                      |
| p_chn_types                    | 通道类型和type_id，label对应关系                             |
| e_tunnel_cur_status            | 存储【掘进位置】【偏移距】【超前距离】【back_distance】【forward_distance】等巷道参数 |
|                                |                                                              |
| e_chns_config_tunnel           | 通道的配置等参数。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn` |
| e_chns_config                  | **用户输入的通道信息**。比如坐标。                           |
| e_chns_config_history          | **通道的历史信息（因为通道会移动，坐标也会改变，而历史计算需要历史的通道的数据）**。通道更新`e_chns_config`时触发器会自动更新该表。代码中用到该表都是查询。计算时，查询到通道坐标，保存到`PureCommonOperation::PCOCalChn`变量。 |
|                                |                                                              |
| e_tunnel_serverInfo            | 服务器的ip和port                                             |
| e_tunnel_model_info            |                                                              |
|                                |                                                              |
| e_ms_samp_config               | 保存【采集置参->微震采集参数】修改                           |
| p_samp_intvls                  | 【采样间隔，id】，`for_ms`表示该间隔是否可用于微震           |
| p_points                       | 【采样点数，id】或【超前点数，id】                           |
| p_ms_trigs                     | 【触发方式，id】                                             |
| p_time_wins                    | 【时窗id，时窗值(ms)】，`for_ms_bg`——是否可用于微震背景检测，`for_ms_up`——微震背景上传 |
|                                |                                                              |
|                                |                                                              |
|                                |                                                              |
| **干涉提取**                   |                                                              |
| e_data_frm_info                | **原始数据。**类型class_id，数据文件路径frm_loc。            |
| e_mining_signaldata_frm_info   | 9类型数据，提取图数据                                        |
| e_mining_pcodata_frm_info      | 10类型数据，偏移图数据                                       |
| e_mining_PCOSignalParm         | **实时计算参数，信号处理页面上设定的参数值。**`getPCO_parm`函数负责查表获得这些参数，放到 `PureCommonOperation::PCOSignalParm`变量和`PureCommonOperation::PCOLocParm`变量中，flag=1实时。 |
| e_mining_PCOSignalParm_history | **历史计算参数，信号处理页面上设定的参数值。**参与计算的数据类型class_id（历史默认6）等。flag=0历史。 |
| e_mining_PCOLocParm            | **实时/历史计算，坐标等参数值。回采位置/回采方向/日进尺/回采位置更新日期**等参数。存到`PureCommonOperation::PCOLocParm`变量中。 |
| e_tunnel_locinfo               | 回采位置/回采位置对应时间戳/日进尺。这3个参数若有，则覆盖掉表`e_mining_PCOLocParm`查询的数据。 |
| e_chn_types                    | 当前使用的通道的设备/编号/类型：0-微震采集，1-电法采集，2-电法发射，3-电磁采集，4-温度采集，5-电法B极，6-电法N极 |
| e_chns_config_history          | 从中读取通道历史信息参与历史计算                             |
|                                |                                                              |
|                                |                                                              |
| **偏移**                       |                                                              |
|                                |                                                              |
| **回采位置**                   |                                                              |
| e_tunnel_cur_status            | 当前回采位置，偏移距，基准通道。实时，历史都会更新到这。     |
| e_mining_locx_history          | 记录回采位置被修改时的历史。                                 |
|                                |                                                              |
|                                |                                                              |
| e_data_digest                  |                                                              |
|                                |                                                              |
| e_geology_info                 | 岩性，p波s波速度                                             |
|                                |                                                              |
| **界面提取**                   |                                                              |
| e_tunnel_line_info             | 界面提取，保存从偏移图中提取的：起始点坐标，终止点坐标，与横轴夹角等信息。 |
| e_tunnel_error_info            | 保存对`e_tunnel_line_info`进行【聚类】算法后，得到的【地质异常】（即地质分层） |
|                                |                                                              |
|                                |                                                              |
|                                |                                                              |
| **预警**                       |                                                              |
| e_warningInfo_parm             | 判定大能量事件次数的能量阈值等，判定算作这5个参数的值增加的阈值（msFrequency 微震频次，highEnergyNum 大能量事件，msLocation 定位，e_sp_variation 自电变化量，ee_p_variation 视电阻率变化量） |
| e_msevt_rslts                  | 记录了所有的微震事件。用于查询时间范围的微震事件，与`e_warningInfo_parm`中的阈值进行比较，计算出5个参数的值。用于和阈值比较判断预警事件等级。 |
| e_warning_level_value          | 5个预警参数判定等级的阈值，红/橙/蓝                          |
| e_warning_info                 | 记录微震预警事件。时间，等级（类型：蓝橙红），是否已发送，是否已处理 |
|                                |                                                              |
| **随采**                       |                                                              |
| e_mining_surveyLines           |                                                              |
|                                |                                                              |

# 21. 登录

---

## （1）验证用户名密码

>  表`e_users`中存的`password`就只是`PASSWORD(password)`

```cpp
//commands.cpp
//body传plain/text，形如：【username=admin&password=Hzi12345!】
void login(const Rest::Request &request, Http::ResponseWriter response)
{}
    
//login中调用的verifyUser重载是下面的：用于分别验证用户名和密码。
//user和pswd都是传明文
bool verifyUser(string user, string pswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  auto ret = queryDb(conn, "SELECT * FROM e_users where user_name=? and password=PASSWORD(?)", user, pswd)
                 ? true : false;
  return ret;
}
```

```cpp
//接口
Routes::Post(RoutesManager::router, "/auth_user", Routes::bind(&cmd::authUser));

void authUser(const Rest::Request &request, Http::ResponseWriter response)
{
  Document bodyDoc;
  if (bodyDoc.Parse(request.body().c_str()).HasParseError())
  {
    response.send(Http::Code::Bad_Request, "用户认证格式错");
  }
  string userPswd = bodyDoc["user_pswd"].GetString();
  response.headers().add<Http::Header::ContentType>("text/plain");
  verifyUser(userPswd)
      .map([&](auto r)	{ response.send(Http::Code::Ok, "user_verified:ok"); })
      .map_error([&](auto err)	{ response.send(Http::Code::Unauthorized, "user_verified:failed"); });
}


//authUser调用的verifyUser重载是下面的：
//传入参数userPswd是：形如【user:password】这样的字符串，再base64编码后的字符串。
tl::expected<int, string> verifyUser(string userPswd)
{
  auto conn = hzi::config.pConnPool->getConnection();
  //SELECT FROM_BASE64(?)解码base64
  return queryDb(conn, "SELECT FROM_BASE64(?) as user", userPswd.c_str())
      .and_then([&](ResultSet userPsw) -> tl::expected<int, string>
                {
    				auto user = string(userPsw.getString("user"));
    				auto colonPos = user.find(":");
    				if (colonPos != string::npos) 
                    {
    				  auto userName = user.substr(0, colonPos);
    				  auto psw = user.substr(colonPos + 1);
                        //PASSWORD()为MySQL中自带函数，用于对密码进行单向加密，生成的加密字符串无法直接还原为原始密码，主要用于安全存储密码。
    				  return queryDb(conn,
    				                 "SELECT * FROM e_users where user_name=? and "
    				                 "password=PASSWORD(?)",
    				                 userName, psw)
    				      .and_then([&](auto r) { return tl::expected<int, string>(0); });
    				} 
                })
      .or_else([&](auto e) -> tl::expected<int, string>
               {
    			cout << "error:" << e << "\n";
    			return tl::make_unexpected(string("error verifying user:") + e); 
               });
}
```

## （2）修改密码

```cpp
//接口
Routes::Post(RoutesManager::router, "/password/:user/:pswd", Routes::bind(&cmd::changePswd));

void changePswd(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":user").as<string>();
  auto pswd = request.param(":pswd").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  try
  {
    conn.execute("UPDATE e_users set password=PASSWORD(?) where user_name=?",
                 pswd, userName);
    response.send(Http::Code::Ok, "ok");
  }
  catch (zdb::sql_exception &err)
  {
    response.send(Http::Code::Bad_Request, err.what());
  }
  // conn.close();
}
```

## （3）用户是否存在

```cpp
//接口
Routes::Get(RoutesManager::router, "/users/:name", Routes::bind(&cmd::userExists));

void userExists(const Rest::Request &request, Http::ResponseWriter response)
{
  auto userName = request.param(":name").as<string>();
  auto conn = hzi::config.pConnPool->getConnection();
  queryDb(conn, "SELECT * from e_users where user_name=?", userName.c_str())
      .map([&](auto r)
           { response.send(Http::Code::Ok, "ok"); })
      .map_error([&](auto err)
                 {
      if (err.find("not found") != string::npos) {
        response.send(Http::Code::Not_Found, "not found");
      } else {
        response.send(Http::Code::Bad_Request, err);
      } });
  // conn.close();
}
```

# 23.日志

---

```bash
./aaa会在终端显示实时日志
nohup ./aaa &就是在后台启动，日志就在nohup.out
```

```cpp
void logInfo(string const &info) {
    std::cout << timeStr(std::chrono::system_clock::now()) << " " << info
        << std::endl;
}
void logInfo(const std::vector<string> &infos) {
    std::cout << timeStr(std::chrono::system_clock::now()) << " ";
    for (int i = 0; i < infos.size(); i++) {
        std::cout << infos[i];
    }
    std::cout << std::endl;
}
void logErr(string const &info) {
    std::cerr << timeStr(std::chrono::system_clock::now()) << " " << info
        << std::endl;
}
void logErr(const std::vector<string> &infos) {
    std::cerr << timeStr(std::chrono::system_clock::now()) << " ";
    for (int i = 0; i < infos.size(); i++) {
        std::cerr << infos[i];
    }
    std::cerr << std::endl;
}
```

![日志路径](D:\notes\笔记Img\日志路径.png)

# 24. 上传文件发送文件

---

## （1）文件指定格式上传/下载

> * 发送文件到前端，通过字节流：
>
>   ```cpp
>   //依赖库pistache
>   auto stream = response.stream(Http::Code::Ok);
>   while(ifs.gcount() > 0)
>   {
>       stream.write(bufTmpPtr, ifs.gcount());
>       stream << flush;
>       ifs.read(bufTmpPtr, fileSize);
>   }
>   ifs.close();
>   stream << ends;
>   ```
>
> * 发送文件到前端，通过`serveFile`
>
>   ```cpp
>   //函数原型
>   Http::serveFile(ResponseWriter& writer, const std::string& fileName,
>             const Mime::MediaType& contentType = Mime::MediaType());
>   ```
>
>   ```cpp
>   //依赖库pistache
>   Http::serveFile(res, fig, MIME(Application, Png));
>   ```

```cpp
/*
* 上传
*/ 

Routes::Post(RoutesManager::router, "/upload_doc/:mime/:name",
             Routes::bind(&cmd::uploadDocument));

void uploadDocument(const Rest::Request &request, Http::ResponseWriter response) 
{
    response.headers().add<Http::Header::ContentType>(MIME(Text, Plain));                          
    if(!request.hasParam(":name") || !request.hasParam(":mime"))
    {
        response.send(Http::Code::Bad_Request, "缺少参数");
        return;
    }
    string filename = request.param(":name").as<string>();
    string fileMime = request.param(":mime").as<string>();

    if (request.body().empty()) 
    {
        response.send(Http::Code::No_Content, "没有传入文件");
        return;
    }

    fs::path filePath("assets/images/");
    filePath /= filename;
    if (!fs::exists(filePath.parent_path())) 
    {
        response.send(Http::Code::Expectation_Failed, "Invalid path");
        return;
    }

    try 
    {
        //根据格式保存文件
        std::ofstream ofs;
        //图片
        if(fileMime == "png" || fileMime == "jpg" || fileMime == "jpeg" || fileMime == "gif" || fileMime == "bmp")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "pdf")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "xlsx")
        {
            ofs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "csv")
        {
            ofs.open(filePath);
        }

        if (!ofs.is_open())
        {
            response.send(Http::Code::Expectation_Failed, "failed to create: " + filename);
            return;
        }
        
        ofs.write(request.body().data(), request.body().size());
        ofs.close();
        response.send(Http::Code::Ok, filename + " uploaded!");
    } 
    catch (std::exception &e) 
    {
        logErr(e.what());
        response.send(Http::Code::Expectation_Failed, "Failed to upload: " + filename);
        return;
    }
}
```

```cpp
Routes::Get(RoutesManager::router, "/download_doc/:mime/:name", Routes::bind(&cmd::downloadDocument)); 

void downloadDocument(const Rest::Request &request, Http::ResponseWriter response)
{
    // response.headers().add<Http::Header::ContentType>(
    //   MIME3(Application, OctetStream, Zip));
    if(!request.hasParam(":name") || !request.hasParam(":mime"))
    {
        response.send(Http::Code::Bad_Request, "缺少参数");
        return;
    }

    string filename = request.param(":name").as<string>();
    string fileMime = request.param(":mime").as<string>();

    if (filename == "undefined") {
        response.send(Http::Code::No_Content, "没有指定pdf文件名");
        return;
    }

    fs::path filePath("assets/");//文件存储目录
    filePath /= filename;
    if (!fs::exists(filePath) || !fs::is_regular_file(filePath)) {
        cout << "file not exists: " << filePath.string() << endl;
        response.send(Http::Code::Expectation_Failed, "file not exists:" + filename);
        return;
    }

    try
    {
        std::ifstream ifs;
        if(fileMime== "png" || fileMime == "jpg" || fileMime == "jpeg" 
           || fileMime == "gif" || fileMime == "bmp" || fileMime == "pdf")
        {
            ifs.open(filePath, std::ifstream::binary);
        }
        else if(fileMime == "csv" || fileMime == "xlsx")
        {
            ifs.open(filePath);
        }    

        if (!ifs.is_open())
        {
            cout << "failed to open file: " << filePath << endl;
            response.send(Http::Code::Expectation_Failed, "failed to open: " + filename);
            return;
        }  

        if(fileMime == "png")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Png));
        }
        else if(fileMime == "jpg")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
        }
        else if(fileMime == "jpeg")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Jpeg));
        }
        else if(fileMime == "gif")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Gif));
        }
        else if(fileMime == "bmp")
        {
            response.headers().add<Http::Header::ContentType>(MIME(Image, Bmp));
        }
        else if(fileMime == "pdf")
        {
            response.headers().add<Http::Header::ContentType>("application/pdf; charset=utf-8");
        }
        else if(fileMime == "csv")
        {
            response.headers().add<Http::Header::ContentType>("text/csv; charset=utf-8");
        }
        else if(fileMime == "xlsx")
        {
            response.headers().add<Http::Header::ContentType>("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet; charset=utf-8");
        }

        //保存到文件
        int64_t fileSize = fs::file_size(filePath);
        unique_ptr<char[]> bufTmp = make_unique<char[]>(fileSize);
        char* bufTmpPtr = static_cast<char*>(bufTmp.get());
        ifs.read(bufTmpPtr, fileSize);
        auto stream = response.stream(Http::Code::Ok);
        while(ifs.gcount() > 0)
        {
            stream.write(bufTmpPtr, ifs.gcount());
            stream << flush;
            ifs.read(bufTmpPtr, fileSize);
        }
        ifs.close();
        stream << ends;
    }
    catch(const std::exception& e)
    {
        cout << "failed to download:" << filename << endl;
        logErr(e.what());
        response.send(Http::Code::Expectation_Failed, "failed to download: " + filename);
        return;
    }
}
```

## （2）zip压缩/解压缩

> [!NOTE]
>
> 库：`libzip`
>
> 目录：`usr/include/zip.h`

### 压缩

* `zip_open`创建zip文件，返回`zip_t*`
* `zip_source_file`打开文件为一个source，返回`zip_source_t*`
* `zip_file_add`把source添加到zip实现把文件添加到zip，返回`zip_int64_t`。错误时返回-1，调用`zip_source_free(source)`释放source。
* `zip_close`关闭zip文件。

```cpp
/*
* 打包压缩文件
*/
#include <stdlib.h>
#include <zip.h>
struct fileNode 
{
    string fileName;//文件名
    fs::path filePath;//文件路径
};

//zipPath形如/tmp/hzisemt.zip
//isRandomSuffix=true表示加上随机后缀生成临时文件，此时zipPath中路径将被改为加上后缀后的路径
//isRandomSuffix=false表示直接使用传入路径作为zip路径

//这里是随机生成zip临时文件名为/tmp/hzisemt.zip.XXXXXX，然后下载该文件。
//若想指定下载的zip文件名，可去掉mkstemp64按照文件名模板自动生成随机文件名的代码，而使用从request中解析出的filename
tl::expected<bool, string> packZip(const vector<fileNode>& fileList, string* zipPath, bool addRandomSuffix)
{
    //入参判断
    if(fileList.size()==0 || zipPath==nullptr)	
        return tl::make_unexpected(string("入参非法"));
    
    bool failure = false;
    int filesAddZipCount = 0;	//成功添加到zip中的文件数
    string zipPathSuffix = ".XXXXXX";
    string zipPathTmpStr = *zipPath + zipPathSuffix;
    char* zipPath_;//最后使用的zip路径
    
    if(addRandomSuffix)
    {
        *zipPath = zipPathTmpStr;
        memset(zipPath_, zipPathTmpStr.c_str(), zipPathTmpStr.size());
        zipPath_ = zipPathTmpStr.c_str(); //char zipName[] = "/tmp/hzisemt.zip.XXXXXX";
        
        int fd = mkstemp64(zipPath_);//mkstemp64会根据替换zipName中的XXXXXX为随机数字并创建临时文件，返回该文件的描述符
        close(fd);	//调用方通过zip文件名访问，不通过fd读写
    }
    else
    {
        zipPath_ = zipPath->c_str();
    }
    
    //创建zip文件
    zip_t* z = zip_open(zipPath_, ZIP_CREATE | ZIP_TRUNCATE, nullptr);
    if (!z) 
    {
        // 获取系统错误信息
        char sys_errbuf[256];
        zip_error_t error;
        zip_error_init_with_code(&error, error_code);
        snprintf(sys_errbuf, sizeof(sys_errbuf), 
                 "无法创建zip文件: %s (系统错误码: %d)",
                 zip_error_strerror(&error), 
                 zip_error_system_type(&error));
        zip_error_fini(&error);
        
        return tl::make_unexpected(string("zip_open failed:") + string(sys_errbuf));
    }
    
    //遍历文件下载列表
    for (auto file : files) 
    {
        //打开文件为一个source(把source添加到zip中实现添加文件到zip)
        zip_source_t* source = zip_source_file(z, file.filePath.c_str(), 0, 0);
        if (!source) 
        {
            if (fs::exists(zipPath_))
            	remove(zipPath_);	//打包失败，把生成的zip删除
            return tl::make_unexpected(string("zip_source_file failed"));
        }
        
        //把source添加到zip中，并返回该文件在zip中的index 
        zip_int64_t index = zip_file_add(z, file.fileName.c_str(), source, ZIP_FL_ENC_RAW);
        if (-1 == index/* || -1 == zip_set_file_compression(z, index, ZIP_CM_STORE, 0)*/) 
        {
            zip_source_free(source);//index=-1，文件保存失败，释放source，跳出循环终止后续文件的添加
            if (fs::exists(zipPath_))
                remove(zipPath_);	
            
            // 直接获取当前zip实例的错误信息
            const zip_error_t* zerror = zip_get_error(z);
            std::string errmsg = "添加文件失败: " + 
                std::string(zip_error_strerror(zerror)) +
                " (系统错误码: " + 
                std::to_string(zip_error_system_type(zerror)) + ")";
            
            return tl::make_unexpected(string("zip_file_add failed:") + errmsg);
        } 
        ++filesAddZipCount;//成功添加文件数+1
    }
    
    if (zip_close(z) == -1) //文件添加完毕，关闭zip
    {
        if (fs::exists(zipPath_))
            remove(zipPath_);	
        
        // 获取关闭时的错误信息
        const zip_error_t* zerror = zip_get_error(z);
        std::string errmsg = "关闭zip文件失败: " + 
            std::string(zip_file_strerror(z));

        // 注意：zip_close失败后需要手动保留错误信息
        zip_discard(z); // 必须调用以避免内存泄漏
        return tl::make_unexpected(string("zip_close failed:") + errmsg);
    }

    if (filesAddZipCount == 0) //zip内没文件
    {
        if (fs::exists(zipPath_))
            remove(zipPath_);	
    	return tl::make_unexpected(string("zip为空！"));
    }
    
    return true;
}
```

### 解压缩

* 使用`zip_open`打开一个压缩文件，并使用`zip_get_num_entries`获取压缩文件中的条目数。

* 遍历每个条目，使用`zip_stat_index`获取条目的基本信息。

* 使用`zip_fopen_index`打开条目，使用`zip_fread`读取其中的数据，并将解压后的数据写入本地文件。

```cpp
/*
* 解压缩，返回文件名列表
*/
#include <zip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


vector<string>& unPackZip(string zipPath, string zipUnPackPath)
{
    int err = 0;
    struct zip* zipfile = zip_open(zipPath.c_str(), ZIP_CHECKCONS, &err);
    if (!zipfile) 
    {
        printf("zip open failed: %d\n", err);
        return 1;
    }

    zip_int64_t num_entries = zip_get_num_entries(zipfile, 0);
    for (zip_int64_t i = 0; i < num_entries; i++) 
    {
        struct zip_stat stat;
        zip_stat_index(zipfile, i, 0, &stat);
        printf("the file name is: %s\n", stat.name);

        struct zip_file *entry = zip_fopen_index(zipfile, i, 0);
        if (!entry) 
        {
            printf("fopen index failed\n");
            continue;
        }

        FILE *fp = fopen(stat.name, "w+");
        if (!fp) 
        {
            printf("create local file failed\n");
            zip_fclose(entry);
            continue;
        }

        char buf[1024];
        zip_int64_t len = 0;
        while (len < stat.size) 
        {
            int read = zip_fread(entry, buf, sizeof(buf));
            if (read < 0) {
                printf("read file failed\n");
                break;
            }
            fwrite(buf, 1, read, fp);
            len += read;
        }

        fclose(fp);
        zip_fclose(entry);
    }

    zip_close(zipfile);
    return 0;
}
```

## （3）文件列表打包zip下载

> 打包函数+文件下载接口

```cpp
/*
* 数据保存为bin/csv/qfx，打包zip并下载
*/
Routes::Get(RoutesManager::router,
              "/download/:from_time/:to_time/:is_csv/:file_name",
              Routes::bind(&ms_comm::downloadRawDateFile));


void downloadRawDateFile(const Rest::Request &request,
                         Http::ResponseWriter response) {
  uint64_t fromTime = request.param(":from_time").as<uint64_t>();
  uint64_t toTime = request.param(":to_time").as<uint64_t>();
  auto isCsvId = request.param(":is_csv").as<int>();
  int dev_id = 0;

  auto conn = hzi::config.pConnPool->getConnection();

  auto rslt0 = conn.executeQuery(
      "SELECT dataFreq,dataLen,class_Id  FROM `e_mining_PCOSignalParm`");
  if (rslt0.next()) {
    hzi::miningFreq = rslt0.getInt("dataFreq");
    hzi::miningDateLen = rslt0.getInt("dataLen");
    hzi::mining_classId = rslt0.getInt("class_Id");
  }
  debugLog(" downloadRawDateFile start mergeMs1");
  // mergeEngDenity(fromTime, toTime);

  // response.send(Http::Code::No_Content, "此时间段内无数据！");
  // return;

  mergeMs(fromTime, toTime,dev_id)
      .map([&](DataFrame df) {
        auto dftmp = std::move(df);
        auto chns = dftmp.channels();
        auto tmStmp = dftmp.sampTime();
        auto deltT = dftmp.sampIntvl();
        auto points = dftmp.points();
        auto pretime = 0;

        int32_t *p32 = (int32_t *)dftmp.upData.get();
        // 开始下载数据
        struct fileNode {
          float sampIntvl;
          string fileName;
          string frmLoc;
          string csvLoc;
        };

        std::vector<fileNode> files; // 下载文件列表
        fileNode file;
        //  file.frmLoc = path.string();
        // file.csvLoc = "/tmp" +
        // file.frmLoc.substr(file.frmLoc.find_last_of('/'));
        file.csvLoc = "/tmp/" + std::to_string(tmStmp);
        // + (isCsv ? ".csv" : ".bin");
        file.fileName = std::to_string(tmStmp);
        float tmpf;
        vector<vector<float>> v;
        v.resize(chns);
        for (int ch = 0; ch < chns; ++ch) {
          v.at(ch).resize(points);
          for (int pt = 0; pt < points; ++pt) {
            v.at(ch).at(pt) = p32[ch * points + pt] * 3000.0 / 8388607.0;
          }
        }
        if (isCsvId == 0) {
          try {
            file.csvLoc += ".bin";
            file.fileName += ".bin";
            std::ofstream ofs(file.csvLoc, std::ofstream::binary);
            ofs.write(dftmp.upHead.get(), 32);
            ofs.write((char *)dftmp.upData.get(), chns * points * 4);
            ofs.close();

          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败：" + file.csvLoc);
            return;
          }

        } else if (isCsvId == 1) {
          file.csvLoc += ".csv";
          file.fileName += ".csv";
          try {
            std::ofstream ofs(file.csvLoc);
            ofs << chns << ',' << points << ',' << deltT << ',' << (int)pretime
                << std::endl;

            for (int j = 0; j < points; ++j) {
              for (int k = 0; k < chns; ++k) {
                ofs << v.at(k).at(j) << ",";
              }
              ofs << std::endl;
            }
            ofs.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败：" + file.csvLoc);
            return;
          }
        } else if (isCsvId == 2) {
          file.csvLoc += ".qfx";
          file.fileName += ".qfx";
          STQfxFileHead fhQfx;
          STQfxTraceHead thQfx;
          fhQfx.nTraceCount = chns;
          fhQfx.nSamplePoints = points;
          fhQfx.fSampleInterval = deltT;
          fhQfx.nAdvanPoints = (int)pretime;
          if (fhQfx.nTraceCount < 1 || fhQfx.nSamplePoints < 1 ||
              fhQfx.fSampleInterval < 1e-9f) {
            response.send(Http::Code::Expectation_Failed,
                          "文本数据文件错误：" + file.csvLoc);
            return;
          }

          fhQfx.uchSurveyUnit = QFX_SSU_MV;
          std::ofstream ofsQfx(file.csvLoc);
          ofsQfx.write(reinterpret_cast<char *>(&fhQfx), sizeof(STQfxFileHead));

          thQfx.nSamplePoints = fhQfx.nSamplePoints;
          thQfx.fSampleInterva = fhQfx.fSampleInterval;

          try {
            for (int k = 0; k < chns; ++k) {
              thQfx.uchTraceType = 1;
              thQfx.nTraceNum = thQfx.nOrgTraceNum = k + 1;
              ofsQfx.write(reinterpret_cast<char *>(&thQfx),
                           sizeof(STQfxTraceHead));
              for (int j = 0; j < points; ++j) {
                ofsQfx.write((char *)&v[k][j], sizeof(float));
              }
            }
            ofsQfx.close();
          } catch (std::exception e) {
            response.headers().add<Http::Header::ContentType>(
                "text/plain; charset='utf-8'");
            response.send(Http::Code::Expectation_Failed,
                          "保存文件失败 2：" + file.csvLoc);
            return;
          }
        }
        files.push_back(file);

#pragma region 生成压缩文件
        bool failure = false;
        char fileName[] = "/tmp/hzisemt.zip.XXXXXX";
        int fd = mkstemp64(fileName), filesCnt = 0;//返回的fd没用到，后面用文件名读写的文件
        if (files.size() > 0) 
        {
          zip_t *z = zip_open(fileName, ZIP_CREATE | ZIP_TRUNCATE, nullptr);
          if (z) {
            for (auto file : files) {
              zip_source_t *source =
                  zip_source_file(z, file.csvLoc.c_str(), 0, 0);
              if (source) {
                zip_int64_t index = zip_file_add(z, file.fileName.c_str(),
                                                 source, ZIP_FL_ENC_RAW);
                if (-1 == index/* || -1 == zip_set_file_compression(z, index, ZIP_CM_STORE, 0)*/) {
                  failure = true;
                  zip_source_free(source);
                  break;
                } else {
                  ++filesCnt;
                }
              }
            }
            int ret = zip_close(z);
            if (-1 == ret) {
              failure = true;
            }
          }
        }
        if (failure) {
          if (fs::exists(fileName)) {
            remove(fileName);
          }
          response.headers().add<Http::Header::ContentType>(
              "text/plain; charset='utf-8'");
          response.send(Http::Code::Expectation_Failed,
                        "无法生成 zip 压缩文件！");
          return;
        }
        if (0 == filesCnt) {
          response.headers().add<Http::Header::ContentType>(
              "text/plain; charset='utf-8'");
          response.send(Http::Code::No_Content, "此时间段内无数据！");
          return;
        }
#pragma endregion
        response.headers().add<Http::Header::ContentType>(
            MIME3(Application, OctetStream, Zip));
        constexpr int MAX_BUFFER_SIZE = 512;
        char streamBuffer[MAX_BUFFER_SIZE] = {};
        auto stream = response.stream(Http::Code::Ok);
        
        std::ifstream ifs(fileName);//通过文件名读文件
        
       	ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        while (ifs.gcount() > 0) {
          stream.write(streamBuffer, ifs.gcount());
          stream << flush;
          ifs.read(streamBuffer, MAX_BUFFER_SIZE);
        }
        ifs.close();
        stream << ends;
        close(fd);
      })
      .map_error([&](auto err) {
        if (hzi::config.verbose) {
          std::stringstream ss;
          logErr(ss.str());
        }
        response.headers().add<Http::Header::ContentType>(
            "text/plain; charset='utf-8'");
        response.send(Http::Code::Expectation_Failed, "NO data");
        return;
      });
}
```



# 25. 时间戳

---

## （1）UTC时间与UTC+8

> [!NOTE]
>
> * **UTC（协调世界时）** 和 **UTC+8（东八区时间）** 是两种不同的时间标准，主要区别在于 **时区偏移**。
>
>   **UTC 时间 = GMT（格林尼治标准时间）**（但 GMT 可能受地球自转影响，UTC 更精确）。UTC 是全球标准时间，基于原子钟计算，不受夏令时影响。
>
>   **UTC+8 表示比 UTC 快 8 小时，东八区，适用于中国**、新加坡、马来西亚、菲律宾等地区。**北京时间（CST, China Standard Time）**。中国全境统一使用 UTC+8。
>
>   如果 UTC 时间是 `2025-06-12 00:00:00`，那么：
>
>   UTC+8（北京时间）** 是 `2025-06-12 08:00:00`。
>
>   UTC-5（纽约时间） 是 `2025-06-11 19:00:00`（前一天）。

> [!CAUTION]
>
> * **unix时间戳是UTC时间，单位为s**
>
> * **代码中`uint64_t/time_t`一律使用UTC时间戳（标准时间）**
>
> * **库表中的`datetime`类型一律存当地时间（北京时间），存：`FROM_UNIXTIME(uint64_t)`获取当地时间，取：`UNIX_TIMESTAMP()`得到UTC时间戳**
>
> * MySQL会根据服务器所在时区选择UTC+8(服务器在中国)，`UNIX_TIMESTAMP(datetime)`会认为datetime是北京时间，先减去8小时得到UTC时间再计算时间戳。
>
>   比如：`UNIX_TIMESTAMP('2025-06-12 10:42:10')`，它会认为 `'2025-06-12 10:42:10'` 是北京时间，并转换成 UTC 时间（`2025-06-12 02:42:10`），再计算`2025-06-12 02:42:10`的时间戳 → **1749696130**

* 从UTC unix时间戳得到当地的时间

  比如：从`1749696130`获得`2025-06-12 10:42:10`，而不是`2025-06-12 02:42:10`

  ```cpp
  //timep：指向 time_t 类型的指针，表示从1970年1月1日00:00:00 UTC开始的秒数。
  //返回一个指向 struct tm 的指针，该结构体包含转换后的本地时间信息。如果转换失败，返回 NULL。
  struct tm* std::localtime(const time_t* timep);
  
  //localtime_r 是 localtime 的线程安全版本，localtime 是较早版本的函数
  struct tm* std::localtime_r(const time_t* timep, struct tm* result);
  ```

* 从当地时间得到UTC unix时间戳

  比如：从`2025-06-12 10:42:10`获得`1749696130`

  ```cpp
  //timeptr：指向 struct tm 的指针，该结构体包含要转换的本地时间信息。
  //返回一个 time_t 类型的时间戳，表示从1970年1月1日00:00:00 UTC开始的秒数。如果输入的 struct tm 无效，返回 -1。
  time_t std::mktime(struct tm* timeptr);
  
  time_t utc_timestamp = std::mktime(&local_tm); // 将本地时间转换为UTC时间戳
  ```

## （2）由unix时间戳（uint64_t或time_t）获取datetime

> [!NOTE]
>
> datetime在代码中以`std::tm`表示
>
> ```cpp
> #include <ctime>
> std::tm
> 
> struct tm
> {
>   int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
>   int tm_min;			/* Minutes.	[0-59] */
>   int tm_hour;			/* Hours.	[0-23] */
>   int tm_mday;			/* Day.		[1-31] */
>   int tm_mon;			/* Month.	[0-11] */
>   int tm_year;			/* Year	- 1900.  */
>   int tm_wday;			/* Day of week.	[0-6] */
>   int tm_yday;			/* Days in year.[0-365]	*/
>   int tm_isdst;			/* DST.		[-1/0/1]*/
> 
> # ifdef	__USE_MISC
>   long int tm_gmtoff;		/* Seconds east of UTC.  */
>   const char *tm_zone;		/* Timezone abbreviation.  */
> # else
>   long int __tm_gmtoff;		/* Seconds east of UTC.  */
>   const char *__tm_zone;	/* Timezone abbreviation.  */
> # endif
> };
> ```
>
> ```cpp
> //年份
> tm.tm_year+1900
> //月份
> tm.tm_year+1
> //日
> tm.tm_mday
> //星期
> tm.tm_wday+1
> ```

```cpp
//uint64_t--->std::tm
#include <ctime>
#include <cstdint>
int uint64_to_tm(uint64_t timestamp, struct tm* tm_ptr) //timestamp为秒时间戳
{
    // 将时间戳转换为 time_t 类型
    time_t time = static_cast<time_t>(timestamp);
    // 转换为本地时间
    localtime_r(&sec_timestamp, tm_ptr);
    return 0;
}

int uint64_to_tm(uint64_t timestamp, struct tm* tm_ptr) //timestamp为秒时间戳
{
    // 手动给UTC时间戳+8小时调整时区到东八区（北京时间），得到本地时间戳
    int64_t milli = timestamp + (int64_t)8 * 60 * 60 * 1000; 
    auto mTime = std::chrono::milliseconds(milli);
    auto tp = std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds>(mTime);
    auto tt = std::chrono::system_clock::to_time_t(tp);//chrono::time_point转time_t
    *tm_ptr = std::gmtime(&tt);
}

//C++20标准
#include <chrono>
#include <format>

void uint64_to_tm(uint64_t timestamp, struct tm* tm_ptr) 
{
    auto tp = std::chrono::system_clock::from_time_t(timestamp);
    zoned_time zt{"Asia/Shanghai", tp}; // 指定时区
    *tm_ptr = std::chrono::get_tm(zt);
}
```

## （3）datetime获取unix时间戳（uint64_t或time_t）

```cpp
//std::tm--->uint64_t
#include <ctime>
#include <chrono>
#include <cstdint>
uint64_t tm_to_uint64(const std::tm& tm_time) //返回秒
{
    // 将 std::tm 转换为 time_t
    std::time_t time_t_value = mktime(const_cast<std::tm*>(&tm_time));
    // 转换为 uint64_t
    return static_cast<uint64_t>(time_t_value);
}

// 将 std::chrono::system_clock::time_point 转换为 uint64_t 时间戳（秒为单位）
uint64_t chrono_to_uint64(const std::chrono::system_clock::time_point& time_point) 
{
    // 转换为秒
    auto duration = time_point.time_since_epoch();
    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration);
    return static_cast<uint64_t>(seconds.count());
}
```

## （4）由UTC unix毫秒时间戳获取`YYYY-MM-DD HH:MM:SS.mmm`字符串

```cpp
// utc unix毫秒时间戳（13位）获取YYYY-MM-DD HH:MM:SS.mmm字符串
std::string timestampToString(int64_t timestamp_ms) 
{
  // Convert milliseconds to seconds and remainder milliseconds
  std::time_t seconds = timestamp_ms / 1000;
  int milliseconds = timestamp_ms % 1000;

  //使用std::localtime函数将seconds（以秒为单位的时间）转换为本地时间，结果存储在tm结构体中
  std::tm *tm = std::localtime(&seconds);

  //存储格式化后的时间字符串（不包括毫秒部分）。大小为24，足以存储"YYYY-MM-DD HH:MM:SS"格式的字符串
  //将tm结构中的时间信息格式化为"YYYY-MM-DD HH:MM:SS"格式的字符串，并存储在buffer中
  char buffer[24];
  std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm);

  //将buffer中的字符串和毫秒部分拼接起来
  //std::setfill('0')设置填充字符为'0'，std::setw(3)设置字段宽度为3，确保毫秒部分总是三位数字，不足时前面补零。
  std::ostringstream oss;
  oss << buffer << '.' << std::setfill('0') << std::setw(3) << milliseconds;

  return oss.str();
}
```

## （5）HH:MM:SS时间字符串转成ms

```cpp
//将形如1:30:21格式时间段转换为毫秒数
static uint64_t timeStringToMillis(const std::string &timeString)
{
    int hours, minutes, seconds;
    sscanf(timeString.c_str(), "%d:%d:%d", &hours, &minutes, &seconds);
    return (hours * 3600 + minutes * 60 + seconds) * 1000;
}
```

## （6）YYYY-MM-DD HH:MM:SS.mmm字符串获取UTC unix毫秒时间戳（13位）

```cpp
//YYYY-MM-DD HH:MM:SS.mmm字符串获取utc unix毫秒时间戳（13位）
int64_t stringToTimestamp(const std::string &datetime_str) 
{
  std::tm tm = {};
  int milliseconds = 0;

  // Manually parse the string "YYYY-MM-DD HH:MM:SS.mmm"
  if (sscanf(datetime_str.c_str(), "%4d-%2d-%2d %2d:%2d:%2d.%3d", &tm.tm_year,
             &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec,
             &milliseconds) != 7) 
  {
    throw std::runtime_error("Failed to parse date-time string");
  }

  // Adjust fields for tm structure
  tm.tm_year -= 1900; // tm_year is years since 1900
  tm.tm_mon -= 1;     // tm_mon is 0-based (0 = January)

  // Convert to time_t (seconds since epoch) and add milliseconds
  std::time_t seconds = std::mktime(&tm);
  if (seconds == -1) 
  {
    throw std::runtime_error("Failed to convert to time_t");
  }

  return static_cast<int64_t>(seconds) * 1000 + milliseconds;
}
```

## （6）将yyyy-MM-dd hh:mm:ss字符串转成yyyyMMddhhmmss字符串

```cpp
std::string convertDateFormat(const std::string& date_str) 
{
    if (date_str.empty()) {
        throw std::invalid_argument("Input date string is empty");
    }

    // 检查输入长度是否符合 "YYYY-MM-DD HH:MM:SS"
    if (date_str.size() != 19) {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 提取并验证格式
    std::string year = date_str.substr(0, 4);
    std::string month = date_str.substr(5, 2);
    std::string day = date_str.substr(8, 2);
    std::string hour = date_str.substr(11, 2);
    std::string minute = date_str.substr(14, 2);
    std::string second = date_str.substr(17, 2);

    // 确保字符的位置符合标准格式
    if (date_str[4] != '-' || date_str[7] != '-' || date_str[10] != ' ' || 
        date_str[13] != ':' || date_str[16] != ':') {
        throw std::runtime_error("Invalid date string format: " + date_str);
    }

    // 合并为目标格式
    std::string result = year + month + day + hour + minute + second;
    return result;
}
```

## （8）获取当前UNIX时间戳

```cpp
uint64_t nowMS() 
{
    std::chrono::time_point<std::chrono::system_clock> now =
        std::chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    auto millis =
        std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();
    return millis;
}
```

## （9）根据时间戳获取当日零点时间戳

```cpp
//timestamp（单位ms）
//返回值（单位ms）
time_t midnight(uint64_t timestamp) 
{
    time_t tmt = timestamp / 1000;
    tm* pTM = localtime(&tmt);
    pTM->tm_hour = 0;
    pTM->tm_min = 0;
    pTM->tm_sec = 0;
    auto midnight_timet = mktime(pTM) * 1000;
    return midnight_timet;
}

uint64_t midnite = midnight(ms_now);    // 当天0点时间戳
```

## （10）库表中时间类型的选择

* 日期时间类型：`DATETIME(4)` 表示时间戳的精度为4位小数（毫秒级）。如果你需要更高的精度（例如微秒级），可以使用 `DATETIME(6)`
* 时间戳类型：存储`s/ms/us`，使用`bigint`

## （11）c++代码中时间类型

> [!NOTE]
>
> uint64_t和time_t可直接强转
>
> ```cpp
> std::time_t time_t_value;
> uint64_t uint64_value static_cast<uint64_t>(time_t_value);
> ```

* 日期时间类型：`std::tm`或`std::chrono::system_clock::time_point`

* 时间戳类型：`uint64_t`或`time_t`，这两者数值一致。

  **秒时间戳：10位整数。**

  **毫秒时间戳：13位整数。**

## （12）MySQL语句中时间戳处理

> * `time_t（time_t是时间戳epoch到现在的seconds）`或`uint_64`可表示秒，毫秒，微秒时间戳，精度够
> * 字段类型为时间戳：存，`time_t`或`uint_64`格式变量在`execute()`中执行插入到字段时，都要先转double（秒）或long long（微秒，微秒用long long约定俗成）。取，用`getDouble()`或`getLLong()`直接取库表里的字面值。
>
> * **比较时间先后，一律使用时间戳进行比较。datetime也先转成时间戳再比较！**

### 获取日期当天零点

```mysql
-- 获取指定datetime的当天0点
SELECT DATE_FORMAT(`datetime字段`, '%Y-%m-%d 00:00:00') AS midnight;

-- 获取现在时间的当天0点
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d 00:00:00') AS midnight;
```

### unix时间戳（int64_t或time_t）存取

* 库表字段数据类型假设为`bigint`，11位，但存入库中不直接存uint64_t，类型`time_t`或`uint64_t`需要转成double或long long才能被`libzdb`库的函数`execute`使用

  ```cpp
  //存入
  uint64_t tm;
  auto tmTmp = static_cast<long long>(tm);
  conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", tmTmp);
  或
  auto tmTmp = static_cast<double>(tm);
  conn.execute("UPDATE e_warning_Info SET is_sent_user=1 WHERE tm=?", tmTmp);
  ```

* 用`getDouble()`或`getLLong()`读取库表中unix时间戳字面值

  **`getDouble()`会不会是使用`getTimestamp()`？不要用getTimestamp()！！！！！**

  ```cpp
  //获取表内字面值，强转long long int。（无法获取字面值）
  auto rslt = conn.executeQuery("...");
  uint64_t tm = rslt.getLLong("tm");//一般用来取ms或us
  cout<<"tm="<<tm<<endl;//和数据库中所存的值相等
  或
  uint64_t tm = rslt.getDouble("tm");//用来取秒时间戳
  cout<<"tm="<<tm<<endl;//和数据库中所存的值不等
  cout<<"tm="<<(double)(tm)<<endl;//和数据库中所存字面值相等
  ```

### unix时间戳（int64_t或time_t）转成datetime存取

```cpp
//MySQL会根据服务器所在时区选择UTC+8(服务器在中国)
UNIX_TIMESTAMP(datetime)//datetime转unix时间戳(单位s，拿到datetime先减去8小时得到UTC时间再计算时间戳)
FROM_UNIXTIME(uint64_t)//unix时间戳(s)转datetime（拿到uint64_t转成datetime后加上8小时）
```

库表字段数据类型设为`datetime(4)`，秒后面4位小数。

调用函数`FROM_UNIXTIME()`将unix时间戳（单位s）转成`datetime`插入

datetime类型字段用`conn.getDateTime("field")`从查询结果中获取，获取结果是`struct tm`类型

```cpp
//int64_t或time_t--->datetime后存入
uint64_t tmStmp = dfVec[0]->sampTime();//ms

conn21.execute(
"INSERT INTO "
"e_mining_signaldata_frm_info "
"(dev_id,samp_time,class_id,samp_intvl,valNum,vecSize,outLen,frm_"
"loc,fx,fy,fz,dis)"
"values(?,FROM_UNIXTIME(?),?,?,?,?,?,?,?,?,?,?) "//ms转成datetime
" ON DUPLICATE KEY UPDATE samp_intvl= values(samp_intvl),valNum= "
"values(valNum),vecSize= values(vecSize),outLen= values(outLen)",
(uint8_t)devId,  // dev_id
(double)tmStmp / 1000.0, // tmStmp是uint64_t毫秒时间戳，转秒，因此要再转double
classId2,        // class_id
deltT,           // curt_ch
valNum,          // channels
vecSize,
pcoParm.outLen, // ch_pnts
(relLocFromTime(tmStmp) / std::to_string(classId2) / std::to_string(tmStmp)).c_str(), // frm_loc
pcoLocParm.fx,
pcoLocParm.fy,
pcoLocParm.fz,
pcoLocParm.dis_y);

//datetime--->int64_t或time_t取出
auto rslt = conn.executeQuery("SELECT UNIX_TIMESTAMP(field) from table");
uint64_t tm = rslt.getLLong("field");

//直接读取datetime类型字段，获取struct tm类型（若需要uint64_t类型可再转）
std::tm = conn.getDateTime("field");
```

> ### 1. **`time_t`**
>
> - **定义**：`time_t` 是 C 和 C++ 标准库中用于表示时间的类型，通常用于表示从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的秒数（即 Unix 时间戳）。
> - **类型**：`time_t` 的具体实现依赖于平台和编译器，但通常是 `long` 或 `long long` 类型。在大多数现代系统中，`time_t` 是一个 64 位有符号整数。
> - **用途**：主要用于时间相关的操作，如获取当前时间、时间间隔计算等。
> - **范围**：由于 `time_t` 是有符号整数，其范围通常是 `-2^63` 到 `2^63-1`（在 64 位系统中）。
>
> ### 2. **`uint64_t`**
>
> - **定义**：`uint64_t` 是 C++ 标准库中定义的无符号 64 位整数类型，属于 `<cstdint>` 头文件中的固定宽度整数类型。
> - **类型**：`uint64_t` 是一个无符号 64 位整数。
> - **用途**：用于需要精确表示 64 位无符号整数的场景，如大整数计算、文件大小、内存地址等。
> - **范围**：`0` 到 `2^64-1`。
>
> ### 对比
>
> | 特性       | `time_t`                | `uint64_t`             |
> | :--------- | :---------------------- | :--------------------- |
> | **类型**   | 通常是 64 位有符号整数  | 64 位无符号整数        |
> | **范围**   | `-2^63` 到 `2^63-1`     | `0` 到 `2^64-1`        |
> | **用途**   | 时间相关的操作          | 大整数计算、文件大小等 |
> | **标准库** | `<ctime>` 或 `<chrono>` | `<cstdint>`            |

# 26. 字符串处理

---

## （1）字符分割

```cpp
//deli作为分割，从origStr中分割出子字符，保存到vals中
void splitStr(const string &origStr, char deli, std::vector<string> &vals) {
    string str = origStr;

    while (!str.empty()) {
        auto pos = str.find_first_of(deli);
        if (pos == string::npos) {
            // 如果找不到分隔符，将剩余字符串作为最后一个部分
            vals.push_back(str);
            break;
        } else {
            // 提取当前部分并更新剩余字符串
            vals.push_back(str.substr(0, pos));
            str = str.substr(pos + 1); // 更新剩余字符串
        }
    }
}
```

# 27. 数值计算

---

## （1）整数幂计算

```cpp
//base^power
int safePow(int base, unsigned int power) 
{
  if (power == 0) 
  {
    return 1;
  }
  int p = 1;
  for (int i = 0; i < power; i++) 
  {
    p *= base;
  }
  return p;
}
```

## （2）双精度数值格式化为保留两位小数的字符串

```cpp
// 格式化函数：将双精度数值格式化为保留两位小数的字符串
std::string formatDouble(double value, int fmat) {
  std::ostringstream oss;
  oss << std::fixed << std::setprecision(fmat) << value;
  std::string str = oss.str();

  // If the number is an integer, remove the decimal part
  if (std::fabs(value - static_cast<int>(value)) < 1e-9) {
    str.erase(str.find('.'));
  } else {
    // Remove trailing zeros
    str.erase(str.find_last_not_of('0') + 1, std::string::npos);
    // If there is a dangling decimal point, remove it
    if (str.back() == '.') {
      str.pop_back();
    }
  }

  return str;
}
```

## （3）计算字节形式存储的整数的均值

```cpp
double avg(const char *p, int from, int to) {
  int64_t sum = 0;
  for (int i = from; i < to; i++) {
    sum += *(int32_t *)(p + i * 4);
  }
  return sum / (to - from);
}
```

## （4）fabsf

> `fabsf` 是一个 C 标准库中的数学函数，用于计算单精度浮点数的绝对值。
>
> ```cpp
> float fabsf(float x);
> ```
>
> 

## （5）floor()

`floor()` 函数是一个数学函数，用于计算小于或等于给定数值的最大整数

# 28.异常

---

## （1）使用tl::expected库处理异常

>  expected，替代bool或返回码。
>
> 好处：简便的将异常的详细信息返回到调用处使用。可链式调用。

```cpp
static tl::expected<Document, string> jsonDocFromFile(string const &file) {
    FILE *fp = fopen(file.c_str(), "r");
    if (!fp)
      return tl::make_unexpected("failed opening file: " + file);

    char readBuf[1024];
    FileReadStream frs(fp, readBuf, sizeof(readBuf));
    Document doc;

    if (doc.ParseStream<kParseCommentsFlag>(frs).HasParseError()) {
      return tl::make_unexpected("jsonDocFromFile: invalid json file:" + file);
    }
    return std::move(doc);
  }
```

* 比较and_then与or_else，map与map_erro的区别

```cpp
//and_then和or_else 
return jsonDocFromFile(jsonConf).and_then([&](Document doc) -> tl::expected<Config, string> 
     	{
            ...
        })
     	.or_else([&](string unexpect) -> tl::expected<Config, string>
    	{
            ...
        });
```

```cpp
//map和map_error

```

## （2）throw抛异常

throw抛异常后，代码将终止，不会执行throw之后的语句。

throw一般用于抛异常到上层代码，让其捕获处理。

但目前来说，写代码，最好那里发生哪里捕获哪里处理，不要往上层抛。

## （3）多个catch

多个catch，前面的catch捕获异常后，后面的catch不会再捕获异常并处理。

# 29. Makefile

```makefile
# cxx = /usr/bin/g++
cxx = nvc++
base_version = NEWBASE
stdpar = multicore
# ARCH ?= native  # 默认架构，使用本机架构

target = ../../hzisemt
major_srcs = $(shell find . -type d \( -path ./bkups -o -path ./on_gpu -o -path ./python -o -path ./python2cpp \) -prune -false -o -name "*.cpp")
major_objs = $(major_srcs:%.cpp=%.o)

gpu_srcs = $(shell find ./on_gpu -name "*.cpp")
gpu_objs = $(gpu_srcs:%.cpp=%.o)

# cflags = -I/usr/local/include/zdb  -I/usr/local/include/pistache -I/opt/pistache/include -I./  -std=c++23 -fPIC -fcoroutines -Wno-deprecated  -O3 -fpermissive -D${base_version}
# cflags = -I/opt/oldzdb/include/zdb  -I/usr/local/include/pistache -I/usr/include/python3.11 -I/opt/anaconda3/lib/python3.11/site-packages/numpy/core/include -I/usr/include/eigen3 -I/usr/include/openssl -I./  -std=c++23 -fPIC -fcoroutines -Wno-deprecated  -O3 -fpermissive -D${base_version}
cflags = -I/opt/oldzdb/include/zdb -I/usr/local/include/pistache -I/usr/include/eigen3 -I/usr/include/openssl -I./ -std=c++23 -fPIC -fcoroutines -Wno-deprecated -O3 -fpermissive -D${base_version}

# for skylake：
# cflags = -I/opt/oldzdb/include/zdb -I/usr/local/include/pistache -I/usr/include/eigen3 -I/usr/include/openssl -I./ -std=c++23 -fPIC -fcoroutines -Wno-deprecated -O1 -fpermissive -D${base_version} -tp=$(ARCH) -Minfo=all 

$(major_objs): mcflags := -stdpar=multicore 
$(gpu_objs): gcflags := -stdpar=${stdpar} 

lnkflags = -L/usr/local/lib -L/usr/lib/x86_64-linux-gnu -L/lib/x86_64-linux-gnu -L/opt/oldzdb/lib -lpthread -lzdb -lpistache -lzip -lssl -lcrypto -lceres -lglog -lcurl -lmariadb -lmysqlclient -lrdkafka++ -lrdkafka -Wl,-rpath,/usr/lib/x86_64-linux-gnu
#$(shell python3-config --ldflags)

$(target): $(major_objs) $(gpu_objs)
	$(cxx) $(cflags) -stdpar=$(stdpar) -o $(target) $(lnkflags) $(major_objs) $(gpu_objs)

main.o: main.cpp
	$(cxx) $(cflags) $(mcflags) -c main.cpp -o main.o

%.o: %.cpp %.hpp Config.hpp resis_handler.hpp FrameQueue.hpp
	$(cxx) $(cflags) $(mcflags) $(gcflags) -c $< -o $@ 

clean:
	rm -f *.o web/*.o DataImage/*.o algorithms/msl/*.o on_gpu/*.o ../../hzisemt
```

