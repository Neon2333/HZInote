# 1. 方案流程

### 1. 整体架构

```plaintext
┌────────┐          ┌──────────────┐          ┌────────────────┐
│ 闲鱼   │  Webhook │  C++ Service │ REST API │ BaiduPCS-Go    │
│ 订单   │─────────►│   (Pistache) │─────────►│(Go 二进制)     │
└────────┘ (HTTPS)  └──────────────┘  exec    └────────────────┘
                              ▲
                              │SQLite
```

- **服务https接口完整的 URL** 贴到 **「闲管家→开发者中心→Webhook 地址」** 即可
- **闲鱼** 通过「闲管家」的 Webhook 把「已付款」事件推送到你的 HTTPS 接口；  
- **C++ Service** 接收事件 → 查询订单对应的文件 → 调用 **BaiduPCS-Go** 生成 **7 天有效+随机 4 位密码** 的分享 → 把链接/密码发回闲鱼聊天。  
- **BaiduPCS-Go** 是官方兼容的命令行客户端（Go 实现，跨平台，可嵌入脚本）。  

### 2. 环境准备（Ubuntu 22.04 举例）

#### 2.1 安装依赖

```bash
sudo apt update
sudo apt install -y build-essential git libssl-dev libpistache-dev libsqlite3-dev
```

#### 2.2 安装 Go

```bash
wget https://go.dev/dl/go1.21.4.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.4.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin
```

#### 2.3 编译 BaiduPCS-Go

```bash
git clone https://github.com/qjfoidnh/BaiduPCS-Go.git
cd BaiduPCS-Go
go build -o /usr/local/bin/baidupcs
```

#### 2.4 登录百度网盘

```bash
baidupcs login --cookies-from-browser chrome   # 或手机扫码
# 成功后 ~/.baidupcs.json 里就存了 BDUSS、STOKEN
```

### 3. C++ 胶水服务（最小可运行示例）

#### 3.1 安装 Pistache

```bash
sudo apt install -y libpistache-dev
```

#### 3.2 编写 C++ 服务

```cpp
#include <pistache/endpoint.h>
#include <pistache/http.h>
#include <pistache/router.h>
#include <sqlite3.h>
#include <cstdlib>
#include <chrono>
#include <random>
#include <iostream>
#include <string>
#include <sstream>

using namespace Pistache;
using namespace Pistache::Http;
using namespace Pistache::Rest;

std::string exec(const char* cmd) {
    char buffer[128];
    std::string result;
    FILE* pipe = popen(cmd, "r");
    if (!pipe) return "";
    while (fgets(buffer, sizeof(buffer), pipe) != nullptr)
        result += buffer;
    pclose(pipe);
    return result;
}

std::string createShare(const std::string& path, int days = 7) {
    char pwd[5];
    static const char alphanum[] = "0123456789";
    for (int i = 0; i < 4; ++i) pwd[i] = alphanum[rand() % 10];
    pwd[4] = 0;

    std::string cmd = fmt::format("baidupcs share -p {} --period-time {} {}", pwd, days, path);
    std::string out = exec(cmd.c_str());
    // 解析返回的 share link，略
    return out + " 提取码：" + pwd;
}

void webhookHandler(const Request& request, Http::ResponseWriter response) {
    std::string body = request.body();
    std::cout << "Received webhook: " << body << std::endl;

    // 解析 JSON
    nlohmann::json bodyJson = nlohmann::json::parse(body);
    std::string sku = bodyJson["sku"];
    std::string buyer = bodyJson["buyer_id"];

    // 1. 查 SKU -> 文件路径
    std::string path = "/资源/" + sku + ".zip";

    // 2. 生成一次性分享
    std::string share = createShare(path);

    // 3. 通过闲鱼开放平台发消息（略）
    // curl -X POST https://api.xianyu.com/message/send ...

    response.send(Http::Code::Ok, share);
}

int main() {
    std::string address = "0.0.0.0";
    std::string port = "8080";
    std::string certFile = "/path/to/your/cert.pem";
    std::string keyFile = "/path/to/your/key.pem";

    Pistache::Address addr(address, Pistache::Port(std::stoi(port)));
    Http::Endpoint server(addr);

    server.init(10);
    server.setHandler(Http::make_handler<Rest::Router>([](Rest::Router& router) {
        router.Post("/webhook", webhookHandler);
    }));

    server.setSsl(certFile, keyFile);
    server.serve();

    return 0;
}
```

#### 3.3 编译服务

```bash
g++ -std=c++20 service.cpp -lssl -lcrypto -lpthread -lsqlite3 -lpistache -o service
```

#### 3.4 运行服务

```bash
nohup ./service &
```

### 4. HTTPS 证书设置

#### 4.1 获取证书

1. **使用 Let's Encrypt 证书**  
   - 安装 Certbot：

     ```bash
     sudo apt install certbot
     ```

   - 申请证书：

     ```bash
     sudo certbot certonly --standalone -d yourdomain.com
     ```

   - 证书文件路径：

     ```plaintext
     /etc/letsencrypt/live/yourdomain.com/fullchain.pem
     /etc/letsencrypt/live/yourdomain.com/privkey.pem
     ```

2. **手动上传证书**  
   - 如果你有自签名证书或从 CA 获取的证书，将其上传到 `/path/to/your/` 目录。

#### 4.2 配置 Nginx

#####  Nginx 配置文件的位置和结构

Nginx 的配置文件通常位于 `/etc/nginx/` 目录下。具体的配置文件结构如下：

- **主配置文件**：`/etc/nginx/nginx.conf`
  这是 Nginx 的主配置文件，通常包含全局配置和一些默认的服务器块（`server`）配置。
- **站点配置文件**：`/etc/nginx/sites-available/`
  这个目录下可以存放各个站点的配置文件。通常，每个站点（如 `yourdomain.com`）会有一个单独的配置文件，例如 `yourdomain.com.conf`。
- **启用的站点**：`/etc/nginx/sites-enabled/`
  这个目录下存放的是实际启用的站点配置文件的符号链接。通过将 `sites-available` 中的配置文件链接到 `sites-enabled`，可以启用对应的站点。

##### 配置文件示例

假设你的域名是 `yourdomain.com`，你可以创建一个配置文件 `/etc/nginx/sites-available/yourdomain.com.conf`，并写入以下内容：

```nginx
server {
    listen 443 ssl;
    server_name yourdomain.com;	# 设定域名

    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

##### 启用配置文件

1. **创建符号链接**：将 `sites-available` 中的配置文件链接到 `sites-enabled`。

   ```bash
   sudo ln -s /etc/nginx/sites-available/yourdomain.com.conf /etc/nginx/sites-enabled/
   ```

2. **检查配置文件语法**：确保配置文件没有语法错误。

   ```bash
   sudo nginx -t
   ```

3. **重启 Nginx**：应用新的配置。

   ```bash
   sudo systemctl restart nginx
   ```

#### 4.3 关于域名

服务器直接暴露给用户使用的时候，需要申请域名。

虽然直接用云服务器外网 IP 填nginx配置的 `server_name` 字段可以工作（`server_name 123.45.67.89;`），但出于 **安全性、可扩展性、用户体验** 的考虑，强烈建议申请域名（哪怕免费的）。

1. **安全性问题**
   - **暴露服务器 IP**：直接暴露服务器真实 IP，容易被攻击者定位到服务器位置，增加被 DDoS 攻击的风险。
   - **证书问题**：SSL/TLS 证书通常绑定域名，而不是 IP 地址。如果用 IP，可能需要自签名证书，这会导致浏览器安全警告，降低用户信任度。
2. **可扩展性差**
   - **IP 变更**：云服务器的外网 IP 可能会变（如更换实例、续费失败等），每次变更都需要修改 Nginx 配置并重启，很麻烦。
   - **负载均衡**：未来如果想扩展到多台服务器，用域名可以轻松实现负载均衡，而 IP 则做不到。

#### 4.4 注意接口是给内部服务使用，不需要申请域名也可

如果这个接口**仅用于内部服务**（如给闲管家使用，不直接暴露给终端用户），那么使用外网 IP 是完全可以的，而且相对简单直接。

##### 使用外网 IP 的优势：

1. **简单快捷**：无需申请域名，直接使用服务器的外网 IP，配置简单。
2. **成本低**：省去了域名注册和管理的费用。
3. **快速部署**：适合临时测试或内部服务，快速启动和运行。

### 5. 定时清理脚本（防止忘记撤销）

```bash
# /etc/cron.daily/cleanup_share
#!/bin/bash
baidupcs listshared --show-all | grep -E '7天.*过期' | awk '{print$1}' | \
xargs -I {} baidupcs cancelshared {}
```

### 6. 部署清单

- **云服务器**：1 核 1 G 即可（仅跑脚本，无流量峰值）。  
- **域名 + HTTPS**：Let’s Encrypt 自动续签。  
- **防火墙**：仅开放 443 端口。  
- **备份**：每晚把 `~/.baidupcs.json` 和 SQLite 备份到 OSS。

### 7. 运行效果

买家下单后，10 秒内收到一条：

```
下载地址：https://pan.baidu.com/s/1xxxx  提取码：7k2m  7 天后失效。
```

链接永不重复，泄露也最多 7 天。

这样 **10 分钟** 就能跑通，零代码、零服务器、7 天自动失效、不可二次分享的完整自动发货链路。



# 2. QA

### 1. Nginx 的作用

在你的系统架构中，**Nginx** 主要起到 **反向代理** 和 **HTTPS 终端** 的作用。具体来说：

#### 1.1 反向代理

- `0.0.0.0`：服务会监听服务器所有网卡（包括公网 IP），外网可直接访问 `https://<服务器公网IP>:8080`，绕过了 Nginx。
- `127.0.0.1`：服务只监听本地回环，**外网无法直连**，所有流量必须经过 Nginx 转发，符合「反向代理」的设计。

- **反向代理** 的作用是将外部请求转发到内部服务（你的 C++ 服务）。  

  关于监听地址：
  当 Nginx 作为反向代理时，C++ 服务 **只需暴露给本机** 即可，因此把

  ```cpp
  std::string address = "0.0.0.0";
  ```

  改为

  ```cpp
  std::string address = "127.0.0.1";
  ```

  是 **更安全的做法**。只监听本地回环地址的端口`127.0.0.1:8080`，外部通过服务器外网ip是无法访问的

- 当用户访问你的域名（如 `https://yourdomain.com/webhook`）时，Nginx 接收到请求后，会将请求转发到本地运行的 C++ 服务（假设运行在 `http://127.0.0.1:8080`）。

  **当 Nginx 配置了 SSL 证书后，它会处理所有的 HTTPS 请求。**具体流程如下：

  1. **客户端请求**：客户端通过 HTTPS 发起请求到你的域名（如 `https://yourdomain.com`）。
  2. **Nginx 解密**：Nginx 接收到请求后，使用 SSL 证书解密请求。
  3. **转发请求**：Nginx 将解密后的 HTTP 请求转发到你的 C++ 服务（假设运行在 `http://127.0.0.1:8080`）。
  4. **处理响应**：C++ 服务处理请求并返回 HTTP 响应。
  5. **Nginx 加密**：Nginx 接收到响应后，使用 SSL 证书对响应进行加密，再发送给客户端。

- 这样做的好处是：
  - **隐藏内部服务**：外部用户只能看到 Nginx 的 IP 和端口，而不知道内部服务的具体地址，增加了安全性。
  - **负载均衡**：如果未来需要扩展，可以将请求分发到多个后端服务实例。
  - **缓存**：Nginx 可以缓存静态资源，减少后端服务的负载。

#### 1.2 HTTPS 终端

- **HTTPS 终端** 的作用是处理 SSL/TLS 加密。

  **就无需在后端代码中手动调用` app.useSSL("etc/cert/xxx.pem","etc/cert/xxx.key");`来进行https加密了。**

- 当用户通过 HTTPS 访问你的服务时，Nginx 负责解密请求，并将解密后的请求转发给后端服务。  

- 同时，Nginx 也会对后端服务返回的响应进行加密，再发送给用户。

- 这样做的好处是：
  - **安全**：确保数据在传输过程中是加密的，防止中间人攻击。
  - **简化后端服务**：后端服务（C++ 服务）不需要自己处理 SSL/TLS 加密，只需处理普通的 HTTP 请求。

### 2. 定时清理脚本的作用

**定时清理脚本** 的作用是 **定期清理过期的百度网盘分享链接**，以防止这些链接被滥用或泄露。

#### 2.1 为什么需要清理

- 当你为每个买家生成一个 **7 天有效** 的百度网盘分享链接时，这些链接在 7 天后应该自动失效。  
- 但是，百度网盘本身没有自动清理过期分享链接的功能。  
- 如果不清理，这些链接可能会被恶意利用，或者被搜索引擎爬取，导致资源泄露。

#### 2.2 脚本逻辑

定时清理脚本的逻辑如下：

1. **列出所有分享链接**：使用 `baidupcs listshared --show-all` 命令列出所有当前有效的分享链接。
2. **筛选过期链接**：通过 `grep` 和 `awk` 筛选出即将过期（如 7 天后）的链接。
3. **取消分享**：使用 `baidupcs cancelshared` 命令取消这些过期链接的分享。

#### 2.3 脚本示例

```bash
# /etc/cron.daily/cleanup_share
#!/bin/bash
baidupcs listshared --show-all | grep -E '7天.*过期' | awk '{print$1}' | \
xargs -I {} baidupcs cancelshared {}
```

#### 2.4 定时任务

- 将上述脚本保存为 `/etc/cron.daily/cleanup_share`，并确保其可执行：

  ```bash
  sudo chmod +x /etc/cron.daily/cleanup_share
  ```

- 系统会自动每天运行 `/etc/cron.daily` 目录下的脚本，确保每天清理过期的分享链接。

### 总结

- **Nginx** 的作用是：
  - **反向代理**：将外部请求转发到内部服务。
  - **HTTPS 终端**：处理 SSL/TLS 加密，确保数据传输安全。

- **定时清理脚本** 的作用是：
  - **定期清理过期的百度网盘分享链接**，防止资源泄露或被滥用。

通过这两者的结合，你的系统不仅能够安全地处理 HTTPS 请求，还能自动管理过期的分享链接，确保系统的安全性和可靠性。